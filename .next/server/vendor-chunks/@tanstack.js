"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareItems: () => (/* binding */ compareItems),\n/* harmony export */   rankItem: () => (/* binding */ rankItem),\n/* harmony export */   rankings: () => (/* binding */ rankings)\n/* harmony export */ });\n/**\n   * match-sorter-utils\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */\nconst characterMap = {\n  À: 'A',\n  Á: 'A',\n  Â: 'A',\n  Ã: 'A',\n  Ä: 'A',\n  Å: 'A',\n  Ấ: 'A',\n  Ắ: 'A',\n  Ẳ: 'A',\n  Ẵ: 'A',\n  Ặ: 'A',\n  Æ: 'AE',\n  Ầ: 'A',\n  Ằ: 'A',\n  Ȃ: 'A',\n  Ç: 'C',\n  Ḉ: 'C',\n  È: 'E',\n  É: 'E',\n  Ê: 'E',\n  Ë: 'E',\n  Ế: 'E',\n  Ḗ: 'E',\n  Ề: 'E',\n  Ḕ: 'E',\n  Ḝ: 'E',\n  Ȇ: 'E',\n  Ì: 'I',\n  Í: 'I',\n  Î: 'I',\n  Ï: 'I',\n  Ḯ: 'I',\n  Ȋ: 'I',\n  Ð: 'D',\n  Ñ: 'N',\n  Ò: 'O',\n  Ó: 'O',\n  Ô: 'O',\n  Õ: 'O',\n  Ö: 'O',\n  Ø: 'O',\n  Ố: 'O',\n  Ṍ: 'O',\n  Ṓ: 'O',\n  Ȏ: 'O',\n  Ù: 'U',\n  Ú: 'U',\n  Û: 'U',\n  Ü: 'U',\n  Ý: 'Y',\n  à: 'a',\n  á: 'a',\n  â: 'a',\n  ã: 'a',\n  ä: 'a',\n  å: 'a',\n  ấ: 'a',\n  ắ: 'a',\n  ẳ: 'a',\n  ẵ: 'a',\n  ặ: 'a',\n  æ: 'ae',\n  ầ: 'a',\n  ằ: 'a',\n  ȃ: 'a',\n  ç: 'c',\n  ḉ: 'c',\n  è: 'e',\n  é: 'e',\n  ê: 'e',\n  ë: 'e',\n  ế: 'e',\n  ḗ: 'e',\n  ề: 'e',\n  ḕ: 'e',\n  ḝ: 'e',\n  ȇ: 'e',\n  ì: 'i',\n  í: 'i',\n  î: 'i',\n  ï: 'i',\n  ḯ: 'i',\n  ȋ: 'i',\n  ð: 'd',\n  ñ: 'n',\n  ò: 'o',\n  ó: 'o',\n  ô: 'o',\n  õ: 'o',\n  ö: 'o',\n  ø: 'o',\n  ố: 'o',\n  ṍ: 'o',\n  ṓ: 'o',\n  ȏ: 'o',\n  ù: 'u',\n  ú: 'u',\n  û: 'u',\n  ü: 'u',\n  ý: 'y',\n  ÿ: 'y',\n  Ā: 'A',\n  ā: 'a',\n  Ă: 'A',\n  ă: 'a',\n  Ą: 'A',\n  ą: 'a',\n  Ć: 'C',\n  ć: 'c',\n  Ĉ: 'C',\n  ĉ: 'c',\n  Ċ: 'C',\n  ċ: 'c',\n  Č: 'C',\n  č: 'c',\n  C̆: 'C',\n  c̆: 'c',\n  Ď: 'D',\n  ď: 'd',\n  Đ: 'D',\n  đ: 'd',\n  Ē: 'E',\n  ē: 'e',\n  Ĕ: 'E',\n  ĕ: 'e',\n  Ė: 'E',\n  ė: 'e',\n  Ę: 'E',\n  ę: 'e',\n  Ě: 'E',\n  ě: 'e',\n  Ĝ: 'G',\n  Ǵ: 'G',\n  ĝ: 'g',\n  ǵ: 'g',\n  Ğ: 'G',\n  ğ: 'g',\n  Ġ: 'G',\n  ġ: 'g',\n  Ģ: 'G',\n  ģ: 'g',\n  Ĥ: 'H',\n  ĥ: 'h',\n  Ħ: 'H',\n  ħ: 'h',\n  Ḫ: 'H',\n  ḫ: 'h',\n  Ĩ: 'I',\n  ĩ: 'i',\n  Ī: 'I',\n  ī: 'i',\n  Ĭ: 'I',\n  ĭ: 'i',\n  Į: 'I',\n  į: 'i',\n  İ: 'I',\n  ı: 'i',\n  Ĳ: 'IJ',\n  ĳ: 'ij',\n  Ĵ: 'J',\n  ĵ: 'j',\n  Ķ: 'K',\n  ķ: 'k',\n  Ḱ: 'K',\n  ḱ: 'k',\n  K̆: 'K',\n  k̆: 'k',\n  Ĺ: 'L',\n  ĺ: 'l',\n  Ļ: 'L',\n  ļ: 'l',\n  Ľ: 'L',\n  ľ: 'l',\n  Ŀ: 'L',\n  ŀ: 'l',\n  Ł: 'l',\n  ł: 'l',\n  Ḿ: 'M',\n  ḿ: 'm',\n  M̆: 'M',\n  m̆: 'm',\n  Ń: 'N',\n  ń: 'n',\n  Ņ: 'N',\n  ņ: 'n',\n  Ň: 'N',\n  ň: 'n',\n  ŉ: 'n',\n  N̆: 'N',\n  n̆: 'n',\n  Ō: 'O',\n  ō: 'o',\n  Ŏ: 'O',\n  ŏ: 'o',\n  Ő: 'O',\n  ő: 'o',\n  Œ: 'OE',\n  œ: 'oe',\n  P̆: 'P',\n  p̆: 'p',\n  Ŕ: 'R',\n  ŕ: 'r',\n  Ŗ: 'R',\n  ŗ: 'r',\n  Ř: 'R',\n  ř: 'r',\n  R̆: 'R',\n  r̆: 'r',\n  Ȓ: 'R',\n  ȓ: 'r',\n  Ś: 'S',\n  ś: 's',\n  Ŝ: 'S',\n  ŝ: 's',\n  Ş: 'S',\n  Ș: 'S',\n  ș: 's',\n  ş: 's',\n  Š: 'S',\n  š: 's',\n  Ţ: 'T',\n  ţ: 't',\n  ț: 't',\n  Ț: 'T',\n  Ť: 'T',\n  ť: 't',\n  Ŧ: 'T',\n  ŧ: 't',\n  T̆: 'T',\n  t̆: 't',\n  Ũ: 'U',\n  ũ: 'u',\n  Ū: 'U',\n  ū: 'u',\n  Ŭ: 'U',\n  ŭ: 'u',\n  Ů: 'U',\n  ů: 'u',\n  Ű: 'U',\n  ű: 'u',\n  Ų: 'U',\n  ų: 'u',\n  Ȗ: 'U',\n  ȗ: 'u',\n  V̆: 'V',\n  v̆: 'v',\n  Ŵ: 'W',\n  ŵ: 'w',\n  Ẃ: 'W',\n  ẃ: 'w',\n  X̆: 'X',\n  x̆: 'x',\n  Ŷ: 'Y',\n  ŷ: 'y',\n  Ÿ: 'Y',\n  Y̆: 'Y',\n  y̆: 'y',\n  Ź: 'Z',\n  ź: 'z',\n  Ż: 'Z',\n  ż: 'z',\n  Ž: 'Z',\n  ž: 'z',\n  ſ: 's',\n  ƒ: 'f',\n  Ơ: 'O',\n  ơ: 'o',\n  Ư: 'U',\n  ư: 'u',\n  Ǎ: 'A',\n  ǎ: 'a',\n  Ǐ: 'I',\n  ǐ: 'i',\n  Ǒ: 'O',\n  ǒ: 'o',\n  Ǔ: 'U',\n  ǔ: 'u',\n  Ǖ: 'U',\n  ǖ: 'u',\n  Ǘ: 'U',\n  ǘ: 'u',\n  Ǚ: 'U',\n  ǚ: 'u',\n  Ǜ: 'U',\n  ǜ: 'u',\n  Ứ: 'U',\n  ứ: 'u',\n  Ṹ: 'U',\n  ṹ: 'u',\n  Ǻ: 'A',\n  ǻ: 'a',\n  Ǽ: 'AE',\n  ǽ: 'ae',\n  Ǿ: 'O',\n  ǿ: 'o',\n  Þ: 'TH',\n  þ: 'th',\n  Ṕ: 'P',\n  ṕ: 'p',\n  Ṥ: 'S',\n  ṥ: 's',\n  X́: 'X',\n  x́: 'x',\n  Ѓ: 'Г',\n  ѓ: 'г',\n  Ќ: 'К',\n  ќ: 'к',\n  A̋: 'A',\n  a̋: 'a',\n  E̋: 'E',\n  e̋: 'e',\n  I̋: 'I',\n  i̋: 'i',\n  Ǹ: 'N',\n  ǹ: 'n',\n  Ồ: 'O',\n  ồ: 'o',\n  Ṑ: 'O',\n  ṑ: 'o',\n  Ừ: 'U',\n  ừ: 'u',\n  Ẁ: 'W',\n  ẁ: 'w',\n  Ỳ: 'Y',\n  ỳ: 'y',\n  Ȁ: 'A',\n  ȁ: 'a',\n  Ȅ: 'E',\n  ȅ: 'e',\n  Ȉ: 'I',\n  ȉ: 'i',\n  Ȍ: 'O',\n  ȍ: 'o',\n  Ȑ: 'R',\n  ȑ: 'r',\n  Ȕ: 'U',\n  ȕ: 'u',\n  B̌: 'B',\n  b̌: 'b',\n  Č̣: 'C',\n  č̣: 'c',\n  Ê̌: 'E',\n  ê̌: 'e',\n  F̌: 'F',\n  f̌: 'f',\n  Ǧ: 'G',\n  ǧ: 'g',\n  Ȟ: 'H',\n  ȟ: 'h',\n  J̌: 'J',\n  ǰ: 'j',\n  Ǩ: 'K',\n  ǩ: 'k',\n  M̌: 'M',\n  m̌: 'm',\n  P̌: 'P',\n  p̌: 'p',\n  Q̌: 'Q',\n  q̌: 'q',\n  Ř̩: 'R',\n  ř̩: 'r',\n  Ṧ: 'S',\n  ṧ: 's',\n  V̌: 'V',\n  v̌: 'v',\n  W̌: 'W',\n  w̌: 'w',\n  X̌: 'X',\n  x̌: 'x',\n  Y̌: 'Y',\n  y̌: 'y',\n  A̧: 'A',\n  a̧: 'a',\n  B̧: 'B',\n  b̧: 'b',\n  Ḑ: 'D',\n  ḑ: 'd',\n  Ȩ: 'E',\n  ȩ: 'e',\n  Ɛ̧: 'E',\n  ɛ̧: 'e',\n  Ḩ: 'H',\n  ḩ: 'h',\n  I̧: 'I',\n  i̧: 'i',\n  Ɨ̧: 'I',\n  ɨ̧: 'i',\n  M̧: 'M',\n  m̧: 'm',\n  O̧: 'O',\n  o̧: 'o',\n  Q̧: 'Q',\n  q̧: 'q',\n  U̧: 'U',\n  u̧: 'u',\n  X̧: 'X',\n  x̧: 'x',\n  Z̧: 'Z',\n  z̧: 'z'\n};\nconst chars = Object.keys(characterMap).join('|');\nconst allAccents = new RegExp(chars, 'g');\nfunction removeAccents(str) {\n  return str.replace(allAccents, match => {\n    return characterMap[match];\n  });\n}\n\n/**\n * @name match-sorter\n * @license MIT license.\n * @copyright (c) 2099 Kent C. Dodds\n * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n */\n\nconst rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, accessorIndex: Number, accessorThreshold: Number}} - the highest ranking\n */\nfunction rankItem(item, value, options) {\n  var _options$threshold;\n  options = options || {};\n  options.threshold = (_options$threshold = options.threshold) != null ? _options$threshold : rankings.MATCHES;\n  if (!options.accessors) {\n    // if keys is not specified, then we assume the item given is ready to be matched\n    const rank = getMatchRanking(item, value, options);\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedValue: item,\n      rank,\n      accessorIndex: -1,\n      accessorThreshold: options.threshold,\n      passed: rank >= options.threshold\n    };\n  }\n  const valuesToRank = getAllValuesToRank(item, options.accessors);\n  const rankingInfo = {\n    rankedValue: item,\n    rank: rankings.NO_MATCH,\n    accessorIndex: -1,\n    accessorThreshold: options.threshold,\n    passed: false\n  };\n  for (let i = 0; i < valuesToRank.length; i++) {\n    const rankValue = valuesToRank[i];\n    let newRank = getMatchRanking(rankValue.itemValue, value, options);\n    const {\n      minRanking,\n      maxRanking,\n      threshold = options.threshold\n    } = rankValue.attributes;\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n    newRank = Math.min(newRank, maxRanking);\n    if (newRank >= threshold && newRank > rankingInfo.rank) {\n      rankingInfo.rank = newRank;\n      rankingInfo.passed = true;\n      rankingInfo.accessorIndex = i;\n      rankingInfo.accessorThreshold = threshold;\n      rankingInfo.rankedValue = rankValue.itemValue;\n    }\n  }\n  return rankingInfo;\n}\n\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\nfunction getMatchRanking(testString, stringToRank, options) {\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options);\n\n  // too long\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  }\n\n  // case sensitive equals\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  }\n\n  // Lower casing before further comparison\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase();\n\n  // case insensitive equals\n  if (testString === stringToRank) {\n    return rankings.EQUAL;\n  }\n\n  // starts with\n  if (testString.startsWith(stringToRank)) {\n    return rankings.STARTS_WITH;\n  }\n\n  // word starts with\n  if (testString.includes(` ${stringToRank}`)) {\n    return rankings.WORD_STARTS_WITH;\n  }\n\n  // contains\n  if (testString.includes(stringToRank)) {\n    return rankings.CONTAINS;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  }\n\n  // acronym\n  if (getAcronym(testString).includes(stringToRank)) {\n    return rankings.ACRONYM;\n  }\n\n  // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n  return getClosenessRanking(testString, stringToRank);\n}\n\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\nfunction getAcronym(string) {\n  let acronym = '';\n  const wordsInString = string.split(' ');\n  wordsInString.forEach(wordInString => {\n    const splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(splitByHyphenWord => {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\nfunction getClosenessRanking(testString, stringToRank) {\n  let matchingInOrderCharCount = 0;\n  let charNumber = 0;\n  function findMatchingCharacter(matchChar, string, index) {\n    for (let j = index, J = string.length; j < J; j++) {\n      const stringChar = string[j];\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n    return -1;\n  }\n  function getRanking(spread) {\n    const spreadPercentage = 1 / spread;\n    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;\n    return ranking;\n  }\n  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n  charNumber = firstIndex;\n  for (let i = 1, I = stringToRank.length; i < I; i++) {\n    const matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    const found = charNumber > -1;\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n  const spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n\n/**\n * Sorts items that have a rank, index, and accessorIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\nfunction compareItems(a, b) {\n  return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1;\n}\n\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\nfunction prepareValueForComparison(value, _ref) {\n  let {\n    keepDiacritics\n  } = _ref;\n  // value might not actually be a string at this point (we don't get to choose)\n  // so part of preparing the value for comparison is ensure that it is a string\n  value = `${value}`; // toString\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n  return value;\n}\n\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\nfunction getItemValues(item, accessor) {\n  let accessorFn = accessor;\n  if (typeof accessor === 'object') {\n    accessorFn = accessor.accessor;\n  }\n  const value = accessorFn(item);\n\n  // because `value` can also be undefined\n  if (value == null) {\n    return [];\n  }\n  if (Array.isArray(value)) {\n    return value;\n  }\n  return [String(value)];\n}\n\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */\nfunction getAllValuesToRank(item, accessors) {\n  const allValues = [];\n  for (let j = 0, J = accessors.length; j < J; j++) {\n    const accessor = accessors[j];\n    const attributes = getAccessorAttributes(accessor);\n    const itemValues = getItemValues(item, accessor);\n    for (let i = 0, I = itemValues.length; i < I; i++) {\n      allValues.push({\n        itemValue: itemValues[i],\n        attributes\n      });\n    }\n  }\n  return allValues;\n}\nconst defaultKeyAttributes = {\n  maxRanking: Infinity,\n  minRanking: -Infinity\n};\n/**\n * Gets all the attributes for the given accessor\n * @param accessor - the accessor from which the attributes will be retrieved\n * @return object containing the accessor's attributes\n */\nfunction getAccessorAttributes(accessor) {\n  if (typeof accessor === 'function') {\n    return defaultKeyAttributes;\n  }\n  return {\n    ...defaultKeyAttributes,\n    ...accessor\n  };\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL21hdGNoLXNvcnRlci11dGlscy9idWlsZC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsaUVBQWlFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxXQUFXO0FBQzlCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsYUFBYSxNQUFNLEdBQUc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0QztBQUM1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZXh5LW11aS1uZXh0anMtYWRtaW4tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL21hdGNoLXNvcnRlci11dGlscy9idWlsZC9saWIvaW5kZXgubWpzPzcwMzUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gICAqIG1hdGNoLXNvcnRlci11dGlsc1xuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIFRhblN0YWNrXG4gICAqXG4gICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gICAqXG4gICAqIEBsaWNlbnNlIE1JVFxuICAgKi9cbmNvbnN0IGNoYXJhY3Rlck1hcCA9IHtcbiAgw4A6ICdBJyxcbiAgw4E6ICdBJyxcbiAgw4I6ICdBJyxcbiAgw4M6ICdBJyxcbiAgw4Q6ICdBJyxcbiAgw4U6ICdBJyxcbiAg4bqkOiAnQScsXG4gIOG6rjogJ0EnLFxuICDhurI6ICdBJyxcbiAg4bq0OiAnQScsXG4gIOG6tjogJ0EnLFxuICDDhjogJ0FFJyxcbiAg4bqmOiAnQScsXG4gIOG6sDogJ0EnLFxuICDIgjogJ0EnLFxuICDDhzogJ0MnLFxuICDhuIg6ICdDJyxcbiAgw4g6ICdFJyxcbiAgw4k6ICdFJyxcbiAgw4o6ICdFJyxcbiAgw4s6ICdFJyxcbiAg4bq+OiAnRScsXG4gIOG4ljogJ0UnLFxuICDhu4A6ICdFJyxcbiAg4biUOiAnRScsXG4gIOG4nDogJ0UnLFxuICDIhjogJ0UnLFxuICDDjDogJ0knLFxuICDDjTogJ0knLFxuICDDjjogJ0knLFxuICDDjzogJ0knLFxuICDhuK46ICdJJyxcbiAgyIo6ICdJJyxcbiAgw5A6ICdEJyxcbiAgw5E6ICdOJyxcbiAgw5I6ICdPJyxcbiAgw5M6ICdPJyxcbiAgw5Q6ICdPJyxcbiAgw5U6ICdPJyxcbiAgw5Y6ICdPJyxcbiAgw5g6ICdPJyxcbiAg4buQOiAnTycsXG4gIOG5jDogJ08nLFxuICDhuZI6ICdPJyxcbiAgyI46ICdPJyxcbiAgw5k6ICdVJyxcbiAgw5o6ICdVJyxcbiAgw5s6ICdVJyxcbiAgw5w6ICdVJyxcbiAgw506ICdZJyxcbiAgw6A6ICdhJyxcbiAgw6E6ICdhJyxcbiAgw6I6ICdhJyxcbiAgw6M6ICdhJyxcbiAgw6Q6ICdhJyxcbiAgw6U6ICdhJyxcbiAg4bqlOiAnYScsXG4gIOG6rzogJ2EnLFxuICDhurM6ICdhJyxcbiAg4bq1OiAnYScsXG4gIOG6tzogJ2EnLFxuICDDpjogJ2FlJyxcbiAg4bqnOiAnYScsXG4gIOG6sTogJ2EnLFxuICDIgzogJ2EnLFxuICDDpzogJ2MnLFxuICDhuIk6ICdjJyxcbiAgw6g6ICdlJyxcbiAgw6k6ICdlJyxcbiAgw6o6ICdlJyxcbiAgw6s6ICdlJyxcbiAg4bq/OiAnZScsXG4gIOG4lzogJ2UnLFxuICDhu4E6ICdlJyxcbiAg4biVOiAnZScsXG4gIOG4nTogJ2UnLFxuICDIhzogJ2UnLFxuICDDrDogJ2knLFxuICDDrTogJ2knLFxuICDDrjogJ2knLFxuICDDrzogJ2knLFxuICDhuK86ICdpJyxcbiAgyIs6ICdpJyxcbiAgw7A6ICdkJyxcbiAgw7E6ICduJyxcbiAgw7I6ICdvJyxcbiAgw7M6ICdvJyxcbiAgw7Q6ICdvJyxcbiAgw7U6ICdvJyxcbiAgw7Y6ICdvJyxcbiAgw7g6ICdvJyxcbiAg4buROiAnbycsXG4gIOG5jTogJ28nLFxuICDhuZM6ICdvJyxcbiAgyI86ICdvJyxcbiAgw7k6ICd1JyxcbiAgw7o6ICd1JyxcbiAgw7s6ICd1JyxcbiAgw7w6ICd1JyxcbiAgw706ICd5JyxcbiAgw786ICd5JyxcbiAgxIA6ICdBJyxcbiAgxIE6ICdhJyxcbiAgxII6ICdBJyxcbiAgxIM6ICdhJyxcbiAgxIQ6ICdBJyxcbiAgxIU6ICdhJyxcbiAgxIY6ICdDJyxcbiAgxIc6ICdjJyxcbiAgxIg6ICdDJyxcbiAgxIk6ICdjJyxcbiAgxIo6ICdDJyxcbiAgxIs6ICdjJyxcbiAgxIw6ICdDJyxcbiAgxI06ICdjJyxcbiAgQ8yGOiAnQycsXG4gIGPMhjogJ2MnLFxuICDEjjogJ0QnLFxuICDEjzogJ2QnLFxuICDEkDogJ0QnLFxuICDEkTogJ2QnLFxuICDEkjogJ0UnLFxuICDEkzogJ2UnLFxuICDElDogJ0UnLFxuICDElTogJ2UnLFxuICDEljogJ0UnLFxuICDElzogJ2UnLFxuICDEmDogJ0UnLFxuICDEmTogJ2UnLFxuICDEmjogJ0UnLFxuICDEmzogJ2UnLFxuICDEnDogJ0cnLFxuICDHtDogJ0cnLFxuICDEnTogJ2cnLFxuICDHtTogJ2cnLFxuICDEnjogJ0cnLFxuICDEnzogJ2cnLFxuICDEoDogJ0cnLFxuICDEoTogJ2cnLFxuICDEojogJ0cnLFxuICDEozogJ2cnLFxuICDEpDogJ0gnLFxuICDEpTogJ2gnLFxuICDEpjogJ0gnLFxuICDEpzogJ2gnLFxuICDhuKo6ICdIJyxcbiAg4birOiAnaCcsXG4gIMSoOiAnSScsXG4gIMSpOiAnaScsXG4gIMSqOiAnSScsXG4gIMSrOiAnaScsXG4gIMSsOiAnSScsXG4gIMStOiAnaScsXG4gIMSuOiAnSScsXG4gIMSvOiAnaScsXG4gIMSwOiAnSScsXG4gIMSxOiAnaScsXG4gIMSyOiAnSUonLFxuICDEszogJ2lqJyxcbiAgxLQ6ICdKJyxcbiAgxLU6ICdqJyxcbiAgxLY6ICdLJyxcbiAgxLc6ICdrJyxcbiAg4biwOiAnSycsXG4gIOG4sTogJ2snLFxuICBLzIY6ICdLJyxcbiAga8yGOiAnaycsXG4gIMS5OiAnTCcsXG4gIMS6OiAnbCcsXG4gIMS7OiAnTCcsXG4gIMS8OiAnbCcsXG4gIMS9OiAnTCcsXG4gIMS+OiAnbCcsXG4gIMS/OiAnTCcsXG4gIMWAOiAnbCcsXG4gIMWBOiAnbCcsXG4gIMWCOiAnbCcsXG4gIOG4vjogJ00nLFxuICDhuL86ICdtJyxcbiAgTcyGOiAnTScsXG4gIG3MhjogJ20nLFxuICDFgzogJ04nLFxuICDFhDogJ24nLFxuICDFhTogJ04nLFxuICDFhjogJ24nLFxuICDFhzogJ04nLFxuICDFiDogJ24nLFxuICDFiTogJ24nLFxuICBOzIY6ICdOJyxcbiAgbsyGOiAnbicsXG4gIMWMOiAnTycsXG4gIMWNOiAnbycsXG4gIMWOOiAnTycsXG4gIMWPOiAnbycsXG4gIMWQOiAnTycsXG4gIMWROiAnbycsXG4gIMWSOiAnT0UnLFxuICDFkzogJ29lJyxcbiAgUMyGOiAnUCcsXG4gIHDMhjogJ3AnLFxuICDFlDogJ1InLFxuICDFlTogJ3InLFxuICDFljogJ1InLFxuICDFlzogJ3InLFxuICDFmDogJ1InLFxuICDFmTogJ3InLFxuICBSzIY6ICdSJyxcbiAgcsyGOiAncicsXG4gIMiSOiAnUicsXG4gIMiTOiAncicsXG4gIMWaOiAnUycsXG4gIMWbOiAncycsXG4gIMWcOiAnUycsXG4gIMWdOiAncycsXG4gIMWeOiAnUycsXG4gIMiYOiAnUycsXG4gIMiZOiAncycsXG4gIMWfOiAncycsXG4gIMWgOiAnUycsXG4gIMWhOiAncycsXG4gIMWiOiAnVCcsXG4gIMWjOiAndCcsXG4gIMibOiAndCcsXG4gIMiaOiAnVCcsXG4gIMWkOiAnVCcsXG4gIMWlOiAndCcsXG4gIMWmOiAnVCcsXG4gIMWnOiAndCcsXG4gIFTMhjogJ1QnLFxuICB0zIY6ICd0JyxcbiAgxag6ICdVJyxcbiAgxak6ICd1JyxcbiAgxao6ICdVJyxcbiAgxas6ICd1JyxcbiAgxaw6ICdVJyxcbiAgxa06ICd1JyxcbiAgxa46ICdVJyxcbiAgxa86ICd1JyxcbiAgxbA6ICdVJyxcbiAgxbE6ICd1JyxcbiAgxbI6ICdVJyxcbiAgxbM6ICd1JyxcbiAgyJY6ICdVJyxcbiAgyJc6ICd1JyxcbiAgVsyGOiAnVicsXG4gIHbMhjogJ3YnLFxuICDFtDogJ1cnLFxuICDFtTogJ3cnLFxuICDhuoI6ICdXJyxcbiAg4bqDOiAndycsXG4gIFjMhjogJ1gnLFxuICB4zIY6ICd4JyxcbiAgxbY6ICdZJyxcbiAgxbc6ICd5JyxcbiAgxbg6ICdZJyxcbiAgWcyGOiAnWScsXG4gIHnMhjogJ3knLFxuICDFuTogJ1onLFxuICDFujogJ3onLFxuICDFuzogJ1onLFxuICDFvDogJ3onLFxuICDFvTogJ1onLFxuICDFvjogJ3onLFxuICDFvzogJ3MnLFxuICDGkjogJ2YnLFxuICDGoDogJ08nLFxuICDGoTogJ28nLFxuICDGrzogJ1UnLFxuICDGsDogJ3UnLFxuICDHjTogJ0EnLFxuICDHjjogJ2EnLFxuICDHjzogJ0knLFxuICDHkDogJ2knLFxuICDHkTogJ08nLFxuICDHkjogJ28nLFxuICDHkzogJ1UnLFxuICDHlDogJ3UnLFxuICDHlTogJ1UnLFxuICDHljogJ3UnLFxuICDHlzogJ1UnLFxuICDHmDogJ3UnLFxuICDHmTogJ1UnLFxuICDHmjogJ3UnLFxuICDHmzogJ1UnLFxuICDHnDogJ3UnLFxuICDhu6g6ICdVJyxcbiAg4bupOiAndScsXG4gIOG5uDogJ1UnLFxuICDhubk6ICd1JyxcbiAgx7o6ICdBJyxcbiAgx7s6ICdhJyxcbiAgx7w6ICdBRScsXG4gIMe9OiAnYWUnLFxuICDHvjogJ08nLFxuICDHvzogJ28nLFxuICDDnjogJ1RIJyxcbiAgw746ICd0aCcsXG4gIOG5lDogJ1AnLFxuICDhuZU6ICdwJyxcbiAg4bmkOiAnUycsXG4gIOG5pTogJ3MnLFxuICBYzIE6ICdYJyxcbiAgeMyBOiAneCcsXG4gINCDOiAn0JMnLFxuICDRkzogJ9CzJyxcbiAg0Iw6ICfQmicsXG4gINGcOiAn0LonLFxuICBBzIs6ICdBJyxcbiAgYcyLOiAnYScsXG4gIEXMizogJ0UnLFxuICBlzIs6ICdlJyxcbiAgScyLOiAnSScsXG4gIGnMizogJ2knLFxuICDHuDogJ04nLFxuICDHuTogJ24nLFxuICDhu5I6ICdPJyxcbiAg4buTOiAnbycsXG4gIOG5kDogJ08nLFxuICDhuZE6ICdvJyxcbiAg4buqOiAnVScsXG4gIOG7qzogJ3UnLFxuICDhuoA6ICdXJyxcbiAg4bqBOiAndycsXG4gIOG7sjogJ1knLFxuICDhu7M6ICd5JyxcbiAgyIA6ICdBJyxcbiAgyIE6ICdhJyxcbiAgyIQ6ICdFJyxcbiAgyIU6ICdlJyxcbiAgyIg6ICdJJyxcbiAgyIk6ICdpJyxcbiAgyIw6ICdPJyxcbiAgyI06ICdvJyxcbiAgyJA6ICdSJyxcbiAgyJE6ICdyJyxcbiAgyJQ6ICdVJyxcbiAgyJU6ICd1JyxcbiAgQsyMOiAnQicsXG4gIGLMjDogJ2InLFxuICDEjMyjOiAnQycsXG4gIMSNzKM6ICdjJyxcbiAgw4rMjDogJ0UnLFxuICDDqsyMOiAnZScsXG4gIEbMjDogJ0YnLFxuICBmzIw6ICdmJyxcbiAgx6Y6ICdHJyxcbiAgx6c6ICdnJyxcbiAgyJ46ICdIJyxcbiAgyJ86ICdoJyxcbiAgSsyMOiAnSicsXG4gIMewOiAnaicsXG4gIMeoOiAnSycsXG4gIMepOiAnaycsXG4gIE3MjDogJ00nLFxuICBtzIw6ICdtJyxcbiAgUMyMOiAnUCcsXG4gIHDMjDogJ3AnLFxuICBRzIw6ICdRJyxcbiAgccyMOiAncScsXG4gIMWYzKk6ICdSJyxcbiAgxZnMqTogJ3InLFxuICDhuaY6ICdTJyxcbiAg4bmnOiAncycsXG4gIFbMjDogJ1YnLFxuICB2zIw6ICd2JyxcbiAgV8yMOiAnVycsXG4gIHfMjDogJ3cnLFxuICBYzIw6ICdYJyxcbiAgeMyMOiAneCcsXG4gIFnMjDogJ1knLFxuICB5zIw6ICd5JyxcbiAgQcynOiAnQScsXG4gIGHMpzogJ2EnLFxuICBCzKc6ICdCJyxcbiAgYsynOiAnYicsXG4gIOG4kDogJ0QnLFxuICDhuJE6ICdkJyxcbiAgyKg6ICdFJyxcbiAgyKk6ICdlJyxcbiAgxpDMpzogJ0UnLFxuICDJm8ynOiAnZScsXG4gIOG4qDogJ0gnLFxuICDhuKk6ICdoJyxcbiAgScynOiAnSScsXG4gIGnMpzogJ2knLFxuICDGl8ynOiAnSScsXG4gIMmozKc6ICdpJyxcbiAgTcynOiAnTScsXG4gIG3MpzogJ20nLFxuICBPzKc6ICdPJyxcbiAgb8ynOiAnbycsXG4gIFHMpzogJ1EnLFxuICBxzKc6ICdxJyxcbiAgVcynOiAnVScsXG4gIHXMpzogJ3UnLFxuICBYzKc6ICdYJyxcbiAgeMynOiAneCcsXG4gIFrMpzogJ1onLFxuICB6zKc6ICd6J1xufTtcbmNvbnN0IGNoYXJzID0gT2JqZWN0LmtleXMoY2hhcmFjdGVyTWFwKS5qb2luKCd8Jyk7XG5jb25zdCBhbGxBY2NlbnRzID0gbmV3IFJlZ0V4cChjaGFycywgJ2cnKTtcbmZ1bmN0aW9uIHJlbW92ZUFjY2VudHMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShhbGxBY2NlbnRzLCBtYXRjaCA9PiB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlck1hcFttYXRjaF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEBuYW1lIG1hdGNoLXNvcnRlclxuICogQGxpY2Vuc2UgTUlUIGxpY2Vuc2UuXG4gKiBAY29weXJpZ2h0IChjKSAyMDk5IEtlbnQgQy4gRG9kZHNcbiAqIEBhdXRob3IgS2VudCBDLiBEb2RkcyA8bWVAa2VudGNkb2Rkcy5jb20+IChodHRwczovL2tlbnRjZG9kZHMuY29tKVxuICovXG5cbmNvbnN0IHJhbmtpbmdzID0ge1xuICBDQVNFX1NFTlNJVElWRV9FUVVBTDogNyxcbiAgRVFVQUw6IDYsXG4gIFNUQVJUU19XSVRIOiA1LFxuICBXT1JEX1NUQVJUU19XSVRIOiA0LFxuICBDT05UQUlOUzogMyxcbiAgQUNST05ZTTogMixcbiAgTUFUQ0hFUzogMSxcbiAgTk9fTUFUQ0g6IDBcbn07XG4vKipcbiAqIEdldHMgdGhlIGhpZ2hlc3QgcmFua2luZyBmb3IgdmFsdWUgZm9yIHRoZSBnaXZlbiBpdGVtIGJhc2VkIG9uIGl0cyB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBrZXlzXG4gKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgaXRlbSB0byByYW5rXG4gKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gdGhlIGtleXMgdG8gZ2V0IHZhbHVlcyBmcm9tIHRoZSBpdGVtIGZvciB0aGUgcmFua2luZ1xuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHJhbmsgYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRvIGNvbnRyb2wgdGhlIHJhbmtpbmdcbiAqIEByZXR1cm4ge3tyYW5rOiBOdW1iZXIsIGFjY2Vzc29ySW5kZXg6IE51bWJlciwgYWNjZXNzb3JUaHJlc2hvbGQ6IE51bWJlcn19IC0gdGhlIGhpZ2hlc3QgcmFua2luZ1xuICovXG5mdW5jdGlvbiByYW5rSXRlbShpdGVtLCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkdGhyZXNob2xkO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy50aHJlc2hvbGQgPSAoX29wdGlvbnMkdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQpICE9IG51bGwgPyBfb3B0aW9ucyR0aHJlc2hvbGQgOiByYW5raW5ncy5NQVRDSEVTO1xuICBpZiAoIW9wdGlvbnMuYWNjZXNzb3JzKSB7XG4gICAgLy8gaWYga2V5cyBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIHdlIGFzc3VtZSB0aGUgaXRlbSBnaXZlbiBpcyByZWFkeSB0byBiZSBtYXRjaGVkXG4gICAgY29uc3QgcmFuayA9IGdldE1hdGNoUmFua2luZyhpdGVtLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGVuZHMgdXAgYmVpbmcgZHVwbGljYXRlIG9mICdpdGVtJyBpbiBtYXRjaGVzIGJ1dCBjb25zaXN0ZW50XG4gICAgICByYW5rZWRWYWx1ZTogaXRlbSxcbiAgICAgIHJhbmssXG4gICAgICBhY2Nlc3NvckluZGV4OiAtMSxcbiAgICAgIGFjY2Vzc29yVGhyZXNob2xkOiBvcHRpb25zLnRocmVzaG9sZCxcbiAgICAgIHBhc3NlZDogcmFuayA+PSBvcHRpb25zLnRocmVzaG9sZFxuICAgIH07XG4gIH1cbiAgY29uc3QgdmFsdWVzVG9SYW5rID0gZ2V0QWxsVmFsdWVzVG9SYW5rKGl0ZW0sIG9wdGlvbnMuYWNjZXNzb3JzKTtcbiAgY29uc3QgcmFua2luZ0luZm8gPSB7XG4gICAgcmFua2VkVmFsdWU6IGl0ZW0sXG4gICAgcmFuazogcmFua2luZ3MuTk9fTUFUQ0gsXG4gICAgYWNjZXNzb3JJbmRleDogLTEsXG4gICAgYWNjZXNzb3JUaHJlc2hvbGQ6IG9wdGlvbnMudGhyZXNob2xkLFxuICAgIHBhc3NlZDogZmFsc2VcbiAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXNUb1JhbmsubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByYW5rVmFsdWUgPSB2YWx1ZXNUb1JhbmtbaV07XG4gICAgbGV0IG5ld1JhbmsgPSBnZXRNYXRjaFJhbmtpbmcocmFua1ZhbHVlLml0ZW1WYWx1ZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1pblJhbmtpbmcsXG4gICAgICBtYXhSYW5raW5nLFxuICAgICAgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGRcbiAgICB9ID0gcmFua1ZhbHVlLmF0dHJpYnV0ZXM7XG4gICAgaWYgKG5ld1JhbmsgPCBtaW5SYW5raW5nICYmIG5ld1JhbmsgPj0gcmFua2luZ3MuTUFUQ0hFUykge1xuICAgICAgbmV3UmFuayA9IG1pblJhbmtpbmc7XG4gICAgfSBlbHNlIGlmIChuZXdSYW5rID4gbWF4UmFua2luZykge1xuICAgICAgbmV3UmFuayA9IG1heFJhbmtpbmc7XG4gICAgfVxuICAgIG5ld1JhbmsgPSBNYXRoLm1pbihuZXdSYW5rLCBtYXhSYW5raW5nKTtcbiAgICBpZiAobmV3UmFuayA+PSB0aHJlc2hvbGQgJiYgbmV3UmFuayA+IHJhbmtpbmdJbmZvLnJhbmspIHtcbiAgICAgIHJhbmtpbmdJbmZvLnJhbmsgPSBuZXdSYW5rO1xuICAgICAgcmFua2luZ0luZm8ucGFzc2VkID0gdHJ1ZTtcbiAgICAgIHJhbmtpbmdJbmZvLmFjY2Vzc29ySW5kZXggPSBpO1xuICAgICAgcmFua2luZ0luZm8uYWNjZXNzb3JUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgICByYW5raW5nSW5mby5yYW5rZWRWYWx1ZSA9IHJhbmtWYWx1ZS5pdGVtVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByYW5raW5nSW5mbztcbn1cblxuLyoqXG4gKiBHaXZlcyBhIHJhbmtpbmdzIHNjb3JlIGJhc2VkIG9uIGhvdyB3ZWxsIHRoZSB0d28gc3RyaW5ncyBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXN0U3RyaW5nIC0gdGhlIHN0cmluZyB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdUb1JhbmsgLSB0aGUgc3RyaW5nIHRvIHJhbmtcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIG1hdGNoIChsaWtlIGtlZXBEaWFjcml0aWNzIGZvciBjb21wYXJpc29uKVxuICogQHJldHVybnMge051bWJlcn0gdGhlIHJhbmtpbmcgZm9yIGhvdyB3ZWxsIHN0cmluZ1RvUmFuayBtYXRjaGVzIHRlc3RTdHJpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hSYW5raW5nKHRlc3RTdHJpbmcsIHN0cmluZ1RvUmFuaywgb3B0aW9ucykge1xuICB0ZXN0U3RyaW5nID0gcHJlcGFyZVZhbHVlRm9yQ29tcGFyaXNvbih0ZXN0U3RyaW5nLCBvcHRpb25zKTtcbiAgc3RyaW5nVG9SYW5rID0gcHJlcGFyZVZhbHVlRm9yQ29tcGFyaXNvbihzdHJpbmdUb1JhbmssIG9wdGlvbnMpO1xuXG4gIC8vIHRvbyBsb25nXG4gIGlmIChzdHJpbmdUb1JhbmsubGVuZ3RoID4gdGVzdFN0cmluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmFua2luZ3MuTk9fTUFUQ0g7XG4gIH1cblxuICAvLyBjYXNlIHNlbnNpdGl2ZSBlcXVhbHNcbiAgaWYgKHRlc3RTdHJpbmcgPT09IHN0cmluZ1RvUmFuaykge1xuICAgIHJldHVybiByYW5raW5ncy5DQVNFX1NFTlNJVElWRV9FUVVBTDtcbiAgfVxuXG4gIC8vIExvd2VyIGNhc2luZyBiZWZvcmUgZnVydGhlciBjb21wYXJpc29uXG4gIHRlc3RTdHJpbmcgPSB0ZXN0U3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gIHN0cmluZ1RvUmFuayA9IHN0cmluZ1RvUmFuay50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIGNhc2UgaW5zZW5zaXRpdmUgZXF1YWxzXG4gIGlmICh0ZXN0U3RyaW5nID09PSBzdHJpbmdUb1JhbmspIHtcbiAgICByZXR1cm4gcmFua2luZ3MuRVFVQUw7XG4gIH1cblxuICAvLyBzdGFydHMgd2l0aFxuICBpZiAodGVzdFN0cmluZy5zdGFydHNXaXRoKHN0cmluZ1RvUmFuaykpIHtcbiAgICByZXR1cm4gcmFua2luZ3MuU1RBUlRTX1dJVEg7XG4gIH1cblxuICAvLyB3b3JkIHN0YXJ0cyB3aXRoXG4gIGlmICh0ZXN0U3RyaW5nLmluY2x1ZGVzKGAgJHtzdHJpbmdUb1Jhbmt9YCkpIHtcbiAgICByZXR1cm4gcmFua2luZ3MuV09SRF9TVEFSVFNfV0lUSDtcbiAgfVxuXG4gIC8vIGNvbnRhaW5zXG4gIGlmICh0ZXN0U3RyaW5nLmluY2x1ZGVzKHN0cmluZ1RvUmFuaykpIHtcbiAgICByZXR1cm4gcmFua2luZ3MuQ09OVEFJTlM7XG4gIH0gZWxzZSBpZiAoc3RyaW5nVG9SYW5rLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIElmIHRoZSBvbmx5IGNoYXJhY3RlciBpbiB0aGUgZ2l2ZW4gc3RyaW5nVG9SYW5rXG4gICAgLy8gICBpc24ndCBldmVuIGNvbnRhaW5lZCBpbiB0aGUgdGVzdFN0cmluZywgdGhlblxuICAgIC8vICAgaXQncyBkZWZpbml0ZWx5IG5vdCBhIG1hdGNoLlxuICAgIHJldHVybiByYW5raW5ncy5OT19NQVRDSDtcbiAgfVxuXG4gIC8vIGFjcm9ueW1cbiAgaWYgKGdldEFjcm9ueW0odGVzdFN0cmluZykuaW5jbHVkZXMoc3RyaW5nVG9SYW5rKSkge1xuICAgIHJldHVybiByYW5raW5ncy5BQ1JPTllNO1xuICB9XG5cbiAgLy8gd2lsbCByZXR1cm4gYSBudW1iZXIgYmV0d2VlbiByYW5raW5ncy5NQVRDSEVTIGFuZFxuICAvLyByYW5raW5ncy5NQVRDSEVTICsgMSBkZXBlbmRpbmcgIG9uIGhvdyBjbG9zZSBvZiBhIG1hdGNoIGl0IGlzLlxuICByZXR1cm4gZ2V0Q2xvc2VuZXNzUmFua2luZyh0ZXN0U3RyaW5nLCBzdHJpbmdUb1JhbmspO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhY3JvbnltIGZvciBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIHRoZSBzdHJpbmcgZm9yIHdoaWNoIHRvIHByb2R1Y2UgdGhlIGFjcm9ueW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBhY3JvbnltXG4gKi9cbmZ1bmN0aW9uIGdldEFjcm9ueW0oc3RyaW5nKSB7XG4gIGxldCBhY3JvbnltID0gJyc7XG4gIGNvbnN0IHdvcmRzSW5TdHJpbmcgPSBzdHJpbmcuc3BsaXQoJyAnKTtcbiAgd29yZHNJblN0cmluZy5mb3JFYWNoKHdvcmRJblN0cmluZyA9PiB7XG4gICAgY29uc3Qgc3BsaXRCeUh5cGhlbldvcmRzID0gd29yZEluU3RyaW5nLnNwbGl0KCctJyk7XG4gICAgc3BsaXRCeUh5cGhlbldvcmRzLmZvckVhY2goc3BsaXRCeUh5cGhlbldvcmQgPT4ge1xuICAgICAgYWNyb255bSArPSBzcGxpdEJ5SHlwaGVuV29yZC5zdWJzdHIoMCwgMSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gYWNyb255bTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2NvcmUgYmFzZWQgb24gaG93IHNwcmVhZCBhcGFydCB0aGVcbiAqIGNoYXJhY3RlcnMgZnJvbSB0aGUgc3RyaW5nVG9SYW5rIGFyZSB3aXRoaW4gdGhlIHRlc3RTdHJpbmcuXG4gKiBBIG51bWJlciBjbG9zZSB0byByYW5raW5ncy5NQVRDSEVTIHJlcHJlc2VudHMgYSBsb29zZSBtYXRjaC4gQSBudW1iZXIgY2xvc2VcbiAqIHRvIHJhbmtpbmdzLk1BVENIRVMgKyAxIHJlcHJlc2VudHMgYSB0aWdodGVyIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd9IHRlc3RTdHJpbmcgLSB0aGUgc3RyaW5nIHRvIHRlc3QgYWdhaW5zdFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1RvUmFuayAtIHRoZSBzdHJpbmcgdG8gcmFua1xuICogQHJldHVybnMge051bWJlcn0gdGhlIG51bWJlciBiZXR3ZWVuIHJhbmtpbmdzLk1BVENIRVMgYW5kXG4gKiByYW5raW5ncy5NQVRDSEVTICsgMSBmb3IgaG93IHdlbGwgc3RyaW5nVG9SYW5rIG1hdGNoZXMgdGVzdFN0cmluZ1xuICovXG5mdW5jdGlvbiBnZXRDbG9zZW5lc3NSYW5raW5nKHRlc3RTdHJpbmcsIHN0cmluZ1RvUmFuaykge1xuICBsZXQgbWF0Y2hpbmdJbk9yZGVyQ2hhckNvdW50ID0gMDtcbiAgbGV0IGNoYXJOdW1iZXIgPSAwO1xuICBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdDaGFyYWN0ZXIobWF0Y2hDaGFyLCBzdHJpbmcsIGluZGV4KSB7XG4gICAgZm9yIChsZXQgaiA9IGluZGV4LCBKID0gc3RyaW5nLmxlbmd0aDsgaiA8IEo7IGorKykge1xuICAgICAgY29uc3Qgc3RyaW5nQ2hhciA9IHN0cmluZ1tqXTtcbiAgICAgIGlmIChzdHJpbmdDaGFyID09PSBtYXRjaENoYXIpIHtcbiAgICAgICAgbWF0Y2hpbmdJbk9yZGVyQ2hhckNvdW50ICs9IDE7XG4gICAgICAgIHJldHVybiBqICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJhbmtpbmcoc3ByZWFkKSB7XG4gICAgY29uc3Qgc3ByZWFkUGVyY2VudGFnZSA9IDEgLyBzcHJlYWQ7XG4gICAgY29uc3QgaW5PcmRlclBlcmNlbnRhZ2UgPSBtYXRjaGluZ0luT3JkZXJDaGFyQ291bnQgLyBzdHJpbmdUb1JhbmsubGVuZ3RoO1xuICAgIGNvbnN0IHJhbmtpbmcgPSByYW5raW5ncy5NQVRDSEVTICsgaW5PcmRlclBlcmNlbnRhZ2UgKiBzcHJlYWRQZXJjZW50YWdlO1xuICAgIHJldHVybiByYW5raW5nO1xuICB9XG4gIGNvbnN0IGZpcnN0SW5kZXggPSBmaW5kTWF0Y2hpbmdDaGFyYWN0ZXIoc3RyaW5nVG9SYW5rWzBdLCB0ZXN0U3RyaW5nLCAwKTtcbiAgaWYgKGZpcnN0SW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLk5PX01BVENIO1xuICB9XG4gIGNoYXJOdW1iZXIgPSBmaXJzdEluZGV4O1xuICBmb3IgKGxldCBpID0gMSwgSSA9IHN0cmluZ1RvUmFuay5sZW5ndGg7IGkgPCBJOyBpKyspIHtcbiAgICBjb25zdCBtYXRjaENoYXIgPSBzdHJpbmdUb1JhbmtbaV07XG4gICAgY2hhck51bWJlciA9IGZpbmRNYXRjaGluZ0NoYXJhY3RlcihtYXRjaENoYXIsIHRlc3RTdHJpbmcsIGNoYXJOdW1iZXIpO1xuICAgIGNvbnN0IGZvdW5kID0gY2hhck51bWJlciA+IC0xO1xuICAgIGlmICghZm91bmQpIHtcbiAgICAgIHJldHVybiByYW5raW5ncy5OT19NQVRDSDtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3ByZWFkID0gY2hhck51bWJlciAtIGZpcnN0SW5kZXg7XG4gIHJldHVybiBnZXRSYW5raW5nKHNwcmVhZCk7XG59XG5cbi8qKlxuICogU29ydHMgaXRlbXMgdGhhdCBoYXZlIGEgcmFuaywgaW5kZXgsIGFuZCBhY2Nlc3NvckluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gYSAtIHRoZSBmaXJzdCBpdGVtIHRvIHNvcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIC0gdGhlIHNlY29uZCBpdGVtIHRvIHNvcnRcbiAqIEByZXR1cm4ge051bWJlcn0gLTEgaWYgYSBzaG91bGQgY29tZSBmaXJzdCwgMSBpZiBiIHNob3VsZCBjb21lIGZpcnN0LCAwIGlmIGVxdWFsXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVJdGVtcyhhLCBiKSB7XG4gIHJldHVybiBhLnJhbmsgPT09IGIucmFuayA/IDAgOiBhLnJhbmsgPiBiLnJhbmsgPyAtMSA6IDE7XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdmFsdWUgZm9yIGNvbXBhcmlzb24gYnkgc3RyaW5naWZ5aW5nIGl0LCByZW1vdmluZyBkaWFjcml0aWNzIChpZiBzcGVjaWZpZWQpXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gY2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0ge2tlZXBEaWFjcml0aWNzOiB3aGV0aGVyIHRvIHJlbW92ZSBkaWFjcml0aWNzfVxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcHJlcGFyZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcHJlcGFyZVZhbHVlRm9yQ29tcGFyaXNvbih2YWx1ZSwgX3JlZikge1xuICBsZXQge1xuICAgIGtlZXBEaWFjcml0aWNzXG4gIH0gPSBfcmVmO1xuICAvLyB2YWx1ZSBtaWdodCBub3QgYWN0dWFsbHkgYmUgYSBzdHJpbmcgYXQgdGhpcyBwb2ludCAod2UgZG9uJ3QgZ2V0IHRvIGNob29zZSlcbiAgLy8gc28gcGFydCBvZiBwcmVwYXJpbmcgdGhlIHZhbHVlIGZvciBjb21wYXJpc29uIGlzIGVuc3VyZSB0aGF0IGl0IGlzIGEgc3RyaW5nXG4gIHZhbHVlID0gYCR7dmFsdWV9YDsgLy8gdG9TdHJpbmdcbiAgaWYgKCFrZWVwRGlhY3JpdGljcykge1xuICAgIHZhbHVlID0gcmVtb3ZlQWNjZW50cyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEdldHMgdmFsdWUgZm9yIGtleSBpbiBpdGVtIGF0IGFyYml0cmFyaWx5IG5lc3RlZCBrZXlwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSAtIHRoZSBpdGVtXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0ga2V5IC0gdGhlIHBvdGVudGlhbGx5IG5lc3RlZCBrZXlwYXRoIG9yIHByb3BlcnR5IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtBcnJheX0gLSBhbiBhcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZShzKSBhdCB0aGUgbmVzdGVkIGtleXBhdGhcbiAqL1xuZnVuY3Rpb24gZ2V0SXRlbVZhbHVlcyhpdGVtLCBhY2Nlc3Nvcikge1xuICBsZXQgYWNjZXNzb3JGbiA9IGFjY2Vzc29yO1xuICBpZiAodHlwZW9mIGFjY2Vzc29yID09PSAnb2JqZWN0Jykge1xuICAgIGFjY2Vzc29yRm4gPSBhY2Nlc3Nvci5hY2Nlc3NvcjtcbiAgfVxuICBjb25zdCB2YWx1ZSA9IGFjY2Vzc29yRm4oaXRlbSk7XG5cbiAgLy8gYmVjYXVzZSBgdmFsdWVgIGNhbiBhbHNvIGJlIHVuZGVmaW5lZFxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIFtTdHJpbmcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBHZXRzIGFsbCB0aGUgdmFsdWVzIGZvciB0aGUgZ2l2ZW4ga2V5cyBpbiB0aGUgZ2l2ZW4gaXRlbSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aG9zZSB2YWx1ZXNcbiAqIEBwYXJhbSBpdGVtIC0gdGhlIGl0ZW0gZnJvbSB3aGljaCB0aGUgdmFsdWVzIHdpbGwgYmUgcmV0cmlldmVkXG4gKiBAcGFyYW0ga2V5cyAtIHRoZSBrZXlzIHRvIHVzZSB0byByZXRyaWV2ZSB0aGUgdmFsdWVzXG4gKiBAcmV0dXJuIG9iamVjdHMgd2l0aCB7aXRlbVZhbHVlLCBhdHRyaWJ1dGVzfVxuICovXG5mdW5jdGlvbiBnZXRBbGxWYWx1ZXNUb1JhbmsoaXRlbSwgYWNjZXNzb3JzKSB7XG4gIGNvbnN0IGFsbFZhbHVlcyA9IFtdO1xuICBmb3IgKGxldCBqID0gMCwgSiA9IGFjY2Vzc29ycy5sZW5ndGg7IGogPCBKOyBqKyspIHtcbiAgICBjb25zdCBhY2Nlc3NvciA9IGFjY2Vzc29yc1tqXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2V0QWNjZXNzb3JBdHRyaWJ1dGVzKGFjY2Vzc29yKTtcbiAgICBjb25zdCBpdGVtVmFsdWVzID0gZ2V0SXRlbVZhbHVlcyhpdGVtLCBhY2Nlc3Nvcik7XG4gICAgZm9yIChsZXQgaSA9IDAsIEkgPSBpdGVtVmFsdWVzLmxlbmd0aDsgaSA8IEk7IGkrKykge1xuICAgICAgYWxsVmFsdWVzLnB1c2goe1xuICAgICAgICBpdGVtVmFsdWU6IGl0ZW1WYWx1ZXNbaV0sXG4gICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxsVmFsdWVzO1xufVxuY29uc3QgZGVmYXVsdEtleUF0dHJpYnV0ZXMgPSB7XG4gIG1heFJhbmtpbmc6IEluZmluaXR5LFxuICBtaW5SYW5raW5nOiAtSW5maW5pdHlcbn07XG4vKipcbiAqIEdldHMgYWxsIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgZ2l2ZW4gYWNjZXNzb3JcbiAqIEBwYXJhbSBhY2Nlc3NvciAtIHRoZSBhY2Nlc3NvciBmcm9tIHdoaWNoIHRoZSBhdHRyaWJ1dGVzIHdpbGwgYmUgcmV0cmlldmVkXG4gKiBAcmV0dXJuIG9iamVjdCBjb250YWluaW5nIHRoZSBhY2Nlc3NvcidzIGF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0QWNjZXNzb3JBdHRyaWJ1dGVzKGFjY2Vzc29yKSB7XG4gIGlmICh0eXBlb2YgYWNjZXNzb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZGVmYXVsdEtleUF0dHJpYnV0ZXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kZWZhdWx0S2V5QXR0cmlidXRlcyxcbiAgICAuLi5hY2Nlc3NvclxuICB9O1xufVxuXG5leHBvcnQgeyBjb21wYXJlSXRlbXMsIHJhbmtJdGVtLCByYW5raW5ncyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-table/build/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnSizing),\n/* harmony export */   Expanding: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Expanding),\n/* harmony export */   Filters: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Filters),\n/* harmony export */   Grouping: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Grouping),\n/* harmony export */   Headers: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Headers),\n/* harmony export */   Ordering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Ordering),\n/* harmony export */   Pagination: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Pagination),\n/* harmony export */   Pinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Pinning),\n/* harmony export */   RowSelection: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSelection),\n/* harmony export */   Sorting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Sorting),\n/* harmony export */   Visibility: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Visibility),\n/* harmony export */   _getVisibleLeafColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__._getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.buildHeaderGroups),\n/* harmony export */   createCell: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createCell),\n/* harmony export */   createColumn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumn),\n/* harmony export */   createColumnHelper: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumnHelper),\n/* harmony export */   createRow: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createRow),\n/* harmony export */   createTable: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable),\n/* harmony export */   defaultColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.expandRows),\n/* harmony export */   filterFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.filterFns),\n/* harmony export */   flattenBy: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.flattenBy),\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   functionalUpdate: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getSortedRowModel),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isFunction),\n/* harmony export */   isNumberArray: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isNumberArray),\n/* harmony export */   isRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.makeStateUpdater),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.memo),\n/* harmony export */   noop: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   orderColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.sortingFns),\n/* harmony export */   useReactTable: () => (/* binding */ useReactTable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/table-core */ \"(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/**\n   * react-table\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */\n\n\n\n\n//\n\n/**\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\n */\nfunction flexRender(Comp, props) {\n  return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, props) : Comp;\n}\nfunction isReactComponent(component) {\n  return isClassComponent(component) || typeof component === 'function' || isExoticComponent(component);\n}\nfunction isClassComponent(component) {\n  return typeof component === 'function' && (() => {\n    const proto = Object.getPrototypeOf(component);\n    return proto.prototype && proto.prototype.isReactComponent;\n  })();\n}\nfunction isExoticComponent(component) {\n  return typeof component === 'object' && typeof component.$$typeof === 'symbol' && ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description);\n}\nfunction useReactTable(options) {\n  // Compose in the generic options to the user options\n  const resolvedOptions = {\n    state: {},\n    // Dummy state\n    onStateChange: () => {},\n    // noop\n    renderFallbackValue: null,\n    ...options\n  };\n\n  // Create a new table and store it in state\n  const [tableRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => ({\n    current: (0,_tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable)(resolvedOptions)\n  }));\n\n  // By default, manage table state here using the table's initial state\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => tableRef.current.initialState);\n\n  // Compose the default state above with any user state. This will allow the user\n  // to only control a subset of the state if desired.\n  tableRef.current.setOptions(prev => ({\n    ...prev,\n    ...options,\n    state: {\n      ...state,\n      ...options.state\n    },\n    // Similarly, we'll maintain both our internal state and any user-provided\n    // state.\n    onStateChange: updater => {\n      setState(updater);\n      options.onStateChange == null || options.onStateChange(updater);\n    }\n  }));\n  return tableRef.current;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0I7QUFDb0I7QUFDZDs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0RBQW1CO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMkNBQWM7QUFDbkMsYUFBYSxpRUFBVztBQUN4QixHQUFHOztBQUVIO0FBQ0EsNEJBQTRCLDJDQUFjOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVxQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZXh5LW11aS1uZXh0anMtYWRtaW4tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanM/Y2U5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgICogcmVhY3QtdGFibGVcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKlxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVUYWJsZSB9IGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcblxuLy9cblxuLyoqXG4gKiBJZiByZW5kZXJpbmcgaGVhZGVycywgY2VsbHMsIG9yIGZvb3RlcnMgd2l0aCBjdXN0b20gbWFya3VwLCB1c2UgZmxleFJlbmRlciBpbnN0ZWFkIG9mIGBjZWxsLmdldFZhbHVlKClgIG9yIGBjZWxsLnJlbmRlclZhbHVlKClgLlxuICovXG5mdW5jdGlvbiBmbGV4UmVuZGVyKENvbXAsIHByb3BzKSB7XG4gIHJldHVybiAhQ29tcCA/IG51bGwgOiBpc1JlYWN0Q29tcG9uZW50KENvbXApID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcCwgcHJvcHMpIDogQ29tcDtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgfHwgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgKCgpID0+IHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21wb25lbnQpO1xuICAgIHJldHVybiBwcm90by5wcm90b3R5cGUgJiYgcHJvdG8ucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb21wb25lbnQuJCR0eXBlb2YgPT09ICdzeW1ib2wnICYmIFsncmVhY3QubWVtbycsICdyZWFjdC5mb3J3YXJkX3JlZiddLmluY2x1ZGVzKGNvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbik7XG59XG5mdW5jdGlvbiB1c2VSZWFjdFRhYmxlKG9wdGlvbnMpIHtcbiAgLy8gQ29tcG9zZSBpbiB0aGUgZ2VuZXJpYyBvcHRpb25zIHRvIHRoZSB1c2VyIG9wdGlvbnNcbiAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgIHN0YXRlOiB7fSxcbiAgICAvLyBEdW1teSBzdGF0ZVxuICAgIG9uU3RhdGVDaGFuZ2U6ICgpID0+IHt9LFxuICAgIC8vIG5vb3BcbiAgICByZW5kZXJGYWxsYmFja1ZhbHVlOiBudWxsLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgdGFibGUgYW5kIHN0b3JlIGl0IGluIHN0YXRlXG4gIGNvbnN0IFt0YWJsZVJlZl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiAoe1xuICAgIGN1cnJlbnQ6IGNyZWF0ZVRhYmxlKHJlc29sdmVkT3B0aW9ucylcbiAgfSkpO1xuXG4gIC8vIEJ5IGRlZmF1bHQsIG1hbmFnZSB0YWJsZSBzdGF0ZSBoZXJlIHVzaW5nIHRoZSB0YWJsZSdzIGluaXRpYWwgc3RhdGVcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB0YWJsZVJlZi5jdXJyZW50LmluaXRpYWxTdGF0ZSk7XG5cbiAgLy8gQ29tcG9zZSB0aGUgZGVmYXVsdCBzdGF0ZSBhYm92ZSB3aXRoIGFueSB1c2VyIHN0YXRlLiBUaGlzIHdpbGwgYWxsb3cgdGhlIHVzZXJcbiAgLy8gdG8gb25seSBjb250cm9sIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZSBpZiBkZXNpcmVkLlxuICB0YWJsZVJlZi5jdXJyZW50LnNldE9wdGlvbnMocHJldiA9PiAoe1xuICAgIC4uLnByZXYsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBzdGF0ZToge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi5vcHRpb25zLnN0YXRlXG4gICAgfSxcbiAgICAvLyBTaW1pbGFybHksIHdlJ2xsIG1haW50YWluIGJvdGggb3VyIGludGVybmFsIHN0YXRlIGFuZCBhbnkgdXNlci1wcm92aWRlZFxuICAgIC8vIHN0YXRlLlxuICAgIG9uU3RhdGVDaGFuZ2U6IHVwZGF0ZXIgPT4ge1xuICAgICAgc2V0U3RhdGUodXBkYXRlcik7XG4gICAgICBvcHRpb25zLm9uU3RhdGVDaGFuZ2UgPT0gbnVsbCB8fCBvcHRpb25zLm9uU3RhdGVDaGFuZ2UodXBkYXRlcik7XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiB0YWJsZVJlZi5jdXJyZW50O1xufVxuXG5leHBvcnQgeyBmbGV4UmVuZGVyLCB1c2VSZWFjdFRhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   Expanding: () => (/* binding */ Expanding),\n/* harmony export */   Filters: () => (/* binding */ Filters),\n/* harmony export */   Grouping: () => (/* binding */ Grouping),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Ordering: () => (/* binding */ Ordering),\n/* harmony export */   Pagination: () => (/* binding */ Pagination),\n/* harmony export */   Pinning: () => (/* binding */ Pinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   Sorting: () => (/* binding */ Sorting),\n/* harmony export */   Visibility: () => (/* binding */ Visibility),\n/* harmony export */   _getVisibleLeafColumns: () => (/* binding */ _getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* binding */ getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\n   * table-core\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */\n// Is this type a tuple?\n\n// If this type is a tuple, what indices are allowed?\n\n///\n\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction noop() {\n  //\n}\nfunction makeStateUpdater(key, instance) {\n  return updater => {\n    instance.setState(old => {\n      return {\n        ...old,\n        [key]: functionalUpdate(updater, old[key])\n      };\n    });\n  };\n}\nfunction isFunction(d) {\n  return d instanceof Function;\n}\nfunction isNumberArray(d) {\n  return Array.isArray(d) && d.every(val => typeof val === 'number');\n}\nfunction flattenBy(arr, getChildren) {\n  const flat = [];\n  const recurse = subArr => {\n    subArr.forEach(item => {\n      flat.push(item);\n      const children = getChildren(item);\n      if (children != null && children.length) {\n        recurse(children);\n      }\n    });\n  };\n  recurse(arr);\n  return flat;\n}\nfunction memo(getDeps, fn, opts) {\n  let deps = [];\n  let result;\n  return depArgs => {\n    let depTime;\n    if (opts.key && opts.debug) depTime = Date.now();\n    const newDeps = getDeps(depArgs);\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && opts.debug) resultTime = Date.now();\n    result = fn(...newDeps);\n    opts == null || opts.onChange == null || opts.onChange(result);\n    if (opts.key && opts.debug) {\n      if (opts != null && opts.debug()) {\n        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n        const resultFpsPercentage = resultEndTime / 16;\n        const pad = (str, num) => {\n          str = String(str);\n          while (str.length < num) {\n            str = ' ' + str;\n          }\n          return str;\n        };\n        console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n      }\n    }\n    return result;\n  };\n}\nfunction getMemoOptions(tableOptions, debugLevel, key, onChange) {\n  return {\n    debug: () => {\n      var _tableOptions$debugAl;\n      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];\n    },\n    key:  true && key,\n    onChange\n  };\n}\n\nfunction createColumn(table, columnDef, depth, parent) {\n  var _ref, _resolvedColumnDef$id;\n  const defaultColumn = table._getDefaultColumnDef();\n  const resolvedColumnDef = {\n    ...defaultColumn,\n    ...columnDef\n  };\n  const accessorKey = resolvedColumnDef.accessorKey;\n  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace('.', '_') : undefined) != null ? _ref : typeof resolvedColumnDef.header === 'string' ? resolvedColumnDef.header : undefined;\n  let accessorFn;\n  if (resolvedColumnDef.accessorFn) {\n    accessorFn = resolvedColumnDef.accessorFn;\n  } else if (accessorKey) {\n    // Support deep accessor keys\n    if (accessorKey.includes('.')) {\n      accessorFn = originalRow => {\n        let result = originalRow;\n        for (const key of accessorKey.split('.')) {\n          var _result;\n          result = (_result = result) == null ? void 0 : _result[key];\n          if ( true && result === undefined) {\n            console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\n          }\n        }\n        return result;\n      };\n    } else {\n      accessorFn = originalRow => originalRow[resolvedColumnDef.accessorKey];\n    }\n  }\n  if (!id) {\n    if (true) {\n      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\n    }\n    throw new Error();\n  }\n  let column = {\n    id: `${String(id)}`,\n    accessorFn,\n    parent: parent,\n    depth,\n    columnDef: resolvedColumnDef,\n    columns: [],\n    getFlatColumns: memo(() => [true], () => {\n      var _column$columns;\n      return [column, ...((_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap(d => d.getFlatColumns()))];\n    }, getMemoOptions(table.options, 'debugColumns', 'column.getFlatColumns')),\n    getLeafColumns: memo(() => [table._getOrderColumnsFn()], orderColumns => {\n      var _column$columns2;\n      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n        let leafColumns = column.columns.flatMap(column => column.getLeafColumns());\n        return orderColumns(leafColumns);\n      }\n      return [column];\n    }, getMemoOptions(table.options, 'debugColumns', 'column.getLeafColumns'))\n  };\n  for (const feature of table._features) {\n    feature.createColumn == null || feature.createColumn(column, table);\n  }\n\n  // Yes, we have to convert table to uknown, because we know more than the compiler here.\n  return column;\n}\n\nconst debug = 'debugHeaders';\n//\n\nfunction createHeader(table, column, options) {\n  var _options$id;\n  const id = (_options$id = options.id) != null ? _options$id : column.id;\n  let header = {\n    id,\n    column,\n    index: options.index,\n    isPlaceholder: !!options.isPlaceholder,\n    placeholderId: options.placeholderId,\n    depth: options.depth,\n    subHeaders: [],\n    colSpan: 0,\n    rowSpan: 0,\n    headerGroup: null,\n    getLeafHeaders: () => {\n      const leafHeaders = [];\n      const recurseHeader = h => {\n        if (h.subHeaders && h.subHeaders.length) {\n          h.subHeaders.map(recurseHeader);\n        }\n        leafHeaders.push(h);\n      };\n      recurseHeader(header);\n      return leafHeaders;\n    },\n    getContext: () => ({\n      table,\n      header: header,\n      column\n    })\n  };\n  table._features.forEach(feature => {\n    feature.createHeader == null || feature.createHeader(header, table);\n  });\n  return header;\n}\nconst Headers = {\n  createTable: table => {\n    // Header Groups\n\n    table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\n      var _left$map$filter, _right$map$filter;\n      const leftColumns = (_left$map$filter = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n      const rightColumns = (_right$map$filter = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n      const centerColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);\n      return headerGroups;\n    }, getMemoOptions(table.options, debug, 'getHeaderGroups'));\n    table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\n      leafColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n      return buildHeaderGroups(allColumns, leafColumns, table, 'center');\n    }, getMemoOptions(table.options, debug, 'getCenterHeaderGroups'));\n    table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {\n      var _left$map$filter2;\n      const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n      return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'left');\n    }, getMemoOptions(table.options, debug, 'getLeftHeaderGroups'));\n    table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {\n      var _right$map$filter2;\n      const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n      return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'right');\n    }, getMemoOptions(table.options, debug, 'getRightHeaderGroups'));\n\n    // Footer Groups\n\n    table.getFooterGroups = memo(() => [table.getHeaderGroups()], headerGroups => {\n      return [...headerGroups].reverse();\n    }, getMemoOptions(table.options, debug, 'getFooterGroups'));\n    table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], headerGroups => {\n      return [...headerGroups].reverse();\n    }, getMemoOptions(table.options, debug, 'getLeftFooterGroups'));\n    table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], headerGroups => {\n      return [...headerGroups].reverse();\n    }, getMemoOptions(table.options, debug, 'getCenterFooterGroups'));\n    table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], headerGroups => {\n      return [...headerGroups].reverse();\n    }, getMemoOptions(table.options, debug, 'getRightFooterGroups'));\n\n    // Flat Headers\n\n    table.getFlatHeaders = memo(() => [table.getHeaderGroups()], headerGroups => {\n      return headerGroups.map(headerGroup => {\n        return headerGroup.headers;\n      }).flat();\n    }, getMemoOptions(table.options, debug, 'getFlatHeaders'));\n    table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], left => {\n      return left.map(headerGroup => {\n        return headerGroup.headers;\n      }).flat();\n    }, getMemoOptions(table.options, debug, 'getLeftFlatHeaders'));\n    table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], left => {\n      return left.map(headerGroup => {\n        return headerGroup.headers;\n      }).flat();\n    }, getMemoOptions(table.options, debug, 'getCenterFlatHeaders'));\n    table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], left => {\n      return left.map(headerGroup => {\n        return headerGroup.headers;\n      }).flat();\n    }, getMemoOptions(table.options, debug, 'getRightFlatHeaders'));\n\n    // Leaf Headers\n\n    table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], flatHeaders => {\n      return flatHeaders.filter(header => {\n        var _header$subHeaders;\n        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n      });\n    }, getMemoOptions(table.options, debug, 'getCenterLeafHeaders'));\n    table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], flatHeaders => {\n      return flatHeaders.filter(header => {\n        var _header$subHeaders2;\n        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n      });\n    }, getMemoOptions(table.options, debug, 'getLeftLeafHeaders'));\n    table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], flatHeaders => {\n      return flatHeaders.filter(header => {\n        var _header$subHeaders3;\n        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n      });\n    }, getMemoOptions(table.options, debug, 'getRightLeafHeaders'));\n    table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {\n      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n      return [...((_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : []), ...((_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : []), ...((_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : [])].map(header => {\n        return header.getLeafHeaders();\n      }).flat();\n    }, getMemoOptions(table.options, debug, 'getLeafHeaders'));\n  }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\n  var _headerGroups$0$heade, _headerGroups$;\n  // Find the max depth of the columns:\n  // build the leaf column row\n  // build each buffer row going up\n  //    placeholder for non-existent level\n  //    real column for existing level\n\n  let maxDepth = 0;\n  const findMaxDepth = function (columns, depth) {\n    if (depth === void 0) {\n      depth = 1;\n    }\n    maxDepth = Math.max(maxDepth, depth);\n    columns.filter(column => column.getIsVisible()).forEach(column => {\n      var _column$columns;\n      if ((_column$columns = column.columns) != null && _column$columns.length) {\n        findMaxDepth(column.columns, depth + 1);\n      }\n    }, 0);\n  };\n  findMaxDepth(allColumns);\n  let headerGroups = [];\n  const createHeaderGroup = (headersToGroup, depth) => {\n    // The header group we are creating\n    const headerGroup = {\n      depth,\n      id: [headerFamily, `${depth}`].filter(Boolean).join('_'),\n      headers: []\n    };\n\n    // The parent columns we're going to scan next\n    const pendingParentHeaders = [];\n\n    // Scan each column for parents\n    headersToGroup.forEach(headerToGroup => {\n      // What is the latest (last) parent column?\n\n      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];\n      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n      let column;\n      let isPlaceholder = false;\n      if (isLeafHeader && headerToGroup.column.parent) {\n        // The parent header is new\n        column = headerToGroup.column.parent;\n      } else {\n        // The parent header is repeated\n        column = headerToGroup.column;\n        isPlaceholder = true;\n      }\n      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n        // This column is repeated. Add it as a sub header to the next batch\n        latestPendingParentHeader.subHeaders.push(headerToGroup);\n      } else {\n        // This is a new header. Let's create it\n        const header = createHeader(table, column, {\n          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join('_'),\n          isPlaceholder,\n          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter(d => d.column === column).length}` : undefined,\n          depth,\n          index: pendingParentHeaders.length\n        });\n\n        // Add the headerToGroup as a subHeader of the new header\n        header.subHeaders.push(headerToGroup);\n        // Add the new header to the pendingParentHeaders to get grouped\n        // in the next batch\n        pendingParentHeaders.push(header);\n      }\n      headerGroup.headers.push(headerToGroup);\n      headerToGroup.headerGroup = headerGroup;\n    });\n    headerGroups.push(headerGroup);\n    if (depth > 0) {\n      createHeaderGroup(pendingParentHeaders, depth - 1);\n    }\n  };\n  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(table, column, {\n    depth: maxDepth,\n    index\n  }));\n  createHeaderGroup(bottomHeaders, maxDepth - 1);\n  headerGroups.reverse();\n\n  // headerGroups = headerGroups.filter(headerGroup => {\n  //   return !headerGroup.headers.every(header => header.isPlaceholder)\n  // })\n\n  const recurseHeadersForSpans = headers => {\n    const filteredHeaders = headers.filter(header => header.column.getIsVisible());\n    return filteredHeaders.map(header => {\n      let colSpan = 0;\n      let rowSpan = 0;\n      let childRowSpans = [0];\n      if (header.subHeaders && header.subHeaders.length) {\n        childRowSpans = [];\n        recurseHeadersForSpans(header.subHeaders).forEach(_ref => {\n          let {\n            colSpan: childColSpan,\n            rowSpan: childRowSpan\n          } = _ref;\n          colSpan += childColSpan;\n          childRowSpans.push(childRowSpan);\n        });\n      } else {\n        colSpan = 1;\n      }\n      const minChildRowSpan = Math.min(...childRowSpans);\n      rowSpan = rowSpan + minChildRowSpan;\n      header.colSpan = colSpan;\n      header.rowSpan = rowSpan;\n      return {\n        colSpan,\n        rowSpan\n      };\n    });\n  };\n  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n  return headerGroups;\n}\n\n//\n\n//\n\nconst defaultColumnSizing = {\n  size: 150,\n  minSize: 20,\n  maxSize: Number.MAX_SAFE_INTEGER\n};\nconst getDefaultColumnSizingInfoState = () => ({\n  startOffset: null,\n  startSize: null,\n  deltaOffset: null,\n  deltaPercentage: null,\n  isResizingColumn: false,\n  columnSizingStart: []\n});\nconst ColumnSizing = {\n  getDefaultColumnDef: () => {\n    return defaultColumnSizing;\n  },\n  getInitialState: state => {\n    return {\n      columnSizing: {},\n      columnSizingInfo: getDefaultColumnSizingInfoState(),\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      columnResizeMode: 'onEnd',\n      columnResizeDirection: 'ltr',\n      onColumnSizingChange: makeStateUpdater('columnSizing', table),\n      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', table)\n    };\n  },\n  createColumn: (column, table) => {\n    column.getSize = () => {\n      var _column$columnDef$min, _ref, _column$columnDef$max;\n      const columnSize = table.getState().columnSizing[column.id];\n      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n    };\n    column.getStart = memo(position => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(0, column.getIndex(position)).reduce((sum, column) => sum + column.getSize(), 0), getMemoOptions(table.options, 'debugColumns', 'getStart'));\n    column.getAfter = memo(position => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(column.getIndex(position) + 1).reduce((sum, column) => sum + column.getSize(), 0), getMemoOptions(table.options, 'debugColumns', 'getAfter'));\n    column.resetSize = () => {\n      table.setColumnSizing(_ref2 => {\n        let {\n          [column.id]: _,\n          ...rest\n        } = _ref2;\n        return rest;\n      });\n    };\n    column.getCanResize = () => {\n      var _column$columnDef$ena, _table$options$enable;\n      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\n    };\n    column.getIsResizing = () => {\n      return table.getState().columnSizingInfo.isResizingColumn === column.id;\n    };\n  },\n  createHeader: (header, table) => {\n    header.getSize = () => {\n      let sum = 0;\n      const recurse = header => {\n        if (header.subHeaders.length) {\n          header.subHeaders.forEach(recurse);\n        } else {\n          var _header$column$getSiz;\n          sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n        }\n      };\n      recurse(header);\n      return sum;\n    };\n    header.getStart = () => {\n      if (header.index > 0) {\n        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n      }\n      return 0;\n    };\n    header.getResizeHandler = _contextDocument => {\n      const column = table.getColumn(header.column.id);\n      const canResize = column == null ? void 0 : column.getCanResize();\n      return e => {\n        if (!column || !canResize) {\n          return;\n        }\n        e.persist == null || e.persist();\n        if (isTouchStartEvent(e)) {\n          // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n          if (e.touches && e.touches.length > 1) {\n            return;\n          }\n        }\n        const startSize = header.getSize();\n        const columnSizingStart = header ? header.getLeafHeaders().map(d => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];\n        const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n        const newColumnSizing = {};\n        const updateOffset = (eventType, clientXPos) => {\n          if (typeof clientXPos !== 'number') {\n            return;\n          }\n          table.setColumnSizingInfo(old => {\n            var _old$startOffset, _old$startSize;\n            const deltaDirection = table.options.columnResizeDirection === 'rtl' ? -1 : 1;\n            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;\n            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n            old.columnSizingStart.forEach(_ref3 => {\n              let [columnId, headerSize] = _ref3;\n              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n            });\n            return {\n              ...old,\n              deltaOffset,\n              deltaPercentage\n            };\n          });\n          if (table.options.columnResizeMode === 'onChange' || eventType === 'end') {\n            table.setColumnSizing(old => ({\n              ...old,\n              ...newColumnSizing\n            }));\n          }\n        };\n        const onMove = clientXPos => updateOffset('move', clientXPos);\n        const onEnd = clientXPos => {\n          updateOffset('end', clientXPos);\n          table.setColumnSizingInfo(old => ({\n            ...old,\n            isResizingColumn: false,\n            startOffset: null,\n            startSize: null,\n            deltaOffset: null,\n            deltaPercentage: null,\n            columnSizingStart: []\n          }));\n        };\n        const contextDocument = _contextDocument || typeof document !== 'undefined' ? document : null;\n        const mouseEvents = {\n          moveHandler: e => onMove(e.clientX),\n          upHandler: e => {\n            contextDocument == null || contextDocument.removeEventListener('mousemove', mouseEvents.moveHandler);\n            contextDocument == null || contextDocument.removeEventListener('mouseup', mouseEvents.upHandler);\n            onEnd(e.clientX);\n          }\n        };\n        const touchEvents = {\n          moveHandler: e => {\n            if (e.cancelable) {\n              e.preventDefault();\n              e.stopPropagation();\n            }\n            onMove(e.touches[0].clientX);\n            return false;\n          },\n          upHandler: e => {\n            var _e$touches$;\n            contextDocument == null || contextDocument.removeEventListener('touchmove', touchEvents.moveHandler);\n            contextDocument == null || contextDocument.removeEventListener('touchend', touchEvents.upHandler);\n            if (e.cancelable) {\n              e.preventDefault();\n              e.stopPropagation();\n            }\n            onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\n          }\n        };\n        const passiveIfSupported = passiveEventSupported() ? {\n          passive: false\n        } : false;\n        if (isTouchStartEvent(e)) {\n          contextDocument == null || contextDocument.addEventListener('touchmove', touchEvents.moveHandler, passiveIfSupported);\n          contextDocument == null || contextDocument.addEventListener('touchend', touchEvents.upHandler, passiveIfSupported);\n        } else {\n          contextDocument == null || contextDocument.addEventListener('mousemove', mouseEvents.moveHandler, passiveIfSupported);\n          contextDocument == null || contextDocument.addEventListener('mouseup', mouseEvents.upHandler, passiveIfSupported);\n        }\n        table.setColumnSizingInfo(old => ({\n          ...old,\n          startOffset: clientX,\n          startSize,\n          deltaOffset: 0,\n          deltaPercentage: 0,\n          columnSizingStart,\n          isResizingColumn: column.id\n        }));\n      };\n    };\n  },\n  createTable: table => {\n    table.setColumnSizing = updater => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\n    table.setColumnSizingInfo = updater => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\n    table.resetColumnSizing = defaultState => {\n      var _table$initialState$c;\n      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\n    };\n    table.resetHeaderSizeInfo = defaultState => {\n      var _table$initialState$c2;\n      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\n    };\n    table.getTotalSize = () => {\n      var _table$getHeaderGroup, _table$getHeaderGroup2;\n      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header) => {\n        return sum + header.getSize();\n      }, 0)) != null ? _table$getHeaderGroup : 0;\n    };\n    table.getLeftTotalSize = () => {\n      var _table$getLeftHeaderG, _table$getLeftHeaderG2;\n      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header) => {\n        return sum + header.getSize();\n      }, 0)) != null ? _table$getLeftHeaderG : 0;\n    };\n    table.getCenterTotalSize = () => {\n      var _table$getCenterHeade, _table$getCenterHeade2;\n      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header) => {\n        return sum + header.getSize();\n      }, 0)) != null ? _table$getCenterHeade : 0;\n    };\n    table.getRightTotalSize = () => {\n      var _table$getRightHeader, _table$getRightHeader2;\n      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header) => {\n        return sum + header.getSize();\n      }, 0)) != null ? _table$getRightHeader : 0;\n    };\n  }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n  if (typeof passiveSupported === 'boolean') return passiveSupported;\n  let supported = false;\n  try {\n    const options = {\n      get passive() {\n        supported = true;\n        return false;\n      }\n    };\n    const noop = () => {};\n    window.addEventListener('test', noop, options);\n    window.removeEventListener('test', noop);\n  } catch (err) {\n    supported = false;\n  }\n  passiveSupported = supported;\n  return passiveSupported;\n}\nfunction isTouchStartEvent(e) {\n  return e.type === 'touchstart';\n}\n\n//\n\nconst Expanding = {\n  getInitialState: state => {\n    return {\n      expanded: {},\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onExpandedChange: makeStateUpdater('expanded', table),\n      paginateExpandedRows: true\n    };\n  },\n  createTable: table => {\n    let registered = false;\n    let queued = false;\n    table._autoResetExpanded = () => {\n      var _ref, _table$options$autoRe;\n      if (!registered) {\n        table._queue(() => {\n          registered = true;\n        });\n        return;\n      }\n      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\n        if (queued) return;\n        queued = true;\n        table._queue(() => {\n          table.resetExpanded();\n          queued = false;\n        });\n      }\n    };\n    table.setExpanded = updater => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\n    table.toggleAllRowsExpanded = expanded => {\n      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\n        table.setExpanded(true);\n      } else {\n        table.setExpanded({});\n      }\n    };\n    table.resetExpanded = defaultState => {\n      var _table$initialState$e, _table$initialState;\n      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\n    };\n    table.getCanSomeRowsExpand = () => {\n      return table.getPrePaginationRowModel().flatRows.some(row => row.getCanExpand());\n    };\n    table.getToggleAllRowsExpandedHandler = () => {\n      return e => {\n        e.persist == null || e.persist();\n        table.toggleAllRowsExpanded();\n      };\n    };\n    table.getIsSomeRowsExpanded = () => {\n      const expanded = table.getState().expanded;\n      return expanded === true || Object.values(expanded).some(Boolean);\n    };\n    table.getIsAllRowsExpanded = () => {\n      const expanded = table.getState().expanded;\n\n      // If expanded is true, save some cycles and return true\n      if (typeof expanded === 'boolean') {\n        return expanded === true;\n      }\n      if (!Object.keys(expanded).length) {\n        return false;\n      }\n\n      // If any row is not expanded, return false\n      if (table.getRowModel().flatRows.some(row => !row.getIsExpanded())) {\n        return false;\n      }\n\n      // They must all be expanded :shrug:\n      return true;\n    };\n    table.getExpandedDepth = () => {\n      let maxDepth = 0;\n      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\n      rowIds.forEach(id => {\n        const splitId = id.split('.');\n        maxDepth = Math.max(maxDepth, splitId.length);\n      });\n      return maxDepth;\n    };\n    table.getPreExpandedRowModel = () => table.getSortedRowModel();\n    table.getExpandedRowModel = () => {\n      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n        table._getExpandedRowModel = table.options.getExpandedRowModel(table);\n      }\n      if (table.options.manualExpanding || !table._getExpandedRowModel) {\n        return table.getPreExpandedRowModel();\n      }\n      return table._getExpandedRowModel();\n    };\n  },\n  createRow: (row, table) => {\n    row.toggleExpanded = expanded => {\n      table.setExpanded(old => {\n        var _expanded;\n        const exists = old === true ? true : !!(old != null && old[row.id]);\n        let oldExpanded = {};\n        if (old === true) {\n          Object.keys(table.getRowModel().rowsById).forEach(rowId => {\n            oldExpanded[rowId] = true;\n          });\n        } else {\n          oldExpanded = old;\n        }\n        expanded = (_expanded = expanded) != null ? _expanded : !exists;\n        if (!exists && expanded) {\n          return {\n            ...oldExpanded,\n            [row.id]: true\n          };\n        }\n        if (exists && !expanded) {\n          const {\n            [row.id]: _,\n            ...rest\n          } = oldExpanded;\n          return rest;\n        }\n        return old;\n      });\n    };\n    row.getIsExpanded = () => {\n      var _table$options$getIsR;\n      const expanded = table.getState().expanded;\n      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n    };\n    row.getCanExpand = () => {\n      var _table$options$getRow, _table$options$enable, _row$subRows;\n      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n    };\n    row.getIsAllParentsExpanded = () => {\n      let isFullyExpanded = true;\n      let currentRow = row;\n      while (isFullyExpanded && currentRow.parentId) {\n        currentRow = table.getRow(currentRow.parentId, true);\n        isFullyExpanded = currentRow.getIsExpanded();\n      }\n      return isFullyExpanded;\n    };\n    row.getToggleExpandedHandler = () => {\n      const canExpand = row.getCanExpand();\n      return () => {\n        if (!canExpand) return;\n        row.toggleExpanded();\n      };\n    };\n  }\n};\n\nconst includesString = (row, columnId, filterValue) => {\n  var _row$getValue;\n  const search = filterValue.toLowerCase();\n  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\n};\nincludesString.autoRemove = val => testFalsey(val);\nconst includesStringSensitive = (row, columnId, filterValue) => {\n  var _row$getValue2;\n  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\n};\nincludesStringSensitive.autoRemove = val => testFalsey(val);\nconst equalsString = (row, columnId, filterValue) => {\n  var _row$getValue3;\n  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\n};\nequalsString.autoRemove = val => testFalsey(val);\nconst arrIncludes = (row, columnId, filterValue) => {\n  var _row$getValue4;\n  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\n};\narrIncludes.autoRemove = val => testFalsey(val) || !(val != null && val.length);\nconst arrIncludesAll = (row, columnId, filterValue) => {\n  return !filterValue.some(val => {\n    var _row$getValue5;\n    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\n  });\n};\narrIncludesAll.autoRemove = val => testFalsey(val) || !(val != null && val.length);\nconst arrIncludesSome = (row, columnId, filterValue) => {\n  return filterValue.some(val => {\n    var _row$getValue6;\n    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\n  });\n};\narrIncludesSome.autoRemove = val => testFalsey(val) || !(val != null && val.length);\nconst equals = (row, columnId, filterValue) => {\n  return row.getValue(columnId) === filterValue;\n};\nequals.autoRemove = val => testFalsey(val);\nconst weakEquals = (row, columnId, filterValue) => {\n  return row.getValue(columnId) == filterValue;\n};\nweakEquals.autoRemove = val => testFalsey(val);\nconst inNumberRange = (row, columnId, filterValue) => {\n  let [min, max] = filterValue;\n  const rowValue = row.getValue(columnId);\n  return rowValue >= min && rowValue <= max;\n};\ninNumberRange.resolveFilterValue = val => {\n  let [unsafeMin, unsafeMax] = val;\n  let parsedMin = typeof unsafeMin !== 'number' ? parseFloat(unsafeMin) : unsafeMin;\n  let parsedMax = typeof unsafeMax !== 'number' ? parseFloat(unsafeMax) : unsafeMax;\n  let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n  if (min > max) {\n    const temp = min;\n    min = max;\n    max = temp;\n  }\n  return [min, max];\n};\ninNumberRange.autoRemove = val => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\n\n// Export\n\nconst filterFns = {\n  includesString,\n  includesStringSensitive,\n  equalsString,\n  arrIncludes,\n  arrIncludesAll,\n  arrIncludesSome,\n  equals,\n  weakEquals,\n  inNumberRange\n};\n// Utils\n\nfunction testFalsey(val) {\n  return val === undefined || val === null || val === '';\n}\n\n//\n\nconst Filters = {\n  getDefaultColumnDef: () => {\n    return {\n      filterFn: 'auto'\n    };\n  },\n  getInitialState: state => {\n    return {\n      columnFilters: [],\n      globalFilter: undefined,\n      // filtersProgress: 1,\n      // facetProgress: {},\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onColumnFiltersChange: makeStateUpdater('columnFilters', table),\n      onGlobalFilterChange: makeStateUpdater('globalFilter', table),\n      filterFromLeafRows: false,\n      maxLeafRowFilterDepth: 100,\n      globalFilterFn: 'auto',\n      getColumnCanGlobalFilter: column => {\n        var _table$getCoreRowMode;\n        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\n        return typeof value === 'string' || typeof value === 'number';\n      }\n    };\n  },\n  createColumn: (column, table) => {\n    column.getAutoFilterFn = () => {\n      const firstRow = table.getCoreRowModel().flatRows[0];\n      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n      if (typeof value === 'string') {\n        return filterFns.includesString;\n      }\n      if (typeof value === 'number') {\n        return filterFns.inNumberRange;\n      }\n      if (typeof value === 'boolean') {\n        return filterFns.equals;\n      }\n      if (value !== null && typeof value === 'object') {\n        return filterFns.equals;\n      }\n      if (Array.isArray(value)) {\n        return filterFns.arrIncludes;\n      }\n      return filterFns.weakEquals;\n    };\n    column.getFilterFn = () => {\n      var _table$options$filter, _table$options$filter2;\n      return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === 'auto' ? column.getAutoFilterFn() : // @ts-ignore\n      (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\n    };\n    column.getCanFilter = () => {\n      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\n      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\n    };\n    column.getCanGlobalFilter = () => {\n      var _column$columnDef$ena2, _table$options$enable3, _table$options$enable4, _table$options$getCol;\n      return ((_column$columnDef$ena2 = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena2 : true) && ((_table$options$enable3 = table.options.enableGlobalFilter) != null ? _table$options$enable3 : true) && ((_table$options$enable4 = table.options.enableFilters) != null ? _table$options$enable4 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\n    };\n    column.getIsFiltered = () => column.getFilterIndex() > -1;\n    column.getFilterValue = () => {\n      var _table$getState$colum;\n      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find(d => d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\n    };\n    column.getFilterIndex = () => {\n      var _table$getState$colum2, _table$getState$colum3;\n      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex(d => d.id === column.id)) != null ? _table$getState$colum2 : -1;\n    };\n    column.setFilterValue = value => {\n      table.setColumnFilters(old => {\n        const filterFn = column.getFilterFn();\n        const previousfilter = old == null ? void 0 : old.find(d => d.id === column.id);\n        const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : undefined);\n\n        //\n        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n          var _old$filter;\n          return (_old$filter = old == null ? void 0 : old.filter(d => d.id !== column.id)) != null ? _old$filter : [];\n        }\n        const newFilterObj = {\n          id: column.id,\n          value: newFilter\n        };\n        if (previousfilter) {\n          var _old$map;\n          return (_old$map = old == null ? void 0 : old.map(d => {\n            if (d.id === column.id) {\n              return newFilterObj;\n            }\n            return d;\n          })) != null ? _old$map : [];\n        }\n        if (old != null && old.length) {\n          return [...old, newFilterObj];\n        }\n        return [newFilterObj];\n      });\n    };\n    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\n    column.getFacetedRowModel = () => {\n      if (!column._getFacetedRowModel) {\n        return table.getPreFilteredRowModel();\n      }\n      return column._getFacetedRowModel();\n    };\n    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\n    column.getFacetedUniqueValues = () => {\n      if (!column._getFacetedUniqueValues) {\n        return new Map();\n      }\n      return column._getFacetedUniqueValues();\n    };\n    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\n    column.getFacetedMinMaxValues = () => {\n      if (!column._getFacetedMinMaxValues) {\n        return undefined;\n      }\n      return column._getFacetedMinMaxValues();\n    };\n    // () => [column.getFacetedRowModel()],\n    // facetedRowModel => getRowModelMinMaxValues(facetedRowModel, column.id),\n  },\n  createRow: (row, table) => {\n    row.columnFilters = {};\n    row.columnFiltersMeta = {};\n  },\n  createTable: table => {\n    table.getGlobalAutoFilterFn = () => {\n      return filterFns.includesString;\n    };\n    table.getGlobalFilterFn = () => {\n      var _table$options$filter3, _table$options$filter4;\n      const {\n        globalFilterFn: globalFilterFn\n      } = table.options;\n      return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === 'auto' ? table.getGlobalAutoFilterFn() : // @ts-ignore\n      (_table$options$filter3 = (_table$options$filter4 = table.options.filterFns) == null ? void 0 : _table$options$filter4[globalFilterFn]) != null ? _table$options$filter3 : filterFns[globalFilterFn];\n    };\n    table.setColumnFilters = updater => {\n      const leafColumns = table.getAllLeafColumns();\n      const updateFn = old => {\n        var _functionalUpdate;\n        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter(filter => {\n          const column = leafColumns.find(d => d.id === filter.id);\n          if (column) {\n            const filterFn = column.getFilterFn();\n            if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n              return false;\n            }\n          }\n          return true;\n        });\n      };\n      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\n    };\n    table.setGlobalFilter = updater => {\n      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\n    };\n    table.resetGlobalFilter = defaultState => {\n      table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\n    };\n    table.resetColumnFilters = defaultState => {\n      var _table$initialState$c, _table$initialState;\n      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\n    };\n    table.getPreFilteredRowModel = () => table.getCoreRowModel();\n    table.getFilteredRowModel = () => {\n      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n        table._getFilteredRowModel = table.options.getFilteredRowModel(table);\n      }\n      if (table.options.manualFiltering || !table._getFilteredRowModel) {\n        return table.getPreFilteredRowModel();\n      }\n      return table._getFilteredRowModel();\n    };\n    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, '__global__');\n    table.getGlobalFacetedRowModel = () => {\n      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n        return table.getPreFilteredRowModel();\n      }\n      return table._getGlobalFacetedRowModel();\n    };\n    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, '__global__');\n    table.getGlobalFacetedUniqueValues = () => {\n      if (!table._getGlobalFacetedUniqueValues) {\n        return new Map();\n      }\n      return table._getGlobalFacetedUniqueValues();\n    };\n    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, '__global__');\n    table.getGlobalFacetedMinMaxValues = () => {\n      if (!table._getGlobalFacetedMinMaxValues) {\n        return;\n      }\n      return table._getGlobalFacetedMinMaxValues();\n    };\n  }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === 'undefined' || typeof value === 'string' && !value;\n}\n\nconst sum = (columnId, _leafRows, childRows) => {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return childRows.reduce((sum, next) => {\n    const nextValue = next.getValue(columnId);\n    return sum + (typeof nextValue === 'number' ? nextValue : 0);\n  }, 0);\n};\nconst min = (columnId, _leafRows, childRows) => {\n  let min;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n    if (value != null && (min > value || min === undefined && value >= value)) {\n      min = value;\n    }\n  });\n  return min;\n};\nconst max = (columnId, _leafRows, childRows) => {\n  let max;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n    if (value != null && (max < value || max === undefined && value >= value)) {\n      max = value;\n    }\n  });\n  return max;\n};\nconst extent = (columnId, _leafRows, childRows) => {\n  let min;\n  let max;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n    if (value != null) {\n      if (min === undefined) {\n        if (value >= value) min = max = value;\n      } else {\n        if (min > value) min = value;\n        if (max < value) max = value;\n      }\n    }\n  });\n  return [min, max];\n};\nconst mean = (columnId, leafRows) => {\n  let count = 0;\n  let sum = 0;\n  leafRows.forEach(row => {\n    let value = row.getValue(columnId);\n    if (value != null && (value = +value) >= value) {\n      ++count, sum += value;\n    }\n  });\n  if (count) return sum / count;\n  return;\n};\nconst median = (columnId, leafRows) => {\n  if (!leafRows.length) {\n    return;\n  }\n  const values = leafRows.map(row => row.getValue(columnId));\n  if (!isNumberArray(values)) {\n    return;\n  }\n  if (values.length === 1) {\n    return values[0];\n  }\n  const mid = Math.floor(values.length / 2);\n  const nums = values.sort((a, b) => a - b);\n  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\nconst unique = (columnId, leafRows) => {\n  return Array.from(new Set(leafRows.map(d => d.getValue(columnId))).values());\n};\nconst uniqueCount = (columnId, leafRows) => {\n  return new Set(leafRows.map(d => d.getValue(columnId))).size;\n};\nconst count = (_columnId, leafRows) => {\n  return leafRows.length;\n};\nconst aggregationFns = {\n  sum,\n  min,\n  max,\n  extent,\n  mean,\n  median,\n  unique,\n  uniqueCount,\n  count\n};\n\n//\n\nconst Grouping = {\n  getDefaultColumnDef: () => {\n    return {\n      aggregatedCell: props => {\n        var _toString, _props$getValue;\n        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\n      },\n      aggregationFn: 'auto'\n    };\n  },\n  getInitialState: state => {\n    return {\n      grouping: [],\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onGroupingChange: makeStateUpdater('grouping', table),\n      groupedColumnMode: 'reorder'\n    };\n  },\n  createColumn: (column, table) => {\n    column.toggleGrouping = () => {\n      table.setGrouping(old => {\n        // Find any existing grouping for this column\n        if (old != null && old.includes(column.id)) {\n          return old.filter(d => d !== column.id);\n        }\n        return [...(old != null ? old : []), column.id];\n      });\n    };\n    column.getCanGroup = () => {\n      var _ref, _ref2, _ref3, _column$columnDef$ena;\n      return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : table.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;\n    };\n    column.getIsGrouped = () => {\n      var _table$getState$group;\n      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\n    };\n    column.getGroupedIndex = () => {\n      var _table$getState$group2;\n      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\n    };\n    column.getToggleGroupingHandler = () => {\n      const canGroup = column.getCanGroup();\n      return () => {\n        if (!canGroup) return;\n        column.toggleGrouping();\n      };\n    };\n    column.getAutoAggregationFn = () => {\n      const firstRow = table.getCoreRowModel().flatRows[0];\n      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n      if (typeof value === 'number') {\n        return aggregationFns.sum;\n      }\n      if (Object.prototype.toString.call(value) === '[object Date]') {\n        return aggregationFns.extent;\n      }\n    };\n    column.getAggregationFn = () => {\n      var _table$options$aggreg, _table$options$aggreg2;\n      if (!column) {\n        throw new Error();\n      }\n      return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === 'auto' ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\n    };\n  },\n  createTable: table => {\n    table.setGrouping = updater => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\n    table.resetGrouping = defaultState => {\n      var _table$initialState$g, _table$initialState;\n      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\n    };\n    table.getPreGroupedRowModel = () => table.getFilteredRowModel();\n    table.getGroupedRowModel = () => {\n      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n        table._getGroupedRowModel = table.options.getGroupedRowModel(table);\n      }\n      if (table.options.manualGrouping || !table._getGroupedRowModel) {\n        return table.getPreGroupedRowModel();\n      }\n      return table._getGroupedRowModel();\n    };\n  },\n  createRow: (row, table) => {\n    row.getIsGrouped = () => !!row.groupingColumnId;\n    row.getGroupingValue = columnId => {\n      if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n        return row._groupingValuesCache[columnId];\n      }\n      const column = table.getColumn(columnId);\n      if (!(column != null && column.columnDef.getGroupingValue)) {\n        return row.getValue(columnId);\n      }\n      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\n      return row._groupingValuesCache[columnId];\n    };\n    row._groupingValuesCache = {};\n  },\n  createCell: (cell, column, row, table) => {\n    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;\n    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();\n    cell.getIsAggregated = () => {\n      var _row$subRows;\n      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n    };\n  }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n  if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n    return leafColumns;\n  }\n  const nonGroupingColumns = leafColumns.filter(col => !grouping.includes(col.id));\n  if (groupedColumnMode === 'remove') {\n    return nonGroupingColumns;\n  }\n  const groupingColumns = grouping.map(g => leafColumns.find(col => col.id === g)).filter(Boolean);\n  return [...groupingColumns, ...nonGroupingColumns];\n}\n\n//\n\nconst Ordering = {\n  getInitialState: state => {\n    return {\n      columnOrder: [],\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onColumnOrderChange: makeStateUpdater('columnOrder', table)\n    };\n  },\n  createColumn: (column, table) => {\n    column.getIndex = memo(position => [_getVisibleLeafColumns(table, position)], columns => columns.findIndex(d => d.id === column.id), getMemoOptions(table.options, 'debugColumns', 'getIndex'));\n    column.getIsFirstColumn = position => {\n      var _columns$;\n      const columns = _getVisibleLeafColumns(table, position);\n      return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;\n    };\n    column.getIsLastColumn = position => {\n      var _columns;\n      const columns = _getVisibleLeafColumns(table, position);\n      return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;\n    };\n  },\n  createTable: table => {\n    table.setColumnOrder = updater => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\n    table.resetColumnOrder = defaultState => {\n      var _table$initialState$c;\n      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\n    };\n    table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => columns => {\n      // Sort grouped columns to the start of the column list\n      // before the headers are built\n      let orderedColumns = [];\n\n      // If there is no order, return the normal columns\n      if (!(columnOrder != null && columnOrder.length)) {\n        orderedColumns = columns;\n      } else {\n        const columnOrderCopy = [...columnOrder];\n\n        // If there is an order, make a copy of the columns\n        const columnsCopy = [...columns];\n\n        // And make a new ordered array of the columns\n\n        // Loop over the columns and place them in order into the new array\n        while (columnsCopy.length && columnOrderCopy.length) {\n          const targetColumnId = columnOrderCopy.shift();\n          const foundIndex = columnsCopy.findIndex(d => d.id === targetColumnId);\n          if (foundIndex > -1) {\n            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n          }\n        }\n\n        // If there are any columns left, add them to the end\n        orderedColumns = [...orderedColumns, ...columnsCopy];\n      }\n      return orderColumns(orderedColumns, grouping, groupedColumnMode);\n    }, getMemoOptions(table.options, 'debugTable', '_getOrderColumnsFn'));\n  }\n};\n\n//\n\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\nconst getDefaultPaginationState = () => ({\n  pageIndex: defaultPageIndex,\n  pageSize: defaultPageSize\n});\nconst Pagination = {\n  getInitialState: state => {\n    return {\n      ...state,\n      pagination: {\n        ...getDefaultPaginationState(),\n        ...(state == null ? void 0 : state.pagination)\n      }\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onPaginationChange: makeStateUpdater('pagination', table)\n    };\n  },\n  createTable: table => {\n    let registered = false;\n    let queued = false;\n    table._autoResetPageIndex = () => {\n      var _ref, _table$options$autoRe;\n      if (!registered) {\n        table._queue(() => {\n          registered = true;\n        });\n        return;\n      }\n      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\n        if (queued) return;\n        queued = true;\n        table._queue(() => {\n          table.resetPageIndex();\n          queued = false;\n        });\n      }\n    };\n    table.setPagination = updater => {\n      const safeUpdater = old => {\n        let newState = functionalUpdate(updater, old);\n        return newState;\n      };\n      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\n    };\n    table.resetPagination = defaultState => {\n      var _table$initialState$p;\n      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\n    };\n    table.setPageIndex = updater => {\n      table.setPagination(old => {\n        let pageIndex = functionalUpdate(updater, old.pageIndex);\n        const maxPageIndex = typeof table.options.pageCount === 'undefined' || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\n        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\n        return {\n          ...old,\n          pageIndex\n        };\n      });\n    };\n    table.resetPageIndex = defaultState => {\n      var _table$initialState$p2, _table$initialState;\n      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\n    };\n    table.resetPageSize = defaultState => {\n      var _table$initialState$p3, _table$initialState2;\n      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\n    };\n    table.setPageSize = updater => {\n      table.setPagination(old => {\n        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n        const topRowIndex = old.pageSize * old.pageIndex;\n        const pageIndex = Math.floor(topRowIndex / pageSize);\n        return {\n          ...old,\n          pageIndex,\n          pageSize\n        };\n      });\n    };\n    //deprecated\n    table.setPageCount = updater => table.setPagination(old => {\n      var _table$options$pageCo;\n      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\n      if (typeof newPageCount === 'number') {\n        newPageCount = Math.max(-1, newPageCount);\n      }\n      return {\n        ...old,\n        pageCount: newPageCount\n      };\n    });\n    table.getPageOptions = memo(() => [table.getPageCount()], pageCount => {\n      let pageOptions = [];\n      if (pageCount && pageCount > 0) {\n        pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);\n      }\n      return pageOptions;\n    }, getMemoOptions(table.options, 'debugTable', 'getPageOptions'));\n    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;\n    table.getCanNextPage = () => {\n      const {\n        pageIndex\n      } = table.getState().pagination;\n      const pageCount = table.getPageCount();\n      if (pageCount === -1) {\n        return true;\n      }\n      if (pageCount === 0) {\n        return false;\n      }\n      return pageIndex < pageCount - 1;\n    };\n    table.previousPage = () => {\n      return table.setPageIndex(old => old - 1);\n    };\n    table.nextPage = () => {\n      return table.setPageIndex(old => {\n        return old + 1;\n      });\n    };\n    table.firstPage = () => {\n      return table.setPageIndex(0);\n    };\n    table.lastPage = () => {\n      return table.setPageIndex(table.getPageCount() - 1);\n    };\n    table.getPrePaginationRowModel = () => table.getExpandedRowModel();\n    table.getPaginationRowModel = () => {\n      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\n        table._getPaginationRowModel = table.options.getPaginationRowModel(table);\n      }\n      if (table.options.manualPagination || !table._getPaginationRowModel) {\n        return table.getPrePaginationRowModel();\n      }\n      return table._getPaginationRowModel();\n    };\n    table.getPageCount = () => {\n      var _table$options$pageCo2;\n      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);\n    };\n    table.getRowCount = () => {\n      var _table$options$rowCou;\n      return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;\n    };\n  }\n};\n\n//\n\nconst getDefaultColumnPinningState = () => ({\n  left: [],\n  right: []\n});\nconst getDefaultRowPinningState = () => ({\n  top: [],\n  bottom: []\n});\nconst Pinning = {\n  getInitialState: state => {\n    return {\n      columnPinning: getDefaultColumnPinningState(),\n      rowPinning: getDefaultRowPinningState(),\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onColumnPinningChange: makeStateUpdater('columnPinning', table),\n      onRowPinningChange: makeStateUpdater('rowPinning', table)\n    };\n  },\n  createColumn: (column, table) => {\n    column.pin = position => {\n      const columnIds = column.getLeafColumns().map(d => d.id).filter(Boolean);\n      table.setColumnPinning(old => {\n        var _old$left3, _old$right3;\n        if (position === 'right') {\n          var _old$left, _old$right;\n          return {\n            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter(d => !(columnIds != null && columnIds.includes(d))),\n            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds]\n          };\n        }\n        if (position === 'left') {\n          var _old$left2, _old$right2;\n          return {\n            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds],\n            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\n          };\n        }\n        return {\n          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter(d => !(columnIds != null && columnIds.includes(d))),\n          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\n        };\n      });\n    };\n    column.getCanPin = () => {\n      const leafColumns = column.getLeafColumns();\n      return leafColumns.some(d => {\n        var _d$columnDef$enablePi, _ref, _table$options$enable;\n        return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\n      });\n    };\n    column.getIsPinned = () => {\n      const leafColumnIds = column.getLeafColumns().map(d => d.id);\n      const {\n        left,\n        right\n      } = table.getState().columnPinning;\n      const isLeft = leafColumnIds.some(d => left == null ? void 0 : left.includes(d));\n      const isRight = leafColumnIds.some(d => right == null ? void 0 : right.includes(d));\n      return isLeft ? 'left' : isRight ? 'right' : false;\n    };\n    column.getPinnedIndex = () => {\n      var _table$getState$colum, _table$getState$colum2;\n      const position = column.getIsPinned();\n      return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\n    };\n  },\n  createRow: (row, table) => {\n    row.pin = (position, includeLeafRows, includeParentRows) => {\n      const leafRowIds = includeLeafRows ? row.getLeafRows().map(_ref2 => {\n        let {\n          id\n        } = _ref2;\n        return id;\n      }) : [];\n      const parentRowIds = includeParentRows ? row.getParentRows().map(_ref3 => {\n        let {\n          id\n        } = _ref3;\n        return id;\n      }) : [];\n      const rowIds = new Set([...parentRowIds, row.id, ...leafRowIds]);\n      table.setRowPinning(old => {\n        var _old$top3, _old$bottom3;\n        if (position === 'bottom') {\n          var _old$top, _old$bottom;\n          return {\n            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter(d => !(rowIds != null && rowIds.has(d))),\n            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter(d => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)]\n          };\n        }\n        if (position === 'top') {\n          var _old$top2, _old$bottom2;\n          return {\n            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter(d => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)],\n            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter(d => !(rowIds != null && rowIds.has(d)))\n          };\n        }\n        return {\n          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter(d => !(rowIds != null && rowIds.has(d))),\n          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter(d => !(rowIds != null && rowIds.has(d)))\n        };\n      });\n    };\n    row.getCanPin = () => {\n      var _ref4;\n      const {\n        enableRowPinning,\n        enablePinning\n      } = table.options;\n      if (typeof enableRowPinning === 'function') {\n        return enableRowPinning(row);\n      }\n      return (_ref4 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref4 : true;\n    };\n    row.getIsPinned = () => {\n      const rowIds = [row.id];\n      const {\n        top,\n        bottom\n      } = table.getState().rowPinning;\n      const isTop = rowIds.some(d => top == null ? void 0 : top.includes(d));\n      const isBottom = rowIds.some(d => bottom == null ? void 0 : bottom.includes(d));\n      return isTop ? 'top' : isBottom ? 'bottom' : false;\n    };\n    row.getPinnedIndex = () => {\n      var _table$_getPinnedRows, _visiblePinnedRowIds$;\n      const position = row.getIsPinned();\n      if (!position) return -1;\n      const visiblePinnedRowIds = (_table$_getPinnedRows = table._getPinnedRows(position)) == null ? void 0 : _table$_getPinnedRows.map(_ref5 => {\n        let {\n          id\n        } = _ref5;\n        return id;\n      });\n      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\n    };\n    row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {\n      const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\n      return allCells.filter(d => !leftAndRight.includes(d.column.id));\n    }, getMemoOptions(table.options, 'debugRows', 'getCenterVisibleCells'));\n    row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left) => {\n      const cells = (left != null ? left : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({\n        ...d,\n        position: 'left'\n      }));\n      return cells;\n    }, getMemoOptions(table.options, 'debugRows', 'getLeftVisibleCells'));\n    row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {\n      const cells = (right != null ? right : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({\n        ...d,\n        position: 'right'\n      }));\n      return cells;\n    }, getMemoOptions(table.options, 'debugRows', 'getRightVisibleCells'));\n  },\n  createTable: table => {\n    table.setColumnPinning = updater => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\n    table.resetColumnPinning = defaultState => {\n      var _table$initialState$c, _table$initialState;\n      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\n    };\n    table.getIsSomeColumnsPinned = position => {\n      var _pinningState$positio;\n      const pinningState = table.getState().columnPinning;\n      if (!position) {\n        var _pinningState$left, _pinningState$right;\n        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n      }\n      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n    };\n    table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {\n      return (left != null ? left : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\n    }, getMemoOptions(table.options, 'debugColumns', 'getLeftLeafColumns'));\n    table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {\n      return (right != null ? right : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\n    }, getMemoOptions(table.options, 'debugColumns', 'getRightLeafColumns'));\n    table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {\n      const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\n      return allColumns.filter(d => !leftAndRight.includes(d.id));\n    }, getMemoOptions(table.options, 'debugColumns', 'getCenterLeafColumns'));\n    table.setRowPinning = updater => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\n    table.resetRowPinning = defaultState => {\n      var _table$initialState$r, _table$initialState2;\n      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState2 = table.initialState) == null ? void 0 : _table$initialState2.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\n    };\n    table.getIsSomeRowsPinned = position => {\n      var _pinningState$positio2;\n      const pinningState = table.getState().rowPinning;\n      if (!position) {\n        var _pinningState$top, _pinningState$bottom;\n        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\n      }\n      return Boolean((_pinningState$positio2 = pinningState[position]) == null ? void 0 : _pinningState$positio2.length);\n    };\n    table._getPinnedRows = memo(position => [table.getRowModel().rows, table.getState().rowPinning[position], position], (visibleRows, pinnedRowIds, position) => {\n      var _table$options$keepPi;\n      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ?\n      //get all rows that are pinned even if they would not be otherwise visible\n      //account for expanded parent rows, but not pagination or filtering\n      (pinnedRowIds != null ? pinnedRowIds : []).map(rowId => {\n        const row = table.getRow(rowId, true);\n        return row.getIsAllParentsExpanded() ? row : null;\n      }) :\n      //else get only visible rows that are pinned\n      (pinnedRowIds != null ? pinnedRowIds : []).map(rowId => visibleRows.find(row => row.id === rowId));\n      return rows.filter(Boolean).map(d => ({\n        ...d,\n        position\n      }));\n    }, getMemoOptions(table.options, 'debugRows', '_getPinnedRows'));\n    table.getTopRows = () => table._getPinnedRows('top');\n    table.getBottomRows = () => table._getPinnedRows('bottom');\n    table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {\n      const topAndBottom = new Set([...(top != null ? top : []), ...(bottom != null ? bottom : [])]);\n      return allRows.filter(d => !topAndBottom.has(d.id));\n    }, getMemoOptions(table.options, 'debugRows', 'getCenterRows'));\n  }\n};\n\n//\n\nconst RowSelection = {\n  getInitialState: state => {\n    return {\n      rowSelection: {},\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onRowSelectionChange: makeStateUpdater('rowSelection', table),\n      enableRowSelection: true,\n      enableMultiRowSelection: true,\n      enableSubRowSelection: true\n      // enableGroupingRowSelection: false,\n      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,\n      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,\n    };\n  },\n  createTable: table => {\n    table.setRowSelection = updater => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\n    table.resetRowSelection = defaultState => {\n      var _table$initialState$r;\n      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\n    };\n    table.toggleAllRowsSelected = value => {\n      table.setRowSelection(old => {\n        value = typeof value !== 'undefined' ? value : !table.getIsAllRowsSelected();\n        const rowSelection = {\n          ...old\n        };\n        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\n\n        // We don't use `mutateRowIsSelected` here for performance reasons.\n        // All of the rows are flat already, so it wouldn't be worth it\n        if (value) {\n          preGroupedFlatRows.forEach(row => {\n            if (!row.getCanSelect()) {\n              return;\n            }\n            rowSelection[row.id] = true;\n          });\n        } else {\n          preGroupedFlatRows.forEach(row => {\n            delete rowSelection[row.id];\n          });\n        }\n        return rowSelection;\n      });\n    };\n    table.toggleAllPageRowsSelected = value => table.setRowSelection(old => {\n      const resolvedValue = typeof value !== 'undefined' ? value : !table.getIsAllPageRowsSelected();\n      const rowSelection = {\n        ...old\n      };\n      table.getRowModel().rows.forEach(row => {\n        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\n      });\n      return rowSelection;\n    });\n\n    // addRowSelectionRange: rowId => {\n    //   const {\n    //     rows,\n    //     rowsById,\n    //     options: { selectGroupingRows, selectSubRows },\n    //   } = table\n\n    //   const findSelectedRow = (rows: Row[]) => {\n    //     let found\n    //     rows.find(d => {\n    //       if (d.getIsSelected()) {\n    //         found = d\n    //         return true\n    //       }\n    //       const subFound = findSelectedRow(d.subRows || [])\n    //       if (subFound) {\n    //         found = subFound\n    //         return true\n    //       }\n    //       return false\n    //     })\n    //     return found\n    //   }\n\n    //   const firstRow = findSelectedRow(rows) || rows[0]\n    //   const lastRow = rowsById[rowId]\n\n    //   let include = false\n    //   const selectedRowIds = {}\n\n    //   const addRow = (row: Row) => {\n    //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n    //       rowsById,\n    //       selectGroupingRows: selectGroupingRows!,\n    //       selectSubRows: selectSubRows!,\n    //     })\n    //   }\n\n    //   table.rows.forEach(row => {\n    //     const isFirstRow = row.id === firstRow.id\n    //     const isLastRow = row.id === lastRow.id\n\n    //     if (isFirstRow || isLastRow) {\n    //       if (!include) {\n    //         include = true\n    //       } else if (include) {\n    //         addRow(row)\n    //         include = false\n    //       }\n    //     }\n\n    //     if (include) {\n    //       addRow(row)\n    //     }\n    //   })\n\n    //   table.setRowSelection(selectedRowIds)\n    // },\n    table.getPreSelectedRowModel = () => table.getCoreRowModel();\n    table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {\n      if (!Object.keys(rowSelection).length) {\n        return {\n          rows: [],\n          flatRows: [],\n          rowsById: {}\n        };\n      }\n      return selectRowsFn(table, rowModel);\n    }, getMemoOptions(table.options, 'debugTable', 'getSelectedRowModel'));\n    table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {\n      if (!Object.keys(rowSelection).length) {\n        return {\n          rows: [],\n          flatRows: [],\n          rowsById: {}\n        };\n      }\n      return selectRowsFn(table, rowModel);\n    }, getMemoOptions(table.options, 'debugTable', 'getFilteredSelectedRowModel'));\n    table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {\n      if (!Object.keys(rowSelection).length) {\n        return {\n          rows: [],\n          flatRows: [],\n          rowsById: {}\n        };\n      }\n      return selectRowsFn(table, rowModel);\n    }, getMemoOptions(table.options, 'debugTable', 'getGroupedSelectedRowModel'));\n\n    ///\n\n    // getGroupingRowCanSelect: rowId => {\n    //   const row = table.getRow(rowId)\n\n    //   if (!row) {\n    //     throw new Error()\n    //   }\n\n    //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n    //     return table.options.enableGroupingRowSelection(row)\n    //   }\n\n    //   return table.options.enableGroupingRowSelection ?? false\n    // },\n\n    table.getIsAllRowsSelected = () => {\n      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\n      const {\n        rowSelection\n      } = table.getState();\n      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\n      if (isAllRowsSelected) {\n        if (preGroupedFlatRows.some(row => row.getCanSelect() && !rowSelection[row.id])) {\n          isAllRowsSelected = false;\n        }\n      }\n      return isAllRowsSelected;\n    };\n    table.getIsAllPageRowsSelected = () => {\n      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter(row => row.getCanSelect());\n      const {\n        rowSelection\n      } = table.getState();\n      let isAllPageRowsSelected = !!paginationFlatRows.length;\n      if (isAllPageRowsSelected && paginationFlatRows.some(row => !rowSelection[row.id])) {\n        isAllPageRowsSelected = false;\n      }\n      return isAllPageRowsSelected;\n    };\n    table.getIsSomeRowsSelected = () => {\n      var _table$getState$rowSe;\n      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\n      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\n    };\n    table.getIsSomePageRowsSelected = () => {\n      const paginationFlatRows = table.getPaginationRowModel().flatRows;\n      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter(row => row.getCanSelect()).some(d => d.getIsSelected() || d.getIsSomeSelected());\n    };\n    table.getToggleAllRowsSelectedHandler = () => {\n      return e => {\n        table.toggleAllRowsSelected(e.target.checked);\n      };\n    };\n    table.getToggleAllPageRowsSelectedHandler = () => {\n      return e => {\n        table.toggleAllPageRowsSelected(e.target.checked);\n      };\n    };\n  },\n  createRow: (row, table) => {\n    row.toggleSelected = (value, opts) => {\n      const isSelected = row.getIsSelected();\n      table.setRowSelection(old => {\n        var _opts$selectChildren;\n        value = typeof value !== 'undefined' ? value : !isSelected;\n        if (row.getCanSelect() && isSelected === value) {\n          return old;\n        }\n        const selectedRowIds = {\n          ...old\n        };\n        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\n        return selectedRowIds;\n      });\n    };\n    row.getIsSelected = () => {\n      const {\n        rowSelection\n      } = table.getState();\n      return isRowSelected(row, rowSelection);\n    };\n    row.getIsSomeSelected = () => {\n      const {\n        rowSelection\n      } = table.getState();\n      return isSubRowSelected(row, rowSelection) === 'some';\n    };\n    row.getIsAllSubRowsSelected = () => {\n      const {\n        rowSelection\n      } = table.getState();\n      return isSubRowSelected(row, rowSelection) === 'all';\n    };\n    row.getCanSelect = () => {\n      var _table$options$enable;\n      if (typeof table.options.enableRowSelection === 'function') {\n        return table.options.enableRowSelection(row);\n      }\n      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\n    };\n    row.getCanSelectSubRows = () => {\n      var _table$options$enable2;\n      if (typeof table.options.enableSubRowSelection === 'function') {\n        return table.options.enableSubRowSelection(row);\n      }\n      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\n    };\n    row.getCanMultiSelect = () => {\n      var _table$options$enable3;\n      if (typeof table.options.enableMultiRowSelection === 'function') {\n        return table.options.enableMultiRowSelection(row);\n      }\n      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\n    };\n    row.getToggleSelectedHandler = () => {\n      const canSelect = row.getCanSelect();\n      return e => {\n        var _target;\n        if (!canSelect) return;\n        row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n      };\n    };\n  }\n};\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table) => {\n  var _row$subRows;\n  const row = table.getRow(id, true);\n\n  // const isGrouped = row.getIsGrouped()\n\n  // if ( // TODO: enforce grouping row selection rules\n  //   !isGrouped ||\n  //   (isGrouped && table.options.enableGroupingRowSelection)\n  // ) {\n  if (value) {\n    if (!row.getCanMultiSelect()) {\n      Object.keys(selectedRowIds).forEach(key => delete selectedRowIds[key]);\n    }\n    if (row.getCanSelect()) {\n      selectedRowIds[id] = true;\n    }\n  } else {\n    delete selectedRowIds[id];\n  }\n  // }\n\n  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n    row.subRows.forEach(row => mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\n  }\n};\nfunction selectRowsFn(table, rowModel) {\n  const rowSelection = table.getState().rowSelection;\n  const newSelectedFlatRows = [];\n  const newSelectedRowsById = {};\n\n  // Filters top level and nested rows\n  const recurseRows = function (rows, depth) {\n    return rows.map(row => {\n      var _row$subRows2;\n      const isSelected = isRowSelected(row, rowSelection);\n      if (isSelected) {\n        newSelectedFlatRows.push(row);\n        newSelectedRowsById[row.id] = row;\n      }\n      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n        row = {\n          ...row,\n          subRows: recurseRows(row.subRows)\n        };\n      }\n      if (isSelected) {\n        return row;\n      }\n    }).filter(Boolean);\n  };\n  return {\n    rows: recurseRows(rowModel.rows),\n    flatRows: newSelectedFlatRows,\n    rowsById: newSelectedRowsById\n  };\n}\nfunction isRowSelected(row, selection) {\n  var _selection$row$id;\n  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\n}\nfunction isSubRowSelected(row, selection, table) {\n  var _row$subRows3;\n  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\n  let allChildrenSelected = true;\n  let someSelected = false;\n  row.subRows.forEach(subRow => {\n    // Bail out early if we know both of these\n    if (someSelected && !allChildrenSelected) {\n      return;\n    }\n    if (subRow.getCanSelect()) {\n      if (isRowSelected(subRow, selection)) {\n        someSelected = true;\n      } else {\n        allChildrenSelected = false;\n      }\n    }\n\n    // Check row selection of nested subrows\n    if (subRow.subRows && subRow.subRows.length) {\n      const subRowChildrenSelected = isSubRowSelected(subRow, selection);\n      if (subRowChildrenSelected === 'all') {\n        someSelected = true;\n      } else if (subRowChildrenSelected === 'some') {\n        someSelected = true;\n        allChildrenSelected = false;\n      } else {\n        allChildrenSelected = false;\n      }\n    }\n  });\n  return allChildrenSelected ? 'all' : someSelected ? 'some' : false;\n}\n\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst alphanumeric = (rowA, rowB, columnId) => {\n  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\nconst alphanumericCaseSensitive = (rowA, rowB, columnId) => {\n  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text = (rowA, rowB, columnId) => {\n  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive = (rowA, rowB, columnId) => {\n  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\nconst datetime = (rowA, rowB, columnId) => {\n  const a = rowA.getValue(columnId);\n  const b = rowB.getValue(columnId);\n\n  // Can handle nullish values\n  // Use > and < because == (and ===) doesn't work with\n  // Date objects (would require calling getTime()).\n  return a > b ? 1 : a < b ? -1 : 0;\n};\nconst basic = (rowA, rowB, columnId) => {\n  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n};\n\n// Utils\n\nfunction compareBasic(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction toString(a) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return '';\n    }\n    return String(a);\n  }\n  if (typeof a === 'string') {\n    return a;\n  }\n  return '';\n}\n\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr, bStr) {\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\n\n  // While\n  while (a.length && b.length) {\n    const aa = a.shift();\n    const bb = b.shift();\n    const an = parseInt(aa, 10);\n    const bn = parseInt(bb, 10);\n    const combo = [an, bn].sort();\n\n    // Both are string\n    if (isNaN(combo[0])) {\n      if (aa > bb) {\n        return 1;\n      }\n      if (bb > aa) {\n        return -1;\n      }\n      continue;\n    }\n\n    // One is a string, one is a number\n    if (isNaN(combo[1])) {\n      return isNaN(an) ? -1 : 1;\n    }\n\n    // Both are numbers\n    if (an > bn) {\n      return 1;\n    }\n    if (bn > an) {\n      return -1;\n    }\n  }\n  return a.length - b.length;\n}\n\n// Exports\n\nconst sortingFns = {\n  alphanumeric,\n  alphanumericCaseSensitive,\n  text,\n  textCaseSensitive,\n  datetime,\n  basic\n};\n\n//\n\nconst Sorting = {\n  getInitialState: state => {\n    return {\n      sorting: [],\n      ...state\n    };\n  },\n  getDefaultColumnDef: () => {\n    return {\n      sortingFn: 'auto',\n      sortUndefined: 1\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onSortingChange: makeStateUpdater('sorting', table),\n      isMultiSortEvent: e => {\n        return e.shiftKey;\n      }\n    };\n  },\n  createColumn: (column, table) => {\n    column.getAutoSortingFn = () => {\n      const firstRows = table.getFilteredRowModel().flatRows.slice(10);\n      let isString = false;\n      for (const row of firstRows) {\n        const value = row == null ? void 0 : row.getValue(column.id);\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return sortingFns.datetime;\n        }\n        if (typeof value === 'string') {\n          isString = true;\n          if (value.split(reSplitAlphaNumeric).length > 1) {\n            return sortingFns.alphanumeric;\n          }\n        }\n      }\n      if (isString) {\n        return sortingFns.text;\n      }\n      return sortingFns.basic;\n    };\n    column.getAutoSortDir = () => {\n      const firstRow = table.getFilteredRowModel().flatRows[0];\n      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n      if (typeof value === 'string') {\n        return 'asc';\n      }\n      return 'desc';\n    };\n    column.getSortingFn = () => {\n      var _table$options$sortin, _table$options$sortin2;\n      if (!column) {\n        throw new Error();\n      }\n      return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === 'auto' ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\n    };\n    column.toggleSorting = (desc, multi) => {\n      // if (column.columns.length) {\n      //   column.columns.forEach((c, i) => {\n      //     if (c.id) {\n      //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n      //     }\n      //   })\n      //   return\n      // }\n\n      // this needs to be outside of table.setSorting to be in sync with rerender\n      const nextSortingOrder = column.getNextSortingOrder();\n      const hasManualValue = typeof desc !== 'undefined' && desc !== null;\n      table.setSorting(old => {\n        // Find any existing sorting for this column\n        const existingSorting = old == null ? void 0 : old.find(d => d.id === column.id);\n        const existingIndex = old == null ? void 0 : old.findIndex(d => d.id === column.id);\n        let newSorting = [];\n\n        // What should we do with this sort action?\n        let sortAction;\n        let nextDesc = hasManualValue ? desc : nextSortingOrder === 'desc';\n\n        // Multi-mode\n        if (old != null && old.length && column.getCanMultiSort() && multi) {\n          if (existingSorting) {\n            sortAction = 'toggle';\n          } else {\n            sortAction = 'add';\n          }\n        } else {\n          // Normal mode\n          if (old != null && old.length && existingIndex !== old.length - 1) {\n            sortAction = 'replace';\n          } else if (existingSorting) {\n            sortAction = 'toggle';\n          } else {\n            sortAction = 'replace';\n          }\n        }\n\n        // Handle toggle states that will remove the sorting\n        if (sortAction === 'toggle') {\n          // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n          if (!hasManualValue) {\n            // Is our intention to remove?\n            if (!nextSortingOrder) {\n              sortAction = 'remove';\n            }\n          }\n        }\n        if (sortAction === 'add') {\n          var _table$options$maxMul;\n          newSorting = [...old, {\n            id: column.id,\n            desc: nextDesc\n          }];\n          // Take latest n columns\n          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\n        } else if (sortAction === 'toggle') {\n          // This flips (or sets) the\n          newSorting = old.map(d => {\n            if (d.id === column.id) {\n              return {\n                ...d,\n                desc: nextDesc\n              };\n            }\n            return d;\n          });\n        } else if (sortAction === 'remove') {\n          newSorting = old.filter(d => d.id !== column.id);\n        } else {\n          newSorting = [{\n            id: column.id,\n            desc: nextDesc\n          }];\n        }\n        return newSorting;\n      });\n    };\n    column.getFirstSortDir = () => {\n      var _ref, _column$columnDef$sor;\n      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === 'desc';\n      return sortDescFirst ? 'desc' : 'asc';\n    };\n    column.getNextSortingOrder = multi => {\n      var _table$options$enable, _table$options$enable2;\n      const firstSortDirection = column.getFirstSortDir();\n      const isSorted = column.getIsSorted();\n      if (!isSorted) {\n        return firstSortDirection;\n      }\n      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && (\n      // If enableSortRemove, enable in general\n      multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true) // If multi, don't allow if enableMultiRemove))\n      ) {\n        return false;\n      }\n      return isSorted === 'desc' ? 'asc' : 'desc';\n    };\n    column.getCanSort = () => {\n      var _column$columnDef$ena, _table$options$enable3;\n      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\n    };\n    column.getCanMultiSort = () => {\n      var _ref2, _column$columnDef$ena2;\n      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\n    };\n    column.getIsSorted = () => {\n      var _table$getState$sorti;\n      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find(d => d.id === column.id);\n      return !columnSort ? false : columnSort.desc ? 'desc' : 'asc';\n    };\n    column.getSortIndex = () => {\n      var _table$getState$sorti2, _table$getState$sorti3;\n      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex(d => d.id === column.id)) != null ? _table$getState$sorti2 : -1;\n    };\n    column.clearSorting = () => {\n      //clear sorting for just 1 column\n      table.setSorting(old => old != null && old.length ? old.filter(d => d.id !== column.id) : []);\n    };\n    column.getToggleSortingHandler = () => {\n      const canSort = column.getCanSort();\n      return e => {\n        if (!canSort) return;\n        e.persist == null || e.persist();\n        column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\n      };\n    };\n  },\n  createTable: table => {\n    table.setSorting = updater => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\n    table.resetSorting = defaultState => {\n      var _table$initialState$s, _table$initialState;\n      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\n    };\n    table.getPreSortedRowModel = () => table.getGroupedRowModel();\n    table.getSortedRowModel = () => {\n      if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n        table._getSortedRowModel = table.options.getSortedRowModel(table);\n      }\n      if (table.options.manualSorting || !table._getSortedRowModel) {\n        return table.getPreSortedRowModel();\n      }\n      return table._getSortedRowModel();\n    };\n  }\n};\n\n//\n\nconst Visibility = {\n  getInitialState: state => {\n    return {\n      columnVisibility: {},\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onColumnVisibilityChange: makeStateUpdater('columnVisibility', table)\n    };\n  },\n  createColumn: (column, table) => {\n    column.toggleVisibility = value => {\n      if (column.getCanHide()) {\n        table.setColumnVisibility(old => ({\n          ...old,\n          [column.id]: value != null ? value : !column.getIsVisible()\n        }));\n      }\n    };\n    column.getIsVisible = () => {\n      var _ref, _table$getState$colum;\n      const childColumns = column.columns;\n      return (_ref = childColumns.length ? childColumns.some(c => c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;\n    };\n    column.getCanHide = () => {\n      var _column$columnDef$ena, _table$options$enable;\n      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\n    };\n    column.getToggleVisibilityHandler = () => {\n      return e => {\n        column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\n      };\n    };\n  },\n  createRow: (row, table) => {\n    row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], cells => {\n      return cells.filter(cell => cell.column.getIsVisible());\n    }, getMemoOptions(table.options, 'debugRows', '_getAllVisibleCells'));\n    row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], getMemoOptions(table.options, 'debugRows', 'getVisibleCells'));\n  },\n  createTable: table => {\n    const makeVisibleColumnsMethod = (key, getColumns) => {\n      return memo(() => [getColumns(), getColumns().filter(d => d.getIsVisible()).map(d => d.id).join('_')], columns => {\n        return columns.filter(d => d.getIsVisible == null ? void 0 : d.getIsVisible());\n      }, getMemoOptions(table.options, 'debugColumns', key));\n    };\n    table.getVisibleFlatColumns = makeVisibleColumnsMethod('getVisibleFlatColumns', () => table.getAllFlatColumns());\n    table.getVisibleLeafColumns = makeVisibleColumnsMethod('getVisibleLeafColumns', () => table.getAllLeafColumns());\n    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod('getLeftVisibleLeafColumns', () => table.getLeftLeafColumns());\n    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod('getRightVisibleLeafColumns', () => table.getRightLeafColumns());\n    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod('getCenterVisibleLeafColumns', () => table.getCenterLeafColumns());\n    table.setColumnVisibility = updater => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\n    table.resetColumnVisibility = defaultState => {\n      var _table$initialState$c;\n      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\n    };\n    table.toggleAllColumnsVisible = value => {\n      var _value;\n      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\n      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({\n        ...obj,\n        [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n      }), {}));\n    };\n    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some(column => !(column.getIsVisible != null && column.getIsVisible()));\n    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some(column => column.getIsVisible == null ? void 0 : column.getIsVisible());\n    table.getToggleAllColumnsVisibilityHandler = () => {\n      return e => {\n        var _target;\n        table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n      };\n    };\n  }\n};\nfunction _getVisibleLeafColumns(table, position) {\n  return !position ? table.getVisibleLeafColumns() : position === 'center' ? table.getCenterVisibleLeafColumns() : position === 'left' ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\n}\n\nconst features = [Headers, Visibility, Ordering, Pinning, Filters, Sorting, Grouping, Expanding, Pagination, RowSelection, ColumnSizing];\n\n//\n\nfunction createTable(options) {\n  var _options$initialState;\n  if (options.debugAll || options.debugTable) {\n    console.info('Creating Table Instance...');\n  }\n  let table = {\n    _features: features\n  };\n  const defaultOptions = table._features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\n  }, {});\n  const mergeOptions = options => {\n    if (table.options.mergeOptions) {\n      return table.options.mergeOptions(defaultOptions, options);\n    }\n    return {\n      ...defaultOptions,\n      ...options\n    };\n  };\n  const coreInitialState = {};\n  let initialState = {\n    ...coreInitialState,\n    ...((_options$initialState = options.initialState) != null ? _options$initialState : {})\n  };\n  table._features.forEach(feature => {\n    var _feature$getInitialSt;\n    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n  });\n  const queued = [];\n  let queuedTimeout = false;\n  const coreInstance = {\n    _features: features,\n    options: {\n      ...defaultOptions,\n      ...options\n    },\n    initialState,\n    _queue: cb => {\n      queued.push(cb);\n      if (!queuedTimeout) {\n        queuedTimeout = true;\n\n        // Schedule a microtask to run the queued callbacks after\n        // the current call stack (render, etc) has finished.\n        Promise.resolve().then(() => {\n          while (queued.length) {\n            queued.shift()();\n          }\n          queuedTimeout = false;\n        }).catch(error => setTimeout(() => {\n          throw error;\n        }));\n      }\n    },\n    reset: () => {\n      table.setState(table.initialState);\n    },\n    setOptions: updater => {\n      const newOptions = functionalUpdate(updater, table.options);\n      table.options = mergeOptions(newOptions);\n    },\n    getState: () => {\n      return table.options.state;\n    },\n    setState: updater => {\n      table.options.onStateChange == null || table.options.onStateChange(updater);\n    },\n    _getRowId: (row, index, parent) => {\n      var _table$options$getRow;\n      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index].join('.') : index}`;\n    },\n    getCoreRowModel: () => {\n      if (!table._getCoreRowModel) {\n        table._getCoreRowModel = table.options.getCoreRowModel(table);\n      }\n      return table._getCoreRowModel();\n    },\n    // The final calls start at the bottom of the model,\n    // expanded rows, which then work their way up\n\n    getRowModel: () => {\n      return table.getPaginationRowModel();\n    },\n    //in next version, we should just pass in the row model as the optional 2nd arg\n    getRow: (id, searchAll) => {\n      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];\n      if (!row) {\n        row = table.getCoreRowModel().rowsById[id];\n        if (!row) {\n          if (true) {\n            throw new Error(`getRow could not find row with ID: ${id}`);\n          }\n          throw new Error();\n        }\n      }\n      return row;\n    },\n    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], defaultColumn => {\n      var _defaultColumn;\n      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n      return {\n        header: props => {\n          const resolvedColumnDef = props.header.column.columnDef;\n          if (resolvedColumnDef.accessorKey) {\n            return resolvedColumnDef.accessorKey;\n          }\n          if (resolvedColumnDef.accessorFn) {\n            return resolvedColumnDef.id;\n          }\n          return null;\n        },\n        // footer: props => props.header.column.id,\n        cell: props => {\n          var _props$renderValue$to, _props$renderValue;\n          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\n        },\n        ...table._features.reduce((obj, feature) => {\n          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n        }, {}),\n        ...defaultColumn\n      };\n    }, getMemoOptions(options, 'debugColumns', '_getDefaultColumnDef')),\n    _getColumnDefs: () => table.options.columns,\n    getAllColumns: memo(() => [table._getColumnDefs()], columnDefs => {\n      const recurseColumns = function (columnDefs, parent, depth) {\n        if (depth === void 0) {\n          depth = 0;\n        }\n        return columnDefs.map(columnDef => {\n          const column = createColumn(table, columnDef, depth, parent);\n          const groupingColumnDef = columnDef;\n          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\n          return column;\n        });\n      };\n      return recurseColumns(columnDefs);\n    }, getMemoOptions(options, 'debugColumns', 'getAllColumns')),\n    getAllFlatColumns: memo(() => [table.getAllColumns()], allColumns => {\n      return allColumns.flatMap(column => {\n        return column.getFlatColumns();\n      });\n    }, getMemoOptions(options, 'debugColumns', 'getAllFlatColumns')),\n    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], flatColumns => {\n      return flatColumns.reduce((acc, column) => {\n        acc[column.id] = column;\n        return acc;\n      }, {});\n    }, getMemoOptions(options, 'debugColumns', 'getAllFlatColumnsById')),\n    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns) => {\n      let leafColumns = allColumns.flatMap(column => column.getLeafColumns());\n      return orderColumns(leafColumns);\n    }, getMemoOptions(options, 'debugColumns', 'getAllLeafColumns')),\n    getColumn: columnId => {\n      const column = table._getAllFlatColumnsById()[columnId];\n      if ( true && !column) {\n        console.error(`[Table] Column with id '${columnId}' does not exist.`);\n      }\n      return column;\n    }\n  };\n  Object.assign(table, coreInstance);\n  for (let index = 0; index < table._features.length; index++) {\n    const feature = table._features[index];\n    feature == null || feature.createTable == null || feature.createTable(table);\n  }\n  return table;\n}\n\nfunction createCell(table, row, column, columnId) {\n  const getRenderValue = () => {\n    var _cell$getValue;\n    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\n  };\n  const cell = {\n    id: `${row.id}_${column.id}`,\n    row,\n    column,\n    getValue: () => row.getValue(columnId),\n    renderValue: getRenderValue,\n    getContext: memo(() => [table, column, row, cell], (table, column, row, cell) => ({\n      table,\n      column,\n      row,\n      cell: cell,\n      getValue: cell.getValue,\n      renderValue: cell.renderValue\n    }), getMemoOptions(table.options, 'debugCells', 'cell.getContext'))\n  };\n  table._features.forEach(feature => {\n    feature.createCell == null || feature.createCell(cell, column, row, table);\n  }, {});\n  return cell;\n}\n\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {\n  let row = {\n    id,\n    index: rowIndex,\n    original,\n    depth,\n    parentId,\n    _valuesCache: {},\n    _uniqueValuesCache: {},\n    getValue: columnId => {\n      if (row._valuesCache.hasOwnProperty(columnId)) {\n        return row._valuesCache[columnId];\n      }\n      const column = table.getColumn(columnId);\n      if (!(column != null && column.accessorFn)) {\n        return undefined;\n      }\n      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n      return row._valuesCache[columnId];\n    },\n    getUniqueValues: columnId => {\n      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n        return row._uniqueValuesCache[columnId];\n      }\n      const column = table.getColumn(columnId);\n      if (!(column != null && column.accessorFn)) {\n        return undefined;\n      }\n      if (!column.columnDef.getUniqueValues) {\n        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];\n        return row._uniqueValuesCache[columnId];\n      }\n      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\n      return row._uniqueValuesCache[columnId];\n    },\n    renderValue: columnId => {\n      var _row$getValue;\n      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\n    },\n    subRows: subRows != null ? subRows : [],\n    getLeafRows: () => flattenBy(row.subRows, d => d.subRows),\n    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : undefined,\n    getParentRows: () => {\n      let parentRows = [];\n      let currentRow = row;\n      while (true) {\n        const parentRow = currentRow.getParentRow();\n        if (!parentRow) break;\n        parentRows.push(parentRow);\n        currentRow = parentRow;\n      }\n      return parentRows.reverse();\n    },\n    getAllCells: memo(() => [table.getAllLeafColumns()], leafColumns => {\n      return leafColumns.map(column => {\n        return createCell(table, row, column, column.id);\n      });\n    }, getMemoOptions(table.options, 'debugRows', 'getAllCells')),\n    _getAllCellsByColumnId: memo(() => [row.getAllCells()], allCells => {\n      return allCells.reduce((acc, cell) => {\n        acc[cell.column.id] = cell;\n        return acc;\n      }, {});\n    }, getMemoOptions(table.options, 'debugRows', 'getAllCellsByColumnId'))\n  };\n  for (let i = 0; i < table._features.length; i++) {\n    const feature = table._features[i];\n    feature == null || feature.createRow == null || feature.createRow(row, table);\n  }\n  return row;\n};\n\n// type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n\n// const helper = createColumnHelper<Person>()\n\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\n\nfunction createColumnHelper() {\n  return {\n    accessor: (accessor, column) => {\n      return typeof accessor === 'function' ? {\n        ...column,\n        accessorFn: accessor\n      } : {\n        ...column,\n        accessorKey: accessor\n      };\n    },\n    display: column => column,\n    group: column => column\n  };\n}\n\nfunction getCoreRowModel() {\n  return table => memo(() => [table.options.data], data => {\n    const rowModel = {\n      rows: [],\n      flatRows: [],\n      rowsById: {}\n    };\n    const accessRows = function (originalRows, depth, parentRow) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n      const rows = [];\n      for (let i = 0; i < originalRows.length; i++) {\n        // This could be an expensive check at scale, so we should move it somewhere else, but where?\n        // if (!id) {\n        //   if (process.env.NODE_ENV !== 'production') {\n        //     throw new Error(`getRowId expected an ID, but got ${id}`)\n        //   }\n        // }\n\n        // Make the row\n        const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\n\n        // Keep track of every row in a flat array\n        rowModel.flatRows.push(row);\n        // Also keep track of every row by its ID\n        rowModel.rowsById[row.id] = row;\n        // Push table row into parent\n        rows.push(row);\n\n        // Get the original subrows\n        if (table.options.getSubRows) {\n          var _row$originalSubRows;\n          row.originalSubRows = table.options.getSubRows(originalRows[i], i);\n\n          // Then recursively access them\n          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n          }\n        }\n      }\n      return rows;\n    };\n    rowModel.rows = accessRows(data);\n    return rowModel;\n  }, getMemoOptions(table.options, 'debugTable', 'getRowModel', () => table._autoResetPageIndex()));\n}\n\nfunction filterRows(rows, filterRowImpl, table) {\n  if (table.options.filterFromLeafRows) {\n    return filterRowModelFromLeafs(rows, filterRowImpl, table);\n  }\n  return filterRowModelFromRoot(rows, filterRowImpl, table);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\n  var _table$options$maxLea;\n  const newFilteredFlatRows = [];\n  const newFilteredRowsById = {};\n  const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\n  const recurseFilterRows = function (rowsToFilter, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n    const rows = [];\n\n    // Filter from children up first\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      var _row$subRows;\n      let row = rowsToFilter[i];\n      const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n      newRow.columnFilters = row.columnFilters;\n      if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\n        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n        row = newRow;\n        if (filterRow(row) && !newRow.subRows.length) {\n          rows.push(row);\n          newFilteredRowsById[row.id] = row;\n          newFilteredFlatRows.push(row);\n          continue;\n        }\n        if (filterRow(row) || newRow.subRows.length) {\n          rows.push(row);\n          newFilteredRowsById[row.id] = row;\n          newFilteredFlatRows.push(row);\n          continue;\n        }\n      } else {\n        row = newRow;\n        if (filterRow(row)) {\n          rows.push(row);\n          newFilteredRowsById[row.id] = row;\n          newFilteredFlatRows.push(row);\n        }\n      }\n    }\n    return rows;\n  };\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById\n  };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\n  var _table$options$maxLea2;\n  const newFilteredFlatRows = [];\n  const newFilteredRowsById = {};\n  const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\n\n  // Filters top level and nested rows\n  const recurseFilterRows = function (rowsToFilter, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n    // Filter from parents downward first\n\n    const rows = [];\n\n    // Apply the filter to any subRows\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      let row = rowsToFilter[i];\n      const pass = filterRow(row);\n      if (pass) {\n        var _row$subRows2;\n        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\n          const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n          row = newRow;\n        }\n        rows.push(row);\n        newFilteredFlatRows.push(row);\n        newFilteredRowsById[row.id] = row;\n      }\n    }\n    return rows;\n  };\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById\n  };\n}\n\nfunction getFilteredRowModel() {\n  return table => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {\n    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n      for (let i = 0; i < rowModel.flatRows.length; i++) {\n        rowModel.flatRows[i].columnFilters = {};\n        rowModel.flatRows[i].columnFiltersMeta = {};\n      }\n      return rowModel;\n    }\n    const resolvedColumnFilters = [];\n    const resolvedGlobalFilters = [];\n    (columnFilters != null ? columnFilters : []).forEach(d => {\n      var _filterFn$resolveFilt;\n      const column = table.getColumn(d.id);\n      if (!column) {\n        return;\n      }\n      const filterFn = column.getFilterFn();\n      if (!filterFn) {\n        if (true) {\n          console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\n        }\n        return;\n      }\n      resolvedColumnFilters.push({\n        id: d.id,\n        filterFn,\n        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n      });\n    });\n    const filterableIds = columnFilters.map(d => d.id);\n    const globalFilterFn = table.getGlobalFilterFn();\n    const globallyFilterableColumns = table.getAllLeafColumns().filter(column => column.getCanGlobalFilter());\n    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n      filterableIds.push('__global__');\n      globallyFilterableColumns.forEach(column => {\n        var _globalFilterFn$resol;\n        resolvedGlobalFilters.push({\n          id: column.id,\n          filterFn: globalFilterFn,\n          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n        });\n      });\n    }\n    let currentColumnFilter;\n    let currentGlobalFilter;\n\n    // Flag the prefiltered row model with each filter state\n    for (let j = 0; j < rowModel.flatRows.length; j++) {\n      const row = rowModel.flatRows[j];\n      row.columnFilters = {};\n      if (resolvedColumnFilters.length) {\n        for (let i = 0; i < resolvedColumnFilters.length; i++) {\n          currentColumnFilter = resolvedColumnFilters[i];\n          const id = currentColumnFilter.id;\n\n          // Tag the row with the column filter state\n          row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, filterMeta => {\n            row.columnFiltersMeta[id] = filterMeta;\n          });\n        }\n      }\n      if (resolvedGlobalFilters.length) {\n        for (let i = 0; i < resolvedGlobalFilters.length; i++) {\n          currentGlobalFilter = resolvedGlobalFilters[i];\n          const id = currentGlobalFilter.id;\n          // Tag the row with the first truthy global filter state\n          if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, filterMeta => {\n            row.columnFiltersMeta[id] = filterMeta;\n          })) {\n            row.columnFilters.__global__ = true;\n            break;\n          }\n        }\n        if (row.columnFilters.__global__ !== true) {\n          row.columnFilters.__global__ = false;\n        }\n      }\n    }\n    const filterRowsImpl = row => {\n      // Horizontally filter rows through each column\n      for (let i = 0; i < filterableIds.length; i++) {\n        if (row.columnFilters[filterableIds[i]] === false) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    // Filter final rows using all of the active filters\n    return filterRows(rowModel.rows, filterRowsImpl, table);\n  }, getMemoOptions(table.options, 'debugTable', 'getFilteredRowModel', () => table._autoResetPageIndex()));\n}\n\nfunction getFacetedRowModel() {\n  return (table, columnId) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter, table.getFilteredRowModel()], (preRowModel, columnFilters, globalFilter) => {\n    if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n      return preRowModel;\n    }\n    const filterableIds = [...columnFilters.map(d => d.id).filter(d => d !== columnId), globalFilter ? '__global__' : undefined].filter(Boolean);\n    const filterRowsImpl = row => {\n      // Horizontally filter rows through each column\n      for (let i = 0; i < filterableIds.length; i++) {\n        if (row.columnFilters[filterableIds[i]] === false) {\n          return false;\n        }\n      }\n      return true;\n    };\n    return filterRows(preRowModel.rows, filterRowsImpl, table);\n  }, getMemoOptions(table.options, 'debugTable', 'getFacetedRowModel'));\n}\n\nfunction getFacetedUniqueValues() {\n  return (table, columnId) => memo(() => {\n    var _table$getColumn;\n    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];\n  }, facetedRowModel => {\n    if (!facetedRowModel) return new Map();\n    let facetedUniqueValues = new Map();\n    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n      const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n      for (let j = 0; j < values.length; j++) {\n        const value = values[j];\n        if (facetedUniqueValues.has(value)) {\n          var _facetedUniqueValues$;\n          facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n        } else {\n          facetedUniqueValues.set(value, 1);\n        }\n      }\n    }\n    return facetedUniqueValues;\n  }, getMemoOptions(table.options, 'debugTable', `getFacetedUniqueValues_${columnId}`));\n}\n\nfunction getFacetedMinMaxValues() {\n  return (table, columnId) => memo(() => {\n    var _table$getColumn;\n    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];\n  }, facetedRowModel => {\n    var _facetedRowModel$flat;\n    if (!facetedRowModel) return undefined;\n    const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getUniqueValues(columnId);\n    if (typeof firstValue === 'undefined') {\n      return undefined;\n    }\n    let facetedMinMaxValues = [firstValue, firstValue];\n    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n      const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n      for (let j = 0; j < values.length; j++) {\n        const value = values[j];\n        if (value < facetedMinMaxValues[0]) {\n          facetedMinMaxValues[0] = value;\n        } else if (value > facetedMinMaxValues[1]) {\n          facetedMinMaxValues[1] = value;\n        }\n      }\n    }\n    return facetedMinMaxValues;\n  }, getMemoOptions(table.options, 'debugTable', 'getFacetedMinMaxValues'));\n}\n\nfunction getSortedRowModel() {\n  return table => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {\n    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n      return rowModel;\n    }\n    const sortingState = table.getState().sorting;\n    const sortedFlatRows = [];\n\n    // Filter out sortings that correspond to non existing columns\n    const availableSorting = sortingState.filter(sort => {\n      var _table$getColumn;\n      return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\n    });\n    const columnInfoById = {};\n    availableSorting.forEach(sortEntry => {\n      const column = table.getColumn(sortEntry.id);\n      if (!column) return;\n      columnInfoById[sortEntry.id] = {\n        sortUndefined: column.columnDef.sortUndefined,\n        invertSorting: column.columnDef.invertSorting,\n        sortingFn: column.getSortingFn()\n      };\n    });\n    const sortData = rows => {\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      const sortedData = rows.map(row => ({\n        ...row\n      }));\n      sortedData.sort((rowA, rowB) => {\n        for (let i = 0; i < availableSorting.length; i += 1) {\n          var _sortEntry$desc;\n          const sortEntry = availableSorting[i];\n          const columnInfo = columnInfoById[sortEntry.id];\n          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n          let sortInt = 0;\n\n          // All sorting ints should always return in ascending order\n          if (columnInfo.sortUndefined) {\n            const aValue = rowA.getValue(sortEntry.id);\n            const bValue = rowB.getValue(sortEntry.id);\n            const aUndefined = aValue === undefined;\n            const bUndefined = bValue === undefined;\n            if (aUndefined || bUndefined) {\n              sortInt = aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;\n            }\n          }\n          if (sortInt === 0) {\n            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n          }\n\n          // If sorting is non-zero, take care of desc and inversion\n          if (sortInt !== 0) {\n            if (isDesc) {\n              sortInt *= -1;\n            }\n            if (columnInfo.invertSorting) {\n              sortInt *= -1;\n            }\n            return sortInt;\n          }\n        }\n        return rowA.index - rowB.index;\n      });\n\n      // If there are sub-rows, sort them\n      sortedData.forEach(row => {\n        var _row$subRows;\n        sortedFlatRows.push(row);\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n          row.subRows = sortData(row.subRows);\n        }\n      });\n      return sortedData;\n    };\n    return {\n      rows: sortData(rowModel.rows),\n      flatRows: sortedFlatRows,\n      rowsById: rowModel.rowsById\n    };\n  }, getMemoOptions(table.options, 'debugTable', 'getSortedRowModel', () => table._autoResetPageIndex()));\n}\n\nfunction getGroupedRowModel() {\n  return table => memo(() => [table.getState().grouping, table.getPreGroupedRowModel()], (grouping, rowModel) => {\n    if (!rowModel.rows.length || !grouping.length) {\n      return rowModel;\n    }\n\n    // Filter the grouping list down to columns that exist\n    const existingGrouping = grouping.filter(columnId => table.getColumn(columnId));\n    const groupedFlatRows = [];\n    const groupedRowsById = {};\n    // const onlyGroupedFlatRows: Row[] = [];\n    // const onlyGroupedRowsById: Record<RowId, Row> = {};\n    // const nonGroupedFlatRows: Row[] = [];\n    // const nonGroupedRowsById: Record<RowId, Row> = {};\n\n    // Recursively group the data\n    const groupUpRecursively = function (rows, depth, parentId) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n      // Grouping depth has been been met\n      // Stop grouping and simply rewrite thd depth and row relationships\n      if (depth >= existingGrouping.length) {\n        return rows.map(row => {\n          row.depth = depth;\n          groupedFlatRows.push(row);\n          groupedRowsById[row.id] = row;\n          if (row.subRows) {\n            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n          }\n          return row;\n        });\n      }\n      const columnId = existingGrouping[depth];\n\n      // Group the rows together for this level\n      const rowGroupsMap = groupBy(rows, columnId);\n\n      // Peform aggregations for each group\n      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {\n        let [groupingValue, groupedRows] = _ref;\n        let id = `${columnId}:${groupingValue}`;\n        id = parentId ? `${parentId}>${id}` : id;\n\n        // First, Recurse to group sub rows before aggregation\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n\n        // Flatten the leaf rows of the rows in this group\n        const leafRows = depth ? flattenBy(groupedRows, row => row.subRows) : groupedRows;\n        const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n        Object.assign(row, {\n          groupingColumnId: columnId,\n          groupingValue,\n          subRows,\n          leafRows,\n          getValue: columnId => {\n            // Don't aggregate columns that are in the grouping\n            if (existingGrouping.includes(columnId)) {\n              if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n              }\n              if (groupedRows[0]) {\n                var _groupedRows$0$getVal;\n                row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n              }\n              return row._valuesCache[columnId];\n            }\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n              return row._groupingValuesCache[columnId];\n            }\n\n            // Aggregate the values\n            const column = table.getColumn(columnId);\n            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n            if (aggregateFn) {\n              row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n              return row._groupingValuesCache[columnId];\n            }\n          }\n        });\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow);\n          groupedRowsById[subRow.id] = subRow;\n          // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        });\n        return row;\n      });\n      return aggregatedGroupedRows;\n    };\n    const groupedRows = groupUpRecursively(rowModel.rows, 0);\n    groupedRows.forEach(subRow => {\n      groupedFlatRows.push(subRow);\n      groupedRowsById[subRow.id] = subRow;\n      // if (subRow.getIsGrouped?.()) {\n      //   onlyGroupedFlatRows.push(subRow);\n      //   onlyGroupedRowsById[subRow.id] = subRow;\n      // } else {\n      //   nonGroupedFlatRows.push(subRow);\n      //   nonGroupedRowsById[subRow.id] = subRow;\n      // }\n    });\n    return {\n      rows: groupedRows,\n      flatRows: groupedFlatRows,\n      rowsById: groupedRowsById\n    };\n  }, getMemoOptions(table.options, 'debugTable', 'getGroupedRowModel', () => {\n    table._queue(() => {\n      table._autoResetExpanded();\n      table._autoResetPageIndex();\n    });\n  }));\n}\nfunction groupBy(rows, columnId) {\n  const groupMap = new Map();\n  return rows.reduce((map, row) => {\n    const resKey = `${row.getGroupingValue(columnId)}`;\n    const previous = map.get(resKey);\n    if (!previous) {\n      map.set(resKey, [row]);\n    } else {\n      previous.push(row);\n    }\n    return map;\n  }, groupMap);\n}\n\nfunction getExpandedRowModel() {\n  return table => memo(() => [table.getState().expanded, table.getPreExpandedRowModel(), table.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {\n    if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n      return rowModel;\n    }\n    if (!paginateExpandedRows) {\n      // Only expand rows at this point if they are being paginated\n      return rowModel;\n    }\n    return expandRows(rowModel);\n  }, getMemoOptions(table.options, 'debugTable', 'getExpandedRowModel'));\n}\nfunction expandRows(rowModel) {\n  const expandedRows = [];\n  const handleRow = row => {\n    var _row$subRows;\n    expandedRows.push(row);\n    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n      row.subRows.forEach(handleRow);\n    }\n  };\n  rowModel.rows.forEach(handleRow);\n  return {\n    rows: expandedRows,\n    flatRows: rowModel.flatRows,\n    rowsById: rowModel.rowsById\n  };\n}\n\nfunction getPaginationRowModel(opts) {\n  return table => memo(() => [table.getState().pagination, table.getPrePaginationRowModel(), table.options.paginateExpandedRows ? undefined : table.getState().expanded], (pagination, rowModel) => {\n    if (!rowModel.rows.length) {\n      return rowModel;\n    }\n    const {\n      pageSize,\n      pageIndex\n    } = pagination;\n    let {\n      rows,\n      flatRows,\n      rowsById\n    } = rowModel;\n    const pageStart = pageSize * pageIndex;\n    const pageEnd = pageStart + pageSize;\n    rows = rows.slice(pageStart, pageEnd);\n    let paginatedRowModel;\n    if (!table.options.paginateExpandedRows) {\n      paginatedRowModel = expandRows({\n        rows,\n        flatRows,\n        rowsById\n      });\n    } else {\n      paginatedRowModel = {\n        rows,\n        flatRows,\n        rowsById\n      };\n    }\n    paginatedRowModel.flatRows = [];\n    const handleRow = row => {\n      paginatedRowModel.flatRows.push(row);\n      if (row.subRows.length) {\n        row.subRows.forEach(handleRow);\n      }\n    };\n    paginatedRowModel.rows.forEach(handleRow);\n    return paginatedRowModel;\n  }, getMemoOptions(table.options, 'debugTable', 'getPaginationRowModel'));\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QixHQUFHLG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0EseUJBQXlCLDREQUE0RCxjQUFjO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFNBQVMsS0FBc0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBcUM7QUFDbkQsNkJBQTZCLElBQUksMEJBQTBCLFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZEQUE2RDtBQUN6RztBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnR0FBZ0c7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJKQUEySjtBQUNyTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnR0FBZ0c7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUNBQW1DO0FBQ3pELFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvR0FBb0c7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEtBQUs7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpS0FBaUssOENBQThDO0FBQy9NLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25ELGtFQUFrRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxVQUFVLEtBQXFDO0FBQy9DLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPLEdBQUcsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWCxLQUFLO0FBQ0w7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLEdBQUc7QUFDdEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pELDJGQUEyRixVQUFVO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx3RUFBd0UsU0FBUztBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxHQUFHLGNBQWM7QUFDOUMsMkJBQTJCLFNBQVMsR0FBRyxHQUFHOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUU4dEI7QUFDOXRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVleHktbXVpLW5leHRqcy1hZG1pbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdGFibGUtY29yZS9idWlsZC9saWIvaW5kZXgubWpzPzliYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gICAqIHRhYmxlLWNvcmVcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKlxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovXG4vLyBJcyB0aGlzIHR5cGUgYSB0dXBsZT9cblxuLy8gSWYgdGhpcyB0eXBlIGlzIGEgdHVwbGUsIHdoYXQgaW5kaWNlcyBhcmUgYWxsb3dlZD9cblxuLy8vXG5cbmZ1bmN0aW9uIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgaW5wdXQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1cGRhdGVyID09PSAnZnVuY3Rpb24nID8gdXBkYXRlcihpbnB1dCkgOiB1cGRhdGVyO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy9cbn1cbmZ1bmN0aW9uIG1ha2VTdGF0ZVVwZGF0ZXIoa2V5LCBpbnN0YW5jZSkge1xuICByZXR1cm4gdXBkYXRlciA9PiB7XG4gICAgaW5zdGFuY2Uuc2V0U3RhdGUob2xkID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9sZCxcbiAgICAgICAgW2tleV06IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkW2tleV0pXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihkKSB7XG4gIHJldHVybiBkIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5mdW5jdGlvbiBpc051bWJlckFycmF5KGQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZCkgJiYgZC5ldmVyeSh2YWwgPT4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpO1xufVxuZnVuY3Rpb24gZmxhdHRlbkJ5KGFyciwgZ2V0Q2hpbGRyZW4pIHtcbiAgY29uc3QgZmxhdCA9IFtdO1xuICBjb25zdCByZWN1cnNlID0gc3ViQXJyID0+IHtcbiAgICBzdWJBcnIuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGZsYXQucHVzaChpdGVtKTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oaXRlbSk7XG4gICAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmVjdXJzZShjaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHJlY3Vyc2UoYXJyKTtcbiAgcmV0dXJuIGZsYXQ7XG59XG5mdW5jdGlvbiBtZW1vKGdldERlcHMsIGZuLCBvcHRzKSB7XG4gIGxldCBkZXBzID0gW107XG4gIGxldCByZXN1bHQ7XG4gIHJldHVybiBkZXBBcmdzID0+IHtcbiAgICBsZXQgZGVwVGltZTtcbiAgICBpZiAob3B0cy5rZXkgJiYgb3B0cy5kZWJ1ZykgZGVwVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbmV3RGVwcyA9IGdldERlcHMoZGVwQXJncyk7XG4gICAgY29uc3QgZGVwc0NoYW5nZWQgPSBuZXdEZXBzLmxlbmd0aCAhPT0gZGVwcy5sZW5ndGggfHwgbmV3RGVwcy5zb21lKChkZXAsIGluZGV4KSA9PiBkZXBzW2luZGV4XSAhPT0gZGVwKTtcbiAgICBpZiAoIWRlcHNDaGFuZ2VkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBkZXBzID0gbmV3RGVwcztcbiAgICBsZXQgcmVzdWx0VGltZTtcbiAgICBpZiAob3B0cy5rZXkgJiYgb3B0cy5kZWJ1ZykgcmVzdWx0VGltZSA9IERhdGUubm93KCk7XG4gICAgcmVzdWx0ID0gZm4oLi4ubmV3RGVwcyk7XG4gICAgb3B0cyA9PSBudWxsIHx8IG9wdHMub25DaGFuZ2UgPT0gbnVsbCB8fCBvcHRzLm9uQ2hhbmdlKHJlc3VsdCk7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIHtcbiAgICAgIGlmIChvcHRzICE9IG51bGwgJiYgb3B0cy5kZWJ1ZygpKSB7XG4gICAgICAgIGNvbnN0IGRlcEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gZGVwVGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgICBjb25zdCByZXN1bHRFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIHJlc3VsdFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgICAgY29uc3QgcmVzdWx0RnBzUGVyY2VudGFnZSA9IHJlc3VsdEVuZFRpbWUgLyAxNjtcbiAgICAgICAgY29uc3QgcGFkID0gKHN0ciwgbnVtKSA9PiB7XG4gICAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgICAgIHN0ciA9ICcgJyArIHN0cjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS5pbmZvKGAlY+KPsSAke3BhZChyZXN1bHRFbmRUaW1lLCA1KX0gLyR7cGFkKGRlcEVuZFRpbWUsIDUpfSBtc2AsIGBcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogLjZyZW07XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIGNvbG9yOiBoc2woJHtNYXRoLm1heCgwLCBNYXRoLm1pbigxMjAgLSAxMjAgKiByZXN1bHRGcHNQZXJjZW50YWdlLCAxMjApKX1kZWcgMTAwJSAzMSUpO2AsIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMua2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE1lbW9PcHRpb25zKHRhYmxlT3B0aW9ucywgZGVidWdMZXZlbCwga2V5LCBvbkNoYW5nZSkge1xuICByZXR1cm4ge1xuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlT3B0aW9ucyRkZWJ1Z0FsO1xuICAgICAgcmV0dXJuIChfdGFibGVPcHRpb25zJGRlYnVnQWwgPSB0YWJsZU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlT3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZU9wdGlvbnMkZGVidWdBbCA6IHRhYmxlT3B0aW9uc1tkZWJ1Z0xldmVsXTtcbiAgICB9LFxuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYga2V5LFxuICAgIG9uQ2hhbmdlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbHVtbih0YWJsZSwgY29sdW1uRGVmLCBkZXB0aCwgcGFyZW50KSB7XG4gIHZhciBfcmVmLCBfcmVzb2x2ZWRDb2x1bW5EZWYkaWQ7XG4gIGNvbnN0IGRlZmF1bHRDb2x1bW4gPSB0YWJsZS5fZ2V0RGVmYXVsdENvbHVtbkRlZigpO1xuICBjb25zdCByZXNvbHZlZENvbHVtbkRlZiA9IHtcbiAgICAuLi5kZWZhdWx0Q29sdW1uLFxuICAgIC4uLmNvbHVtbkRlZlxuICB9O1xuICBjb25zdCBhY2Nlc3NvcktleSA9IHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5O1xuICBsZXQgaWQgPSAoX3JlZiA9IChfcmVzb2x2ZWRDb2x1bW5EZWYkaWQgPSByZXNvbHZlZENvbHVtbkRlZi5pZCkgIT0gbnVsbCA/IF9yZXNvbHZlZENvbHVtbkRlZiRpZCA6IGFjY2Vzc29yS2V5ID8gYWNjZXNzb3JLZXkucmVwbGFjZSgnLicsICdfJykgOiB1bmRlZmluZWQpICE9IG51bGwgPyBfcmVmIDogdHlwZW9mIHJlc29sdmVkQ29sdW1uRGVmLmhlYWRlciA9PT0gJ3N0cmluZycgPyByZXNvbHZlZENvbHVtbkRlZi5oZWFkZXIgOiB1bmRlZmluZWQ7XG4gIGxldCBhY2Nlc3NvckZuO1xuICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbikge1xuICAgIGFjY2Vzc29yRm4gPSByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuO1xuICB9IGVsc2UgaWYgKGFjY2Vzc29yS2V5KSB7XG4gICAgLy8gU3VwcG9ydCBkZWVwIGFjY2Vzc29yIGtleXNcbiAgICBpZiAoYWNjZXNzb3JLZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgYWNjZXNzb3JGbiA9IG9yaWdpbmFsUm93ID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG9yaWdpbmFsUm93O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBhY2Nlc3NvcktleS5zcGxpdCgnLicpKSB7XG4gICAgICAgICAgdmFyIF9yZXN1bHQ7XG4gICAgICAgICAgcmVzdWx0ID0gKF9yZXN1bHQgPSByZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0W2tleV07XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCIke2tleX1cIiBpbiBkZWVwbHkgbmVzdGVkIGtleSBcIiR7YWNjZXNzb3JLZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjZXNzb3JGbiA9IG9yaWdpbmFsUm93ID0+IG9yaWdpbmFsUm93W3Jlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbiA/IGBDb2x1bW5zIHJlcXVpcmUgYW4gaWQgd2hlbiB1c2luZyBhbiBhY2Nlc3NvckZuYCA6IGBDb2x1bW5zIHJlcXVpcmUgYW4gaWQgd2hlbiB1c2luZyBhIG5vbi1zdHJpbmcgaGVhZGVyYCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIGxldCBjb2x1bW4gPSB7XG4gICAgaWQ6IGAke1N0cmluZyhpZCl9YCxcbiAgICBhY2Nlc3NvckZuLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGRlcHRoLFxuICAgIGNvbHVtbkRlZjogcmVzb2x2ZWRDb2x1bW5EZWYsXG4gICAgY29sdW1uczogW10sXG4gICAgZ2V0RmxhdENvbHVtbnM6IG1lbW8oKCkgPT4gW3RydWVdLCAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5zO1xuICAgICAgcmV0dXJuIFtjb2x1bW4sIC4uLigoX2NvbHVtbiRjb2x1bW5zID0gY29sdW1uLmNvbHVtbnMpID09IG51bGwgPyB2b2lkIDAgOiBfY29sdW1uJGNvbHVtbnMuZmxhdE1hcChkID0+IGQuZ2V0RmxhdENvbHVtbnMoKSkpXTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2NvbHVtbi5nZXRGbGF0Q29sdW1ucycpKSxcbiAgICBnZXRMZWFmQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuKCldLCBvcmRlckNvbHVtbnMgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uczI7XG4gICAgICBpZiAoKF9jb2x1bW4kY29sdW1uczIgPSBjb2x1bW4uY29sdW1ucykgIT0gbnVsbCAmJiBfY29sdW1uJGNvbHVtbnMyLmxlbmd0aCkge1xuICAgICAgICBsZXQgbGVhZkNvbHVtbnMgPSBjb2x1bW4uY29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKSk7XG4gICAgICAgIHJldHVybiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtjb2x1bW5dO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnY29sdW1uLmdldExlYWZDb2x1bW5zJykpXG4gIH07XG4gIGZvciAoY29uc3QgZmVhdHVyZSBvZiB0YWJsZS5fZmVhdHVyZXMpIHtcbiAgICBmZWF0dXJlLmNyZWF0ZUNvbHVtbiA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlQ29sdW1uKGNvbHVtbiwgdGFibGUpO1xuICB9XG5cbiAgLy8gWWVzLCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGFibGUgdG8gdWtub3duLCBiZWNhdXNlIHdlIGtub3cgbW9yZSB0aGFuIHRoZSBjb21waWxlciBoZXJlLlxuICByZXR1cm4gY29sdW1uO1xufVxuXG5jb25zdCBkZWJ1ZyA9ICdkZWJ1Z0hlYWRlcnMnO1xuLy9cblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGlkO1xuICBjb25zdCBpZCA9IChfb3B0aW9ucyRpZCA9IG9wdGlvbnMuaWQpICE9IG51bGwgPyBfb3B0aW9ucyRpZCA6IGNvbHVtbi5pZDtcbiAgbGV0IGhlYWRlciA9IHtcbiAgICBpZCxcbiAgICBjb2x1bW4sXG4gICAgaW5kZXg6IG9wdGlvbnMuaW5kZXgsXG4gICAgaXNQbGFjZWhvbGRlcjogISFvcHRpb25zLmlzUGxhY2Vob2xkZXIsXG4gICAgcGxhY2Vob2xkZXJJZDogb3B0aW9ucy5wbGFjZWhvbGRlcklkLFxuICAgIGRlcHRoOiBvcHRpb25zLmRlcHRoLFxuICAgIHN1YkhlYWRlcnM6IFtdLFxuICAgIGNvbFNwYW46IDAsXG4gICAgcm93U3BhbjogMCxcbiAgICBoZWFkZXJHcm91cDogbnVsbCxcbiAgICBnZXRMZWFmSGVhZGVyczogKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkhlYWRlcnMgPSBbXTtcbiAgICAgIGNvbnN0IHJlY3Vyc2VIZWFkZXIgPSBoID0+IHtcbiAgICAgICAgaWYgKGguc3ViSGVhZGVycyAmJiBoLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaC5zdWJIZWFkZXJzLm1hcChyZWN1cnNlSGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZWFmSGVhZGVycy5wdXNoKGgpO1xuICAgICAgfTtcbiAgICAgIHJlY3Vyc2VIZWFkZXIoaGVhZGVyKTtcbiAgICAgIHJldHVybiBsZWFmSGVhZGVycztcbiAgICB9LFxuICAgIGdldENvbnRleHQ6ICgpID0+ICh7XG4gICAgICB0YWJsZSxcbiAgICAgIGhlYWRlcjogaGVhZGVyLFxuICAgICAgY29sdW1uXG4gICAgfSlcbiAgfTtcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgZmVhdHVyZS5jcmVhdGVIZWFkZXIgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZUhlYWRlcihoZWFkZXIsIHRhYmxlKTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXI7XG59XG5jb25zdCBIZWFkZXJzID0ge1xuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIC8vIEhlYWRlciBHcm91cHNcblxuICAgIHRhYmxlLmdldEhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX2xlZnQkbWFwJGZpbHRlciwgX3JpZ2h0JG1hcCRmaWx0ZXI7XG4gICAgICBjb25zdCBsZWZ0Q29sdW1ucyA9IChfbGVmdCRtYXAkZmlsdGVyID0gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX2xlZnQkbWFwJGZpbHRlciA6IFtdO1xuICAgICAgY29uc3QgcmlnaHRDb2x1bW5zID0gKF9yaWdodCRtYXAkZmlsdGVyID0gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfcmlnaHQkbWFwJGZpbHRlciA6IFtdO1xuICAgICAgY29uc3QgY2VudGVyQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gIShsZWZ0ICE9IG51bGwgJiYgbGVmdC5pbmNsdWRlcyhjb2x1bW4uaWQpKSAmJiAhKHJpZ2h0ICE9IG51bGwgJiYgcmlnaHQuaW5jbHVkZXMoY29sdW1uLmlkKSkpO1xuICAgICAgY29uc3QgaGVhZGVyR3JvdXBzID0gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgWy4uLmxlZnRDb2x1bW5zLCAuLi5jZW50ZXJDb2x1bW5zLCAuLi5yaWdodENvbHVtbnNdLCB0YWJsZSk7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0SGVhZGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBsZWFmQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gIShsZWZ0ICE9IG51bGwgJiYgbGVmdC5pbmNsdWRlcyhjb2x1bW4uaWQpKSAmJiAhKHJpZ2h0ICE9IG51bGwgJiYgcmlnaHQuaW5jbHVkZXMoY29sdW1uLmlkKSkpO1xuICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCB0YWJsZSwgJ2NlbnRlcicpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0Q2VudGVySGVhZGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldExlZnRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgbGVmdCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JG1hcCRmaWx0ZXIyO1xuICAgICAgY29uc3Qgb3JkZXJlZExlYWZDb2x1bW5zID0gKF9sZWZ0JG1hcCRmaWx0ZXIyID0gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX2xlZnQkbWFwJGZpbHRlcjIgOiBbXTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBvcmRlcmVkTGVhZkNvbHVtbnMsIHRhYmxlLCAnbGVmdCcpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdEhlYWRlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgcmlnaHQpID0+IHtcbiAgICAgIHZhciBfcmlnaHQkbWFwJGZpbHRlcjI7XG4gICAgICBjb25zdCBvcmRlcmVkTGVhZkNvbHVtbnMgPSAoX3JpZ2h0JG1hcCRmaWx0ZXIyID0gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfcmlnaHQkbWFwJGZpbHRlcjIgOiBbXTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBvcmRlcmVkTGVhZkNvbHVtbnMsIHRhYmxlLCAncmlnaHQnKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldFJpZ2h0SGVhZGVyR3JvdXBzJykpO1xuXG4gICAgLy8gRm9vdGVyIEdyb3Vwc1xuXG4gICAgdGFibGUuZ2V0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5oZWFkZXJHcm91cHNdLnJldmVyc2UoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEZvb3Rlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRMZWZ0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0Rm9vdGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldENlbnRlckZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJGb290ZXJHcm91cHMnKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEZvb3Rlckdyb3VwcycpKTtcblxuICAgIC8vIEZsYXQgSGVhZGVyc1xuXG4gICAgdGFibGUuZ2V0RmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzLm1hcChoZWFkZXJHcm91cCA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzO1xuICAgICAgfSkuZmxhdCgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0RmxhdEhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0TGVmdEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldExlZnRGbGF0SGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldENlbnRlckZsYXRIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldFJpZ2h0RmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldFJpZ2h0RmxhdEhlYWRlcnMnKSk7XG5cbiAgICAvLyBMZWFmIEhlYWRlcnNcblxuICAgIHRhYmxlLmdldENlbnRlckxlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Q2VudGVyRmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVycztcbiAgICAgICAgcmV0dXJuICEoKF9oZWFkZXIkc3ViSGVhZGVycyA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVycy5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJMZWFmSGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRMZWZ0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0RmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVyczI7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMyID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzMi5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0TGVhZkhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJpZ2h0RmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVyczM7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMzID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzMy5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodExlYWZIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldExlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpLCB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKSwgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIChsZWZ0LCBjZW50ZXIsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX2xlZnQkMCRoZWFkZXJzLCBfbGVmdCQsIF9jZW50ZXIkMCRoZWFkZXJzLCBfY2VudGVyJCwgX3JpZ2h0JDAkaGVhZGVycywgX3JpZ2h0JDtcbiAgICAgIHJldHVybiBbLi4uKChfbGVmdCQwJGhlYWRlcnMgPSAoX2xlZnQkID0gbGVmdFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZWZ0JC5oZWFkZXJzKSAhPSBudWxsID8gX2xlZnQkMCRoZWFkZXJzIDogW10pLCAuLi4oKF9jZW50ZXIkMCRoZWFkZXJzID0gKF9jZW50ZXIkID0gY2VudGVyWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2NlbnRlciQuaGVhZGVycykgIT0gbnVsbCA/IF9jZW50ZXIkMCRoZWFkZXJzIDogW10pLCAuLi4oKF9yaWdodCQwJGhlYWRlcnMgPSAoX3JpZ2h0JCA9IHJpZ2h0WzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3JpZ2h0JC5oZWFkZXJzKSAhPSBudWxsID8gX3JpZ2h0JDAkaGVhZGVycyA6IFtdKV0ubWFwKGhlYWRlciA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXIuZ2V0TGVhZkhlYWRlcnMoKTtcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldExlYWZIZWFkZXJzJykpO1xuICB9XG59O1xuZnVuY3Rpb24gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgY29sdW1uc1RvR3JvdXAsIHRhYmxlLCBoZWFkZXJGYW1pbHkpIHtcbiAgdmFyIF9oZWFkZXJHcm91cHMkMCRoZWFkZSwgX2hlYWRlckdyb3VwcyQ7XG4gIC8vIEZpbmQgdGhlIG1heCBkZXB0aCBvZiB0aGUgY29sdW1uczpcbiAgLy8gYnVpbGQgdGhlIGxlYWYgY29sdW1uIHJvd1xuICAvLyBidWlsZCBlYWNoIGJ1ZmZlciByb3cgZ29pbmcgdXBcbiAgLy8gICAgcGxhY2Vob2xkZXIgZm9yIG5vbi1leGlzdGVudCBsZXZlbFxuICAvLyAgICByZWFsIGNvbHVtbiBmb3IgZXhpc3RpbmcgbGV2ZWxcblxuICBsZXQgbWF4RGVwdGggPSAwO1xuICBjb25zdCBmaW5kTWF4RGVwdGggPSBmdW5jdGlvbiAoY29sdW1ucywgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgZGVwdGggPSAxO1xuICAgIH1cbiAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBkZXB0aCk7XG4gICAgY29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5nZXRJc1Zpc2libGUoKSkuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1ucztcbiAgICAgIGlmICgoX2NvbHVtbiRjb2x1bW5zID0gY29sdW1uLmNvbHVtbnMpICE9IG51bGwgJiYgX2NvbHVtbiRjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBmaW5kTWF4RGVwdGgoY29sdW1uLmNvbHVtbnMsIGRlcHRoICsgMSk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH07XG4gIGZpbmRNYXhEZXB0aChhbGxDb2x1bW5zKTtcbiAgbGV0IGhlYWRlckdyb3VwcyA9IFtdO1xuICBjb25zdCBjcmVhdGVIZWFkZXJHcm91cCA9IChoZWFkZXJzVG9Hcm91cCwgZGVwdGgpID0+IHtcbiAgICAvLyBUaGUgaGVhZGVyIGdyb3VwIHdlIGFyZSBjcmVhdGluZ1xuICAgIGNvbnN0IGhlYWRlckdyb3VwID0ge1xuICAgICAgZGVwdGgsXG4gICAgICBpZDogW2hlYWRlckZhbWlseSwgYCR7ZGVwdGh9YF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ18nKSxcbiAgICAgIGhlYWRlcnM6IFtdXG4gICAgfTtcblxuICAgIC8vIFRoZSBwYXJlbnQgY29sdW1ucyB3ZSdyZSBnb2luZyB0byBzY2FuIG5leHRcbiAgICBjb25zdCBwZW5kaW5nUGFyZW50SGVhZGVycyA9IFtdO1xuXG4gICAgLy8gU2NhbiBlYWNoIGNvbHVtbiBmb3IgcGFyZW50c1xuICAgIGhlYWRlcnNUb0dyb3VwLmZvckVhY2goaGVhZGVyVG9Hcm91cCA9PiB7XG4gICAgICAvLyBXaGF0IGlzIHRoZSBsYXRlc3QgKGxhc3QpIHBhcmVudCBjb2x1bW4/XG5cbiAgICAgIGNvbnN0IGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIgPSBbLi4ucGVuZGluZ1BhcmVudEhlYWRlcnNdLnJldmVyc2UoKVswXTtcbiAgICAgIGNvbnN0IGlzTGVhZkhlYWRlciA9IGhlYWRlclRvR3JvdXAuY29sdW1uLmRlcHRoID09PSBoZWFkZXJHcm91cC5kZXB0aDtcbiAgICAgIGxldCBjb2x1bW47XG4gICAgICBsZXQgaXNQbGFjZWhvbGRlciA9IGZhbHNlO1xuICAgICAgaWYgKGlzTGVhZkhlYWRlciAmJiBoZWFkZXJUb0dyb3VwLmNvbHVtbi5wYXJlbnQpIHtcbiAgICAgICAgLy8gVGhlIHBhcmVudCBoZWFkZXIgaXMgbmV3XG4gICAgICAgIGNvbHVtbiA9IGhlYWRlclRvR3JvdXAuY29sdW1uLnBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBwYXJlbnQgaGVhZGVyIGlzIHJlcGVhdGVkXG4gICAgICAgIGNvbHVtbiA9IGhlYWRlclRvR3JvdXAuY29sdW1uO1xuICAgICAgICBpc1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyICYmIChsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyID09IG51bGwgPyB2b2lkIDAgOiBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyLmNvbHVtbikgPT09IGNvbHVtbikge1xuICAgICAgICAvLyBUaGlzIGNvbHVtbiBpcyByZXBlYXRlZC4gQWRkIGl0IGFzIGEgc3ViIGhlYWRlciB0byB0aGUgbmV4dCBiYXRjaFxuICAgICAgICBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyLnN1YkhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgaGVhZGVyLiBMZXQncyBjcmVhdGUgaXRcbiAgICAgICAgY29uc3QgaGVhZGVyID0gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIHtcbiAgICAgICAgICBpZDogW2hlYWRlckZhbWlseSwgZGVwdGgsIGNvbHVtbi5pZCwgaGVhZGVyVG9Hcm91cCA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVyVG9Hcm91cC5pZF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ18nKSxcbiAgICAgICAgICBpc1BsYWNlaG9sZGVyLFxuICAgICAgICAgIHBsYWNlaG9sZGVySWQ6IGlzUGxhY2Vob2xkZXIgPyBgJHtwZW5kaW5nUGFyZW50SGVhZGVycy5maWx0ZXIoZCA9PiBkLmNvbHVtbiA9PT0gY29sdW1uKS5sZW5ndGh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBpbmRleDogcGVuZGluZ1BhcmVudEhlYWRlcnMubGVuZ3RoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgaGVhZGVyVG9Hcm91cCBhcyBhIHN1YkhlYWRlciBvZiB0aGUgbmV3IGhlYWRlclxuICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5wdXNoKGhlYWRlclRvR3JvdXApO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyBoZWFkZXIgdG8gdGhlIHBlbmRpbmdQYXJlbnRIZWFkZXJzIHRvIGdldCBncm91cGVkXG4gICAgICAgIC8vIGluIHRoZSBuZXh0IGJhdGNoXG4gICAgICAgIHBlbmRpbmdQYXJlbnRIZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlckdyb3VwLmhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgIGhlYWRlclRvR3JvdXAuaGVhZGVyR3JvdXAgPSBoZWFkZXJHcm91cDtcbiAgICB9KTtcbiAgICBoZWFkZXJHcm91cHMucHVzaChoZWFkZXJHcm91cCk7XG4gICAgaWYgKGRlcHRoID4gMCkge1xuICAgICAgY3JlYXRlSGVhZGVyR3JvdXAocGVuZGluZ1BhcmVudEhlYWRlcnMsIGRlcHRoIC0gMSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBib3R0b21IZWFkZXJzID0gY29sdW1uc1RvR3JvdXAubWFwKChjb2x1bW4sIGluZGV4KSA9PiBjcmVhdGVIZWFkZXIodGFibGUsIGNvbHVtbiwge1xuICAgIGRlcHRoOiBtYXhEZXB0aCxcbiAgICBpbmRleFxuICB9KSk7XG4gIGNyZWF0ZUhlYWRlckdyb3VwKGJvdHRvbUhlYWRlcnMsIG1heERlcHRoIC0gMSk7XG4gIGhlYWRlckdyb3Vwcy5yZXZlcnNlKCk7XG5cbiAgLy8gaGVhZGVyR3JvdXBzID0gaGVhZGVyR3JvdXBzLmZpbHRlcihoZWFkZXJHcm91cCA9PiB7XG4gIC8vICAgcmV0dXJuICFoZWFkZXJHcm91cC5oZWFkZXJzLmV2ZXJ5KGhlYWRlciA9PiBoZWFkZXIuaXNQbGFjZWhvbGRlcilcbiAgLy8gfSlcblxuICBjb25zdCByZWN1cnNlSGVhZGVyc0ZvclNwYW5zID0gaGVhZGVycyA9PiB7XG4gICAgY29uc3QgZmlsdGVyZWRIZWFkZXJzID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IGhlYWRlci5jb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xuICAgIHJldHVybiBmaWx0ZXJlZEhlYWRlcnMubWFwKGhlYWRlciA9PiB7XG4gICAgICBsZXQgY29sU3BhbiA9IDA7XG4gICAgICBsZXQgcm93U3BhbiA9IDA7XG4gICAgICBsZXQgY2hpbGRSb3dTcGFucyA9IFswXTtcbiAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycyAmJiBoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgY2hpbGRSb3dTcGFucyA9IFtdO1xuICAgICAgICByZWN1cnNlSGVhZGVyc0ZvclNwYW5zKGhlYWRlci5zdWJIZWFkZXJzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjb2xTcGFuOiBjaGlsZENvbFNwYW4sXG4gICAgICAgICAgICByb3dTcGFuOiBjaGlsZFJvd1NwYW5cbiAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICBjb2xTcGFuICs9IGNoaWxkQ29sU3BhbjtcbiAgICAgICAgICBjaGlsZFJvd1NwYW5zLnB1c2goY2hpbGRSb3dTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xTcGFuID0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pbkNoaWxkUm93U3BhbiA9IE1hdGgubWluKC4uLmNoaWxkUm93U3BhbnMpO1xuICAgICAgcm93U3BhbiA9IHJvd1NwYW4gKyBtaW5DaGlsZFJvd1NwYW47XG4gICAgICBoZWFkZXIuY29sU3BhbiA9IGNvbFNwYW47XG4gICAgICBoZWFkZXIucm93U3BhbiA9IHJvd1NwYW47XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xTcGFuLFxuICAgICAgICByb3dTcGFuXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuICByZWN1cnNlSGVhZGVyc0ZvclNwYW5zKChfaGVhZGVyR3JvdXBzJDAkaGVhZGUgPSAoX2hlYWRlckdyb3VwcyQgPSBoZWFkZXJHcm91cHNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyR3JvdXBzJC5oZWFkZXJzKSAhPSBudWxsID8gX2hlYWRlckdyb3VwcyQwJGhlYWRlIDogW10pO1xuICByZXR1cm4gaGVhZGVyR3JvdXBzO1xufVxuXG4vL1xuXG4vL1xuXG5jb25zdCBkZWZhdWx0Q29sdW1uU2l6aW5nID0ge1xuICBzaXplOiAxNTAsXG4gIG1pblNpemU6IDIwLFxuICBtYXhTaXplOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxufTtcbmNvbnN0IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUgPSAoKSA9PiAoe1xuICBzdGFydE9mZnNldDogbnVsbCxcbiAgc3RhcnRTaXplOiBudWxsLFxuICBkZWx0YU9mZnNldDogbnVsbCxcbiAgZGVsdGFQZXJjZW50YWdlOiBudWxsLFxuICBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSxcbiAgY29sdW1uU2l6aW5nU3RhcnQ6IFtdXG59KTtcbmNvbnN0IENvbHVtblNpemluZyA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiBkZWZhdWx0Q29sdW1uU2l6aW5nO1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uU2l6aW5nOiB7fSxcbiAgICAgIGNvbHVtblNpemluZ0luZm86IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uUmVzaXplTW9kZTogJ29uRW5kJyxcbiAgICAgIGNvbHVtblJlc2l6ZURpcmVjdGlvbjogJ2x0cicsXG4gICAgICBvbkNvbHVtblNpemluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uU2l6aW5nJywgdGFibGUpLFxuICAgICAgb25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5TaXppbmdJbmZvJywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJG1pbiwgX3JlZiwgX2NvbHVtbiRjb2x1bW5EZWYkbWF4O1xuICAgICAgY29uc3QgY29sdW1uU2l6ZSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nW2NvbHVtbi5pZF07XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoKF9jb2x1bW4kY29sdW1uRGVmJG1pbiA9IGNvbHVtbi5jb2x1bW5EZWYubWluU2l6ZSkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJG1pbiA6IGRlZmF1bHRDb2x1bW5TaXppbmcubWluU2l6ZSwgKF9yZWYgPSBjb2x1bW5TaXplICE9IG51bGwgPyBjb2x1bW5TaXplIDogY29sdW1uLmNvbHVtbkRlZi5zaXplKSAhPSBudWxsID8gX3JlZiA6IGRlZmF1bHRDb2x1bW5TaXppbmcuc2l6ZSksIChfY29sdW1uJGNvbHVtbkRlZiRtYXggPSBjb2x1bW4uY29sdW1uRGVmLm1heFNpemUpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRtYXggOiBkZWZhdWx0Q29sdW1uU2l6aW5nLm1heFNpemUpO1xuICAgIH07XG4gICAgY29sdW1uLmdldFN0YXJ0ID0gbWVtbyhwb3NpdGlvbiA9PiBbcG9zaXRpb24sIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmddLCAocG9zaXRpb24sIGNvbHVtbnMpID0+IGNvbHVtbnMuc2xpY2UoMCwgY29sdW1uLmdldEluZGV4KHBvc2l0aW9uKSkucmVkdWNlKChzdW0sIGNvbHVtbikgPT4gc3VtICsgY29sdW1uLmdldFNpemUoKSwgMCksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0U3RhcnQnKSk7XG4gICAgY29sdW1uLmdldEFmdGVyID0gbWVtbyhwb3NpdGlvbiA9PiBbcG9zaXRpb24sIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmddLCAocG9zaXRpb24sIGNvbHVtbnMpID0+IGNvbHVtbnMuc2xpY2UoY29sdW1uLmdldEluZGV4KHBvc2l0aW9uKSArIDEpLnJlZHVjZSgoc3VtLCBjb2x1bW4pID0+IHN1bSArIGNvbHVtbi5nZXRTaXplKCksIDApLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldEFmdGVyJykpO1xuICAgIGNvbHVtbi5yZXNldFNpemUgPSAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcoX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIFtjb2x1bW4uaWRdOiBfLFxuICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gcmVzdDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhblJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlUmVzaXppbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uUmVzaXppbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1Jlc2l6aW5nID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nSW5mby5pc1Jlc2l6aW5nQ29sdW1uID09PSBjb2x1bW4uaWQ7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlSGVhZGVyOiAoaGVhZGVyLCB0YWJsZSkgPT4ge1xuICAgIGhlYWRlci5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICBjb25zdCByZWN1cnNlID0gaGVhZGVyID0+IHtcbiAgICAgICAgaWYgKGhlYWRlci5zdWJIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGhlYWRlci5zdWJIZWFkZXJzLmZvckVhY2gocmVjdXJzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9oZWFkZXIkY29sdW1uJGdldFNpejtcbiAgICAgICAgICBzdW0gKz0gKF9oZWFkZXIkY29sdW1uJGdldFNpeiA9IGhlYWRlci5jb2x1bW4uZ2V0U2l6ZSgpKSAhPSBudWxsID8gX2hlYWRlciRjb2x1bW4kZ2V0U2l6IDogMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlY3Vyc2UoaGVhZGVyKTtcbiAgICAgIHJldHVybiBzdW07XG4gICAgfTtcbiAgICBoZWFkZXIuZ2V0U3RhcnQgPSAoKSA9PiB7XG4gICAgICBpZiAoaGVhZGVyLmluZGV4ID4gMCkge1xuICAgICAgICBjb25zdCBwcmV2U2libGluZ0hlYWRlciA9IGhlYWRlci5oZWFkZXJHcm91cC5oZWFkZXJzW2hlYWRlci5pbmRleCAtIDFdO1xuICAgICAgICByZXR1cm4gcHJldlNpYmxpbmdIZWFkZXIuZ2V0U3RhcnQoKSArIHByZXZTaWJsaW5nSGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgaGVhZGVyLmdldFJlc2l6ZUhhbmRsZXIgPSBfY29udGV4dERvY3VtZW50ID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihoZWFkZXIuY29sdW1uLmlkKTtcbiAgICAgIGNvbnN0IGNhblJlc2l6ZSA9IGNvbHVtbiA9PSBudWxsID8gdm9pZCAwIDogY29sdW1uLmdldENhblJlc2l6ZSgpO1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBpZiAoIWNvbHVtbiB8fCAhY2FuUmVzaXplKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xuICAgICAgICBpZiAoaXNUb3VjaFN0YXJ0RXZlbnQoZSkpIHtcbiAgICAgICAgICAvLyBsZXRzIG5vdCByZXNwb25kIHRvIG11bHRpcGxlIHRvdWNoZXMgKGUuZy4gMiBvciAzIGZpbmdlcnMpXG4gICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFNpemUgPSBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgICBjb25zdCBjb2x1bW5TaXppbmdTdGFydCA9IGhlYWRlciA/IGhlYWRlci5nZXRMZWFmSGVhZGVycygpLm1hcChkID0+IFtkLmNvbHVtbi5pZCwgZC5jb2x1bW4uZ2V0U2l6ZSgpXSkgOiBbW2NvbHVtbi5pZCwgY29sdW1uLmdldFNpemUoKV1dO1xuICAgICAgICBjb25zdCBjbGllbnRYID0gaXNUb3VjaFN0YXJ0RXZlbnQoZSkgPyBNYXRoLnJvdW5kKGUudG91Y2hlc1swXS5jbGllbnRYKSA6IGUuY2xpZW50WDtcbiAgICAgICAgY29uc3QgbmV3Q29sdW1uU2l6aW5nID0ge307XG4gICAgICAgIGNvbnN0IHVwZGF0ZU9mZnNldCA9IChldmVudFR5cGUsIGNsaWVudFhQb3MpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNsaWVudFhQb3MgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+IHtcbiAgICAgICAgICAgIHZhciBfb2xkJHN0YXJ0T2Zmc2V0LCBfb2xkJHN0YXJ0U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhRGlyZWN0aW9uID0gdGFibGUub3B0aW9ucy5jb2x1bW5SZXNpemVEaXJlY3Rpb24gPT09ICdydGwnID8gLTEgOiAxO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFPZmZzZXQgPSAoY2xpZW50WFBvcyAtICgoX29sZCRzdGFydE9mZnNldCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnN0YXJ0T2Zmc2V0KSAhPSBudWxsID8gX29sZCRzdGFydE9mZnNldCA6IDApKSAqIGRlbHRhRGlyZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFQZXJjZW50YWdlID0gTWF0aC5tYXgoZGVsdGFPZmZzZXQgLyAoKF9vbGQkc3RhcnRTaXplID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuc3RhcnRTaXplKSAhPSBudWxsID8gX29sZCRzdGFydFNpemUgOiAwKSwgLTAuOTk5OTk5KTtcbiAgICAgICAgICAgIG9sZC5jb2x1bW5TaXppbmdTdGFydC5mb3JFYWNoKF9yZWYzID0+IHtcbiAgICAgICAgICAgICAgbGV0IFtjb2x1bW5JZCwgaGVhZGVyU2l6ZV0gPSBfcmVmMztcbiAgICAgICAgICAgICAgbmV3Q29sdW1uU2l6aW5nW2NvbHVtbklkXSA9IE1hdGgucm91bmQoTWF0aC5tYXgoaGVhZGVyU2l6ZSArIGhlYWRlclNpemUgKiBkZWx0YVBlcmNlbnRhZ2UsIDApICogMTAwKSAvIDEwMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICBkZWx0YU9mZnNldCxcbiAgICAgICAgICAgICAgZGVsdGFQZXJjZW50YWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0YWJsZS5vcHRpb25zLmNvbHVtblJlc2l6ZU1vZGUgPT09ICdvbkNoYW5nZScgfHwgZXZlbnRUeXBlID09PSAnZW5kJykge1xuICAgICAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nKG9sZCA9PiAoe1xuICAgICAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgICAgIC4uLm5ld0NvbHVtblNpemluZ1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25Nb3ZlID0gY2xpZW50WFBvcyA9PiB1cGRhdGVPZmZzZXQoJ21vdmUnLCBjbGllbnRYUG9zKTtcbiAgICAgICAgY29uc3Qgb25FbmQgPSBjbGllbnRYUG9zID0+IHtcbiAgICAgICAgICB1cGRhdGVPZmZzZXQoJ2VuZCcsIGNsaWVudFhQb3MpO1xuICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+ICh7XG4gICAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgICBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBudWxsLFxuICAgICAgICAgICAgc3RhcnRTaXplOiBudWxsLFxuICAgICAgICAgICAgZGVsdGFPZmZzZXQ6IG51bGwsXG4gICAgICAgICAgICBkZWx0YVBlcmNlbnRhZ2U6IG51bGwsXG4gICAgICAgICAgICBjb2x1bW5TaXppbmdTdGFydDogW11cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnRleHREb2N1bWVudCA9IF9jb250ZXh0RG9jdW1lbnQgfHwgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbDtcbiAgICAgICAgY29uc3QgbW91c2VFdmVudHMgPSB7XG4gICAgICAgICAgbW92ZUhhbmRsZXI6IGUgPT4gb25Nb3ZlKGUuY2xpZW50WCksXG4gICAgICAgICAgdXBIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZUV2ZW50cy5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlRXZlbnRzLnVwSGFuZGxlcik7XG4gICAgICAgICAgICBvbkVuZChlLmNsaWVudFgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG91Y2hFdmVudHMgPSB7XG4gICAgICAgICAgbW92ZUhhbmRsZXI6IGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk1vdmUoZS50b3VjaGVzWzBdLmNsaWVudFgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIHZhciBfZSR0b3VjaGVzJDtcbiAgICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaEV2ZW50cy5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaEV2ZW50cy51cEhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkVuZCgoX2UkdG91Y2hlcyQgPSBlLnRvdWNoZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZSR0b3VjaGVzJC5jbGllbnRYKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhc3NpdmVJZlN1cHBvcnRlZCA9IHBhc3NpdmVFdmVudFN1cHBvcnRlZCgpID8ge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0gOiBmYWxzZTtcbiAgICAgICAgaWYgKGlzVG91Y2hTdGFydEV2ZW50KGUpKSB7XG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNoRXZlbnRzLm1vdmVIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoRXZlbnRzLnVwSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VFdmVudHMubW92ZUhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZUV2ZW50cy51cEhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhvbGQgPT4gKHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgc3RhcnRPZmZzZXQ6IGNsaWVudFgsXG4gICAgICAgICAgc3RhcnRTaXplLFxuICAgICAgICAgIGRlbHRhT2Zmc2V0OiAwLFxuICAgICAgICAgIGRlbHRhUGVyY2VudGFnZTogMCxcbiAgICAgICAgICBjb2x1bW5TaXppbmdTdGFydCxcbiAgICAgICAgICBpc1Jlc2l6aW5nQ29sdW1uOiBjb2x1bW4uaWRcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtblNpemluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0luZm9DaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5TaXppbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uU2l6aW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDoge30pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRIZWFkZXJTaXplSW5mbyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjMjtcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8oZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYzIgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uU2l6aW5nSW5mbykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYzIgOiBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRIZWFkZXJHcm91cCwgX3RhYmxlJGdldEhlYWRlckdyb3VwMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldEhlYWRlckdyb3VwID0gKF90YWJsZSRnZXRIZWFkZXJHcm91cDIgPSB0YWJsZS5nZXRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRIZWFkZXJHcm91cDIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0SGVhZGVyR3JvdXAgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0TGVmdFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0TGVmdEhlYWRlckcsIF90YWJsZSRnZXRMZWZ0SGVhZGVyRzI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRMZWZ0SGVhZGVyRyA9IChfdGFibGUkZ2V0TGVmdEhlYWRlckcyID0gdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldExlZnRIZWFkZXJHMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRMZWZ0SGVhZGVyRyA6IDA7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRDZW50ZXJUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldENlbnRlckhlYWRlLCBfdGFibGUkZ2V0Q2VudGVySGVhZGUyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0Q2VudGVySGVhZGUgPSAoX3RhYmxlJGdldENlbnRlckhlYWRlMiA9IHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENlbnRlckhlYWRlMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRDZW50ZXJIZWFkZSA6IDA7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRSaWdodFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0UmlnaHRIZWFkZXIsIF90YWJsZSRnZXRSaWdodEhlYWRlcjI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRSaWdodEhlYWRlciA9IChfdGFibGUkZ2V0UmlnaHRIZWFkZXIyID0gdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRSaWdodEhlYWRlcjIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0UmlnaHRIZWFkZXIgOiAwO1xuICAgIH07XG4gIH1cbn07XG5sZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IG51bGw7XG5mdW5jdGlvbiBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQoKSB7XG4gIGlmICh0eXBlb2YgcGFzc2l2ZVN1cHBvcnRlZCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbiAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgbm9vcCwgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBub29wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcGFzc2l2ZVN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbiAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59XG5mdW5jdGlvbiBpc1RvdWNoU3RhcnRFdmVudChlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0Jztcbn1cblxuLy9cblxuY29uc3QgRXhwYW5kaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwYW5kZWQ6IHt9LFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkV4cGFuZGVkQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdleHBhbmRlZCcsIHRhYmxlKSxcbiAgICAgIHBhZ2luYXRlRXhwYW5kZWRSb3dzOiB0cnVlXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICBsZXQgcmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGxldCBxdWV1ZWQgPSBmYWxzZTtcbiAgICB0YWJsZS5fYXV0b1Jlc2V0RXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX3RhYmxlJG9wdGlvbnMkYXV0b1JlO1xuICAgICAgaWYgKCFyZWdpc3RlcmVkKSB7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKF9yZWYgPSAoX3RhYmxlJG9wdGlvbnMkYXV0b1JlID0gdGFibGUub3B0aW9ucy5hdXRvUmVzZXRBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRhdXRvUmUgOiB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEV4cGFuZGVkKSAhPSBudWxsID8gX3JlZiA6ICF0YWJsZS5vcHRpb25zLm1hbnVhbEV4cGFuZGluZykge1xuICAgICAgICBpZiAocXVldWVkKSByZXR1cm47XG4gICAgICAgIHF1ZXVlZCA9IHRydWU7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgdGFibGUucmVzZXRFeHBhbmRlZCgpO1xuICAgICAgICAgIHF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhYmxlLnNldEV4cGFuZGVkID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uRXhwYW5kZWRDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25FeHBhbmRlZENoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS50b2dnbGVBbGxSb3dzRXhwYW5kZWQgPSBleHBhbmRlZCA9PiB7XG4gICAgICBpZiAoZXhwYW5kZWQgIT0gbnVsbCA/IGV4cGFuZGVkIDogIXRhYmxlLmdldElzQWxsUm93c0V4cGFuZGVkKCkpIHtcbiAgICAgICAgdGFibGUuc2V0RXhwYW5kZWQodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJsZS5zZXRFeHBhbmRlZCh7fSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldEV4cGFuZGVkID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGUsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRFeHBhbmRlZChkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGUgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuZXhwYW5kZWQpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGUgOiB7fSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRDYW5Tb21lUm93c0V4cGFuZCA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93cy5zb21lKHJvdyA9PiByb3cuZ2V0Q2FuRXhwYW5kKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgfHwgZS5wZXJzaXN0KCk7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCgpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZVJvd3NFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGFuZGVkID0gdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZDtcbiAgICAgIHJldHVybiBleHBhbmRlZCA9PT0gdHJ1ZSB8fCBPYmplY3QudmFsdWVzKGV4cGFuZGVkKS5zb21lKEJvb2xlYW4pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNBbGxSb3dzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XG5cbiAgICAgIC8vIElmIGV4cGFuZGVkIGlzIHRydWUsIHNhdmUgc29tZSBjeWNsZXMgYW5kIHJldHVybiB0cnVlXG4gICAgICBpZiAodHlwZW9mIGV4cGFuZGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkID09PSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFPYmplY3Qua2V5cyhleHBhbmRlZCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYW55IHJvdyBpcyBub3QgZXhwYW5kZWQsIHJldHVybiBmYWxzZVxuICAgICAgaWYgKHRhYmxlLmdldFJvd01vZGVsKCkuZmxhdFJvd3Muc29tZShyb3cgPT4gIXJvdy5nZXRJc0V4cGFuZGVkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhleSBtdXN0IGFsbCBiZSBleHBhbmRlZCA6c2hydWc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHRhYmxlLmdldEV4cGFuZGVkRGVwdGggPSAoKSA9PiB7XG4gICAgICBsZXQgbWF4RGVwdGggPSAwO1xuICAgICAgY29uc3Qgcm93SWRzID0gdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZCA9PT0gdHJ1ZSA/IE9iamVjdC5rZXlzKHRhYmxlLmdldFJvd01vZGVsKCkucm93c0J5SWQpIDogT2JqZWN0LmtleXModGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZCk7XG4gICAgICByb3dJZHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgIGNvbnN0IHNwbGl0SWQgPSBpZC5zcGxpdCgnLicpO1xuICAgICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBzcGxpdElkLmxlbmd0aCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXhEZXB0aDtcbiAgICB9O1xuICAgIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEV4cGFuZGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RXhwYW5kZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RXhwYW5kZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxFeHBhbmRpbmcgfHwgIXRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LnRvZ2dsZUV4cGFuZGVkID0gZXhwYW5kZWQgPT4ge1xuICAgICAgdGFibGUuc2V0RXhwYW5kZWQob2xkID0+IHtcbiAgICAgICAgdmFyIF9leHBhbmRlZDtcbiAgICAgICAgY29uc3QgZXhpc3RzID0gb2xkID09PSB0cnVlID8gdHJ1ZSA6ICEhKG9sZCAhPSBudWxsICYmIG9sZFtyb3cuaWRdKTtcbiAgICAgICAgbGV0IG9sZEV4cGFuZGVkID0ge307XG4gICAgICAgIGlmIChvbGQgPT09IHRydWUpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3NCeUlkKS5mb3JFYWNoKHJvd0lkID0+IHtcbiAgICAgICAgICAgIG9sZEV4cGFuZGVkW3Jvd0lkXSA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkRXhwYW5kZWQgPSBvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZXhwYW5kZWQgPSAoX2V4cGFuZGVkID0gZXhwYW5kZWQpICE9IG51bGwgPyBfZXhwYW5kZWQgOiAhZXhpc3RzO1xuICAgICAgICBpZiAoIWV4aXN0cyAmJiBleHBhbmRlZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5vbGRFeHBhbmRlZCxcbiAgICAgICAgICAgIFtyb3cuaWRdOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhpc3RzICYmICFleHBhbmRlZCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIFtyb3cuaWRdOiBfLFxuICAgICAgICAgICAgLi4ucmVzdFxuICAgICAgICAgIH0gPSBvbGRFeHBhbmRlZDtcbiAgICAgICAgICByZXR1cm4gcmVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2xkO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRnZXRJc1I7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XG4gICAgICByZXR1cm4gISEoKF90YWJsZSRvcHRpb25zJGdldElzUiA9IHRhYmxlLm9wdGlvbnMuZ2V0SXNSb3dFeHBhbmRlZCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRJc1Jvd0V4cGFuZGVkKHJvdykpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRJc1IgOiBleHBhbmRlZCA9PT0gdHJ1ZSB8fCAoZXhwYW5kZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGV4cGFuZGVkW3Jvdy5pZF0pKTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5FeHBhbmQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0Um93LCBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF9yb3ckc3ViUm93cztcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZ2V0Um93ID0gdGFibGUub3B0aW9ucy5nZXRSb3dDYW5FeHBhbmQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0Um93Q2FuRXhwYW5kKHJvdykpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRSb3cgOiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRXhwYW5kaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgISEoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGgpO1xuICAgIH07XG4gICAgcm93LmdldElzQWxsUGFyZW50c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgbGV0IGlzRnVsbHlFeHBhbmRlZCA9IHRydWU7XG4gICAgICBsZXQgY3VycmVudFJvdyA9IHJvdztcbiAgICAgIHdoaWxlIChpc0Z1bGx5RXhwYW5kZWQgJiYgY3VycmVudFJvdy5wYXJlbnRJZCkge1xuICAgICAgICBjdXJyZW50Um93ID0gdGFibGUuZ2V0Um93KGN1cnJlbnRSb3cucGFyZW50SWQsIHRydWUpO1xuICAgICAgICBpc0Z1bGx5RXhwYW5kZWQgPSBjdXJyZW50Um93LmdldElzRXhwYW5kZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bGx5RXhwYW5kZWQ7XG4gICAgfTtcbiAgICByb3cuZ2V0VG9nZ2xlRXhwYW5kZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuRXhwYW5kID0gcm93LmdldENhbkV4cGFuZCgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFjYW5FeHBhbmQpIHJldHVybjtcbiAgICAgICAgcm93LnRvZ2dsZUV4cGFuZGVkKCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IGluY2x1ZGVzU3RyaW5nID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlO1xuICBjb25zdCBzZWFyY2ggPSBmaWx0ZXJWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gQm9vbGVhbigoX3JvdyRnZXRWYWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUgPSBfcm93JGdldFZhbHVlLnRvU3RyaW5nKCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUgPSBfcm93JGdldFZhbHVlLnRvTG93ZXJDYXNlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlLmluY2x1ZGVzKHNlYXJjaCkpO1xufTtcbmluY2x1ZGVzU3RyaW5nLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgdmFyIF9yb3ckZ2V0VmFsdWUyO1xuICByZXR1cm4gQm9vbGVhbigoX3JvdyRnZXRWYWx1ZTIgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlMiA9IF9yb3ckZ2V0VmFsdWUyLnRvU3RyaW5nKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlMi5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSkpO1xufTtcbmluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgZXF1YWxzU3RyaW5nID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlMztcbiAgcmV0dXJuICgoX3JvdyRnZXRWYWx1ZTMgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlMyA9IF9yb3ckZ2V0VmFsdWUzLnRvU3RyaW5nKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlMy50b0xvd2VyQ2FzZSgpKSA9PT0gKGZpbHRlclZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBmaWx0ZXJWYWx1ZS50b0xvd2VyQ2FzZSgpKTtcbn07XG5lcXVhbHNTdHJpbmcuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBhcnJJbmNsdWRlcyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTQ7XG4gIHJldHVybiAoX3JvdyRnZXRWYWx1ZTQgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTQuaW5jbHVkZXMoZmlsdGVyVmFsdWUpO1xufTtcbmFyckluY2x1ZGVzLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8ICEodmFsICE9IG51bGwgJiYgdmFsLmxlbmd0aCk7XG5jb25zdCBhcnJJbmNsdWRlc0FsbCA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gIWZpbHRlclZhbHVlLnNvbWUodmFsID0+IHtcbiAgICB2YXIgX3JvdyRnZXRWYWx1ZTU7XG4gICAgcmV0dXJuICEoKF9yb3ckZ2V0VmFsdWU1ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCAmJiBfcm93JGdldFZhbHVlNS5pbmNsdWRlcyh2YWwpKTtcbiAgfSk7XG59O1xuYXJySW5jbHVkZXNBbGwuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgISh2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoKTtcbmNvbnN0IGFyckluY2x1ZGVzU29tZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gZmlsdGVyVmFsdWUuc29tZSh2YWwgPT4ge1xuICAgIHZhciBfcm93JGdldFZhbHVlNjtcbiAgICByZXR1cm4gKF9yb3ckZ2V0VmFsdWU2ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWU2LmluY2x1ZGVzKHZhbCk7XG4gIH0pO1xufTtcbmFyckluY2x1ZGVzU29tZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhKHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGgpO1xuY29uc3QgZXF1YWxzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID09PSBmaWx0ZXJWYWx1ZTtcbn07XG5lcXVhbHMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCB3ZWFrRXF1YWxzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID09IGZpbHRlclZhbHVlO1xufTtcbndlYWtFcXVhbHMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBpbk51bWJlclJhbmdlID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIGxldCBbbWluLCBtYXhdID0gZmlsdGVyVmFsdWU7XG4gIGNvbnN0IHJvd1ZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgcmV0dXJuIHJvd1ZhbHVlID49IG1pbiAmJiByb3dWYWx1ZSA8PSBtYXg7XG59O1xuaW5OdW1iZXJSYW5nZS5yZXNvbHZlRmlsdGVyVmFsdWUgPSB2YWwgPT4ge1xuICBsZXQgW3Vuc2FmZU1pbiwgdW5zYWZlTWF4XSA9IHZhbDtcbiAgbGV0IHBhcnNlZE1pbiA9IHR5cGVvZiB1bnNhZmVNaW4gIT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh1bnNhZmVNaW4pIDogdW5zYWZlTWluO1xuICBsZXQgcGFyc2VkTWF4ID0gdHlwZW9mIHVuc2FmZU1heCAhPT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHVuc2FmZU1heCkgOiB1bnNhZmVNYXg7XG4gIGxldCBtaW4gPSB1bnNhZmVNaW4gPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE1pbikgPyAtSW5maW5pdHkgOiBwYXJzZWRNaW47XG4gIGxldCBtYXggPSB1bnNhZmVNYXggPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE1heCkgPyBJbmZpbml0eSA6IHBhcnNlZE1heDtcbiAgaWYgKG1pbiA+IG1heCkge1xuICAgIGNvbnN0IHRlbXAgPSBtaW47XG4gICAgbWluID0gbWF4O1xuICAgIG1heCA9IHRlbXA7XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59O1xuaW5OdW1iZXJSYW5nZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCB0ZXN0RmFsc2V5KHZhbFswXSkgJiYgdGVzdEZhbHNleSh2YWxbMV0pO1xuXG4vLyBFeHBvcnRcblxuY29uc3QgZmlsdGVyRm5zID0ge1xuICBpbmNsdWRlc1N0cmluZyxcbiAgaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUsXG4gIGVxdWFsc1N0cmluZyxcbiAgYXJySW5jbHVkZXMsXG4gIGFyckluY2x1ZGVzQWxsLFxuICBhcnJJbmNsdWRlc1NvbWUsXG4gIGVxdWFscyxcbiAgd2Vha0VxdWFscyxcbiAgaW5OdW1iZXJSYW5nZVxufTtcbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIHRlc3RGYWxzZXkodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwgfHwgdmFsID09PSAnJztcbn1cblxuLy9cblxuY29uc3QgRmlsdGVycyA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBmaWx0ZXJGbjogJ2F1dG8nXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbkZpbHRlcnM6IFtdLFxuICAgICAgZ2xvYmFsRmlsdGVyOiB1bmRlZmluZWQsXG4gICAgICAvLyBmaWx0ZXJzUHJvZ3Jlc3M6IDEsXG4gICAgICAvLyBmYWNldFByb2dyZXNzOiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5GaWx0ZXJzQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5GaWx0ZXJzJywgdGFibGUpLFxuICAgICAgb25HbG9iYWxGaWx0ZXJDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2dsb2JhbEZpbHRlcicsIHRhYmxlKSxcbiAgICAgIGZpbHRlckZyb21MZWFmUm93czogZmFsc2UsXG4gICAgICBtYXhMZWFmUm93RmlsdGVyRGVwdGg6IDEwMCxcbiAgICAgIGdsb2JhbEZpbHRlckZuOiAnYXV0bycsXG4gICAgICBnZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXI6IGNvbHVtbiA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkZ2V0Q29yZVJvd01vZGU7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKF90YWJsZSRnZXRDb3JlUm93TW9kZSA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0Q29yZVJvd01vZGUgPSBfdGFibGUkZ2V0Q29yZVJvd01vZGUuX2dldEFsbENlbGxzQnlDb2x1bW5JZCgpW2NvbHVtbi5pZF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29yZVJvd01vZGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLmdldEF1dG9GaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkuZmxhdFJvd3NbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdFJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5pbmNsdWRlc1N0cmluZztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5OdW1iZXJSYW5nZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmVxdWFscztcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuZXF1YWxzO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuYXJySW5jbHVkZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlsdGVyRm5zLndlYWtFcXVhbHM7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0RmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZmlsdGVyLCBfdGFibGUkb3B0aW9ucyRmaWx0ZXIyO1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbikgPyBjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuIDogY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9GaWx0ZXJGbigpIDogLy8gQHRzLWlnbm9yZVxuICAgICAgKF90YWJsZSRvcHRpb25zJGZpbHRlciA9IChfdGFibGUkb3B0aW9ucyRmaWx0ZXIyID0gdGFibGUub3B0aW9ucy5maWx0ZXJGbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRmaWx0ZXIyW2NvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZmlsdGVyIDogZmlsdGVyRm5zW2NvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm5dO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbkZpbHRlciA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMjtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlQ29sdW1uRmlsdGVyKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtbkZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTIgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZSkgJiYgISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMywgX3RhYmxlJG9wdGlvbnMkZW5hYmxlNCwgX3RhYmxlJG9wdGlvbnMkZ2V0Q29sO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlR2xvYmFsRmlsdGVyKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlR2xvYmFsRmlsdGVyKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlNCA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTQgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGdldENvbCA9IHRhYmxlLm9wdGlvbnMuZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldENvbHVtbkNhbkdsb2JhbEZpbHRlcihjb2x1bW4pKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Q29sIDogdHJ1ZSkgJiYgISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc0ZpbHRlcmVkID0gKCkgPT4gY29sdW1uLmdldEZpbHRlckluZGV4KCkgPiAtMTtcbiAgICBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGNvbHVtO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMpID09IG51bGwgfHwgKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IF90YWJsZSRnZXRTdGF0ZSRjb2x1bS5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bS52YWx1ZTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRGaWx0ZXJJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW0yLCBfdGFibGUkZ2V0U3RhdGUkY29sdW0zO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTMgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0zLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCkpICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkY29sdW0yIDogLTE7XG4gICAgfTtcbiAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUgPSB2YWx1ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzKG9sZCA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKCk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzZmlsdGVyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICAgIGNvbnN0IG5ld0ZpbHRlciA9IGZ1bmN0aW9uYWxVcGRhdGUodmFsdWUsIHByZXZpb3VzZmlsdGVyID8gcHJldmlvdXNmaWx0ZXIudmFsdWUgOiB1bmRlZmluZWQpO1xuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlckZuLCBuZXdGaWx0ZXIsIGNvbHVtbikpIHtcbiAgICAgICAgICB2YXIgX29sZCRmaWx0ZXI7XG4gICAgICAgICAgcmV0dXJuIChfb2xkJGZpbHRlciA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbHRlcihkID0+IGQuaWQgIT09IGNvbHVtbi5pZCkpICE9IG51bGwgPyBfb2xkJGZpbHRlciA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0ZpbHRlck9iaiA9IHtcbiAgICAgICAgICBpZDogY29sdW1uLmlkLFxuICAgICAgICAgIHZhbHVlOiBuZXdGaWx0ZXJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByZXZpb3VzZmlsdGVyKSB7XG4gICAgICAgICAgdmFyIF9vbGQkbWFwO1xuICAgICAgICAgIHJldHVybiAoX29sZCRtYXAgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5tYXAoZCA9PiB7XG4gICAgICAgICAgICBpZiAoZC5pZCA9PT0gY29sdW1uLmlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXdGaWx0ZXJPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9KSkgIT0gbnVsbCA/IF9vbGQkbWFwIDogW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gWy4uLm9sZCwgbmV3RmlsdGVyT2JqXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25ld0ZpbHRlck9ial07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwodGFibGUsIGNvbHVtbi5pZCk7XG4gICAgY29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghY29sdW1uLl9nZXRGYWNldGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gICAgY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgY29sdW1uLmlkKTtcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzKCk7XG4gICAgfTtcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzKHRhYmxlLCBjb2x1bW4uaWQpO1xuICAgIGNvbHVtbi5nZXRGYWNldGVkTWluTWF4VmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKTtcbiAgICB9O1xuICAgIC8vICgpID0+IFtjb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsKCldLFxuICAgIC8vIGZhY2V0ZWRSb3dNb2RlbCA9PiBnZXRSb3dNb2RlbE1pbk1heFZhbHVlcyhmYWNldGVkUm93TW9kZWwsIGNvbHVtbi5pZCksXG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cuY29sdW1uRmlsdGVycyA9IHt9O1xuICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YSA9IHt9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLmdldEdsb2JhbEF1dG9GaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5jbHVkZXNTdHJpbmc7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRmaWx0ZXIzLCBfdGFibGUkb3B0aW9ucyRmaWx0ZXI0O1xuICAgICAgY29uc3Qge1xuICAgICAgICBnbG9iYWxGaWx0ZXJGbjogZ2xvYmFsRmlsdGVyRm5cbiAgICAgIH0gPSB0YWJsZS5vcHRpb25zO1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZ2xvYmFsRmlsdGVyRm4pID8gZ2xvYmFsRmlsdGVyRm4gOiBnbG9iYWxGaWx0ZXJGbiA9PT0gJ2F1dG8nID8gdGFibGUuZ2V0R2xvYmFsQXV0b0ZpbHRlckZuKCkgOiAvLyBAdHMtaWdub3JlXG4gICAgICAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyMyA9IChfdGFibGUkb3B0aW9ucyRmaWx0ZXI0ID0gdGFibGUub3B0aW9ucy5maWx0ZXJGbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRmaWx0ZXI0W2dsb2JhbEZpbHRlckZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGZpbHRlcjMgOiBmaWx0ZXJGbnNbZ2xvYmFsRmlsdGVyRm5dO1xuICAgIH07XG4gICAgdGFibGUuc2V0Q29sdW1uRmlsdGVycyA9IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3QgbGVhZkNvbHVtbnMgPSB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpO1xuICAgICAgY29uc3QgdXBkYXRlRm4gPSBvbGQgPT4ge1xuICAgICAgICB2YXIgX2Z1bmN0aW9uYWxVcGRhdGU7XG4gICAgICAgIHJldHVybiAoX2Z1bmN0aW9uYWxVcGRhdGUgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZCkpID09IG51bGwgPyB2b2lkIDAgOiBfZnVuY3Rpb25hbFVwZGF0ZS5maWx0ZXIoZmlsdGVyID0+IHtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gZmlsdGVyLmlkKTtcbiAgICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xuICAgICAgICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIGZpbHRlci52YWx1ZSwgY29sdW1uKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0YWJsZS5vcHRpb25zLm9uQ29sdW1uRmlsdGVyc0NoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25Db2x1bW5GaWx0ZXJzQ2hhbmdlKHVwZGF0ZUZuKTtcbiAgICB9O1xuICAgIHRhYmxlLnNldEdsb2JhbEZpbHRlciA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUub3B0aW9ucy5vbkdsb2JhbEZpbHRlckNoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25HbG9iYWxGaWx0ZXJDaGFuZ2UodXBkYXRlcik7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldEdsb2JhbEZpbHRlciA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRHbG9iYWxGaWx0ZXIoZGVmYXVsdFN0YXRlID8gdW5kZWZpbmVkIDogdGFibGUuaW5pdGlhbFN0YXRlLmdsb2JhbEZpbHRlcik7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldENvbHVtbkZpbHRlcnMgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmNvbHVtbkZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRGaWx0ZXJlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRGaWx0ZXJlZFJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEZpbHRlcmluZyB8fCAhdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gICAgdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsKHRhYmxlLCAnX19nbG9iYWxfXycpO1xuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEZpbHRlcmluZyB8fCAhdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzKCk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXModGFibGUsICdfX2dsb2JhbF9fJyk7XG4gICAgdGFibGUuZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzKCk7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIHZhbHVlLCBjb2x1bW4pIHtcbiAgcmV0dXJuIChmaWx0ZXJGbiAmJiBmaWx0ZXJGbi5hdXRvUmVtb3ZlID8gZmlsdGVyRm4uYXV0b1JlbW92ZSh2YWx1ZSwgY29sdW1uKSA6IGZhbHNlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIXZhbHVlO1xufVxuXG5jb25zdCBzdW0gPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIC8vIEl0J3MgZmFzdGVyIHRvIGp1c3QgYWRkIHRoZSBhZ2dyZWdhdGlvbnMgdG9nZXRoZXIgaW5zdGVhZCBvZlxuICAvLyBwcm9jZXNzIGxlYWYgbm9kZXMgaW5kaXZpZHVhbGx5XG4gIHJldHVybiBjaGlsZFJvd3MucmVkdWNlKChzdW0sIG5leHQpID0+IHtcbiAgICBjb25zdCBuZXh0VmFsdWUgPSBuZXh0LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICByZXR1cm4gc3VtICsgKHR5cGVvZiBuZXh0VmFsdWUgPT09ICdudW1iZXInID8gbmV4dFZhbHVlIDogMCk7XG4gIH0sIDApO1xufTtcbmNvbnN0IG1pbiA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1pbjtcbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKG1pbiA+IHZhbHVlIHx8IG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkge1xuICAgICAgbWluID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1pbjtcbn07XG5jb25zdCBtYXggPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIGxldCBtYXg7XG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIChtYXggPCB2YWx1ZSB8fCBtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpIHtcbiAgICAgIG1heCA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYXg7XG59O1xuY29uc3QgZXh0ZW50ID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICBsZXQgbWluO1xuICBsZXQgbWF4O1xuICBjaGlsZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSB2YWx1ZSkgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBbbWluLCBtYXhdO1xufTtcbmNvbnN0IG1lYW4gPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBzdW0gPSAwO1xuICBsZWFmUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgbGV0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICArK2NvdW50LCBzdW0gKz0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKGNvdW50KSByZXR1cm4gc3VtIC8gY291bnQ7XG4gIHJldHVybjtcbn07XG5jb25zdCBtZWRpYW4gPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIGlmICghbGVhZlJvd3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZhbHVlcyA9IGxlYWZSb3dzLm1hcChyb3cgPT4gcm93LmdldFZhbHVlKGNvbHVtbklkKSk7XG4gIGlmICghaXNOdW1iZXJBcnJheSh2YWx1ZXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgfVxuICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcbiAgY29uc3QgbnVtcyA9IHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIHJldHVybiB2YWx1ZXMubGVuZ3RoICUgMiAhPT0gMCA/IG51bXNbbWlkXSA6IChudW1zW21pZCAtIDFdICsgbnVtc1ttaWRdKSAvIDI7XG59O1xuY29uc3QgdW5pcXVlID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGxlYWZSb3dzLm1hcChkID0+IGQuZ2V0VmFsdWUoY29sdW1uSWQpKSkudmFsdWVzKCkpO1xufTtcbmNvbnN0IHVuaXF1ZUNvdW50ID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICByZXR1cm4gbmV3IFNldChsZWFmUm93cy5tYXAoZCA9PiBkLmdldFZhbHVlKGNvbHVtbklkKSkpLnNpemU7XG59O1xuY29uc3QgY291bnQgPSAoX2NvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICByZXR1cm4gbGVhZlJvd3MubGVuZ3RoO1xufTtcbmNvbnN0IGFnZ3JlZ2F0aW9uRm5zID0ge1xuICBzdW0sXG4gIG1pbixcbiAgbWF4LFxuICBleHRlbnQsXG4gIG1lYW4sXG4gIG1lZGlhbixcbiAgdW5pcXVlLFxuICB1bmlxdWVDb3VudCxcbiAgY291bnRcbn07XG5cbi8vXG5cbmNvbnN0IEdyb3VwaW5nID0ge1xuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFnZ3JlZ2F0ZWRDZWxsOiBwcm9wcyA9PiB7XG4gICAgICAgIHZhciBfdG9TdHJpbmcsIF9wcm9wcyRnZXRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIChfdG9TdHJpbmcgPSAoX3Byb3BzJGdldFZhbHVlID0gcHJvcHMuZ2V0VmFsdWUoKSkgPT0gbnVsbCB8fCBfcHJvcHMkZ2V0VmFsdWUudG9TdHJpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRnZXRWYWx1ZS50b1N0cmluZygpKSAhPSBudWxsID8gX3RvU3RyaW5nIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBhZ2dyZWdhdGlvbkZuOiAnYXV0bydcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ3JvdXBpbmc6IFtdLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkdyb3VwaW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdncm91cGluZycsIHRhYmxlKSxcbiAgICAgIGdyb3VwZWRDb2x1bW5Nb2RlOiAncmVvcmRlcidcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLnRvZ2dsZUdyb3VwaW5nID0gKCkgPT4ge1xuICAgICAgdGFibGUuc2V0R3JvdXBpbmcob2xkID0+IHtcbiAgICAgICAgLy8gRmluZCBhbnkgZXhpc3RpbmcgZ3JvdXBpbmcgZm9yIHRoaXMgY29sdW1uXG4gICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQuaW5jbHVkZXMoY29sdW1uLmlkKSkge1xuICAgICAgICAgIHJldHVybiBvbGQuZmlsdGVyKGQgPT4gZCAhPT0gY29sdW1uLmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWy4uLihvbGQgIT0gbnVsbCA/IG9sZCA6IFtdKSwgY29sdW1uLmlkXTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbkdyb3VwID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF9yZWYyLCBfcmVmMywgX2NvbHVtbiRjb2x1bW5EZWYkZW5hO1xuICAgICAgcmV0dXJuIChfcmVmID0gKF9yZWYyID0gKF9yZWYzID0gKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlR3JvdXBpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAhPSBudWxsID8gX3JlZjMgOiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nKSAhPSBudWxsID8gX3JlZjIgOiB0cnVlKSAhPSBudWxsID8gX3JlZiA6ICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNHcm91cGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRncm91cDtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGdyb3VwID0gdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRncm91cC5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgIH07XG4gICAgY29sdW1uLmdldEdyb3VwZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyID0gdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRncm91cDIuaW5kZXhPZihjb2x1bW4uaWQpO1xuICAgIH07XG4gICAgY29sdW1uLmdldFRvZ2dsZUdyb3VwaW5nSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbkdyb3VwID0gY29sdW1uLmdldENhbkdyb3VwKCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbkdyb3VwKSByZXR1cm47XG4gICAgICAgIGNvbHVtbi50b2dnbGVHcm91cGluZygpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBdXRvQWdncmVnYXRpb25GbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkuZmxhdFJvd3NbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdFJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0aW9uRm5zLnN1bTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0aW9uRm5zLmV4dGVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBZ2dyZWdhdGlvbkZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGFnZ3JlZywgX3RhYmxlJG9wdGlvbnMkYWdncmVnMjtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA6IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9BZ2dyZWdhdGlvbkZuKCkgOiAoX3RhYmxlJG9wdGlvbnMkYWdncmVnID0gKF90YWJsZSRvcHRpb25zJGFnZ3JlZzIgPSB0YWJsZS5vcHRpb25zLmFnZ3JlZ2F0aW9uRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkYWdncmVnMltjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYWdncmVnIDogYWdncmVnYXRpb25GbnNbY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuXTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldEdyb3VwaW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uR3JvdXBpbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Hcm91cGluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldEdyb3VwaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGcsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRHcm91cGluZyhkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGcgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuZ3JvdXBpbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGcgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0R3JvdXBlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0R3JvdXBlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0R3JvdXBlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEdyb3VwZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxHcm91cGluZyB8fCAhdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cuZ2V0SXNHcm91cGVkID0gKCkgPT4gISFyb3cuZ3JvdXBpbmdDb2x1bW5JZDtcbiAgICByb3cuZ2V0R3JvdXBpbmdWYWx1ZSA9IGNvbHVtbklkID0+IHtcbiAgICAgIGlmIChyb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgICB9XG4gICAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRHcm91cGluZ1ZhbHVlKHJvdy5vcmlnaW5hbCk7XG4gICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9O1xuICAgIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZSA9IHt9O1xuICB9LFxuICBjcmVhdGVDZWxsOiAoY2VsbCwgY29sdW1uLCByb3csIHRhYmxlKSA9PiB7XG4gICAgY2VsbC5nZXRJc0dyb3VwZWQgPSAoKSA9PiBjb2x1bW4uZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uLmlkID09PSByb3cuZ3JvdXBpbmdDb2x1bW5JZDtcbiAgICBjZWxsLmdldElzUGxhY2Vob2xkZXIgPSAoKSA9PiAhY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiBjb2x1bW4uZ2V0SXNHcm91cGVkKCk7XG4gICAgY2VsbC5nZXRJc0FnZ3JlZ2F0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzO1xuICAgICAgcmV0dXJuICFjZWxsLmdldElzR3JvdXBlZCgpICYmICFjZWxsLmdldElzUGxhY2Vob2xkZXIoKSAmJiAhISgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCk7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG9yZGVyQ29sdW1ucyhsZWFmQ29sdW1ucywgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKSB7XG4gIGlmICghKGdyb3VwaW5nICE9IG51bGwgJiYgZ3JvdXBpbmcubGVuZ3RoKSB8fCAhZ3JvdXBlZENvbHVtbk1vZGUpIHtcbiAgICByZXR1cm4gbGVhZkNvbHVtbnM7XG4gIH1cbiAgY29uc3Qgbm9uR3JvdXBpbmdDb2x1bW5zID0gbGVhZkNvbHVtbnMuZmlsdGVyKGNvbCA9PiAhZ3JvdXBpbmcuaW5jbHVkZXMoY29sLmlkKSk7XG4gIGlmIChncm91cGVkQ29sdW1uTW9kZSA9PT0gJ3JlbW92ZScpIHtcbiAgICByZXR1cm4gbm9uR3JvdXBpbmdDb2x1bW5zO1xuICB9XG4gIGNvbnN0IGdyb3VwaW5nQ29sdW1ucyA9IGdyb3VwaW5nLm1hcChnID0+IGxlYWZDb2x1bW5zLmZpbmQoY29sID0+IGNvbC5pZCA9PT0gZykpLmZpbHRlcihCb29sZWFuKTtcbiAgcmV0dXJuIFsuLi5ncm91cGluZ0NvbHVtbnMsIC4uLm5vbkdyb3VwaW5nQ29sdW1uc107XG59XG5cbi8vXG5cbmNvbnN0IE9yZGVyaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uT3JkZXI6IFtdLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtbk9yZGVyQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5PcmRlcicsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0SW5kZXggPSBtZW1vKHBvc2l0aW9uID0+IFtfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbildLCBjb2x1bW5zID0+IGNvbHVtbnMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRJbmRleCcpKTtcbiAgICBjb2x1bW4uZ2V0SXNGaXJzdENvbHVtbiA9IHBvc2l0aW9uID0+IHtcbiAgICAgIHZhciBfY29sdW1ucyQ7XG4gICAgICBjb25zdCBjb2x1bW5zID0gX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbnMkID0gY29sdW1uc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb2x1bW5zJC5pZCkgPT09IGNvbHVtbi5pZDtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc0xhc3RDb2x1bW4gPSBwb3NpdGlvbiA9PiB7XG4gICAgICB2YXIgX2NvbHVtbnM7XG4gICAgICBjb25zdCBjb2x1bW5zID0gX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbnMgPSBjb2x1bW5zW2NvbHVtbnMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfY29sdW1ucy5pZCkgPT09IGNvbHVtbi5pZDtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtbk9yZGVyID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uT3JkZXJDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5PcmRlckNoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtbk9yZGVyID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5PcmRlcihkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uT3JkZXIpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4gPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbk9yZGVyLCB0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nLCB0YWJsZS5vcHRpb25zLmdyb3VwZWRDb2x1bW5Nb2RlXSwgKGNvbHVtbk9yZGVyLCBncm91cGluZywgZ3JvdXBlZENvbHVtbk1vZGUpID0+IGNvbHVtbnMgPT4ge1xuICAgICAgLy8gU29ydCBncm91cGVkIGNvbHVtbnMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb2x1bW4gbGlzdFxuICAgICAgLy8gYmVmb3JlIHRoZSBoZWFkZXJzIGFyZSBidWlsdFxuICAgICAgbGV0IG9yZGVyZWRDb2x1bW5zID0gW107XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG9yZGVyLCByZXR1cm4gdGhlIG5vcm1hbCBjb2x1bW5zXG4gICAgICBpZiAoIShjb2x1bW5PcmRlciAhPSBudWxsICYmIGNvbHVtbk9yZGVyLmxlbmd0aCkpIHtcbiAgICAgICAgb3JkZXJlZENvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29sdW1uT3JkZXJDb3B5ID0gWy4uLmNvbHVtbk9yZGVyXTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBvcmRlciwgbWFrZSBhIGNvcHkgb2YgdGhlIGNvbHVtbnNcbiAgICAgICAgY29uc3QgY29sdW1uc0NvcHkgPSBbLi4uY29sdW1uc107XG5cbiAgICAgICAgLy8gQW5kIG1ha2UgYSBuZXcgb3JkZXJlZCBhcnJheSBvZiB0aGUgY29sdW1uc1xuXG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgY29sdW1ucyBhbmQgcGxhY2UgdGhlbSBpbiBvcmRlciBpbnRvIHRoZSBuZXcgYXJyYXlcbiAgICAgICAgd2hpbGUgKGNvbHVtbnNDb3B5Lmxlbmd0aCAmJiBjb2x1bW5PcmRlckNvcHkubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uSWQgPSBjb2x1bW5PcmRlckNvcHkuc2hpZnQoKTtcbiAgICAgICAgICBjb25zdCBmb3VuZEluZGV4ID0gY29sdW1uc0NvcHkuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gdGFyZ2V0Q29sdW1uSWQpO1xuICAgICAgICAgIGlmIChmb3VuZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIG9yZGVyZWRDb2x1bW5zLnB1c2goY29sdW1uc0NvcHkuc3BsaWNlKGZvdW5kSW5kZXgsIDEpWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGNvbHVtbnMgbGVmdCwgYWRkIHRoZW0gdG8gdGhlIGVuZFxuICAgICAgICBvcmRlcmVkQ29sdW1ucyA9IFsuLi5vcmRlcmVkQ29sdW1ucywgLi4uY29sdW1uc0NvcHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhvcmRlcmVkQ29sdW1ucywgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdfZ2V0T3JkZXJDb2x1bW5zRm4nKSk7XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IGRlZmF1bHRQYWdlSW5kZXggPSAwO1xuY29uc3QgZGVmYXVsdFBhZ2VTaXplID0gMTA7XG5jb25zdCBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlID0gKCkgPT4gKHtcbiAgcGFnZUluZGV4OiBkZWZhdWx0UGFnZUluZGV4LFxuICBwYWdlU2l6ZTogZGVmYXVsdFBhZ2VTaXplXG59KTtcbmNvbnN0IFBhZ2luYXRpb24gPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgLi4uZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSgpLFxuICAgICAgICAuLi4oc3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLnBhZ2luYXRpb24pXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25QYWdpbmF0aW9uQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdwYWdpbmF0aW9uJywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICBsZXQgcmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGxldCBxdWV1ZWQgPSBmYWxzZTtcbiAgICB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF90YWJsZSRvcHRpb25zJGF1dG9SZTtcbiAgICAgIGlmICghcmVnaXN0ZXJlZCkge1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGF1dG9SZSA9IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0QWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYXV0b1JlIDogdGFibGUub3B0aW9ucy5hdXRvUmVzZXRQYWdlSW5kZXgpICE9IG51bGwgPyBfcmVmIDogIXRhYmxlLm9wdGlvbnMubWFudWFsUGFnaW5hdGlvbikge1xuICAgICAgICBpZiAocXVldWVkKSByZXR1cm47XG4gICAgICAgIHF1ZXVlZCA9IHRydWU7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgdGFibGUucmVzZXRQYWdlSW5kZXgoKTtcbiAgICAgICAgICBxdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0YWJsZS5zZXRQYWdpbmF0aW9uID0gdXBkYXRlciA9PiB7XG4gICAgICBjb25zdCBzYWZlVXBkYXRlciA9IG9sZCA9PiB7XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkKTtcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLm9uUGFnaW5hdGlvbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblBhZ2luYXRpb25DaGFuZ2Uoc2FmZVVwZGF0ZXIpO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRQYWdpbmF0aW9uID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHA7XG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAgPSB0YWJsZS5pbml0aWFsU3RhdGUucGFnaW5hdGlvbikgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcCA6IGdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRQYWdlSW5kZXggPSB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLnNldFBhZ2luYXRpb24ob2xkID0+IHtcbiAgICAgICAgbGV0IHBhZ2VJbmRleCA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkLnBhZ2VJbmRleCk7XG4gICAgICAgIGNvbnN0IG1heFBhZ2VJbmRleCA9IHR5cGVvZiB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPT09IC0xID8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCAtIDE7XG4gICAgICAgIHBhZ2VJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VJbmRleCwgbWF4UGFnZUluZGV4KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIHBhZ2VJbmRleFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldFBhZ2VJbmRleCA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiwgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldFBhZ2VJbmRleChkZWZhdWx0U3RhdGUgPyBkZWZhdWx0UGFnZUluZGV4IDogKF90YWJsZSRpbml0aWFsU3RhdGUkcDIgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCB8fCAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IF90YWJsZSRpbml0aWFsU3RhdGUucGFnaW5hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUucGFnZUluZGV4KSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiA6IGRlZmF1bHRQYWdlSW5kZXgpO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRQYWdlU2l6ZSA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRwMywgX3RhYmxlJGluaXRpYWxTdGF0ZTI7XG4gICAgICB0YWJsZS5zZXRQYWdlU2l6ZShkZWZhdWx0U3RhdGUgPyBkZWZhdWx0UGFnZVNpemUgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRwMyA9IChfdGFibGUkaW5pdGlhbFN0YXRlMiA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCB8fCAoX3RhYmxlJGluaXRpYWxTdGF0ZTIgPSBfdGFibGUkaW5pdGlhbFN0YXRlMi5wYWdpbmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZTIucGFnZVNpemUpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHAzIDogZGVmYXVsdFBhZ2VTaXplKTtcbiAgICB9O1xuICAgIHRhYmxlLnNldFBhZ2VTaXplID0gdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKG9sZCA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2VTaXplID0gTWF0aC5tYXgoMSwgZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQucGFnZVNpemUpKTtcbiAgICAgICAgY29uc3QgdG9wUm93SW5kZXggPSBvbGQucGFnZVNpemUgKiBvbGQucGFnZUluZGV4O1xuICAgICAgICBjb25zdCBwYWdlSW5kZXggPSBNYXRoLmZsb29yKHRvcFJvd0luZGV4IC8gcGFnZVNpemUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBwYWdlSW5kZXgsXG4gICAgICAgICAgcGFnZVNpemVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLy9kZXByZWNhdGVkXG4gICAgdGFibGUuc2V0UGFnZUNvdW50ID0gdXBkYXRlciA9PiB0YWJsZS5zZXRQYWdpbmF0aW9uKG9sZCA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkcGFnZUNvO1xuICAgICAgbGV0IG5ld1BhZ2VDb3VudCA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgKF90YWJsZSRvcHRpb25zJHBhZ2VDbyA9IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkcGFnZUNvIDogLTEpO1xuICAgICAgaWYgKHR5cGVvZiBuZXdQYWdlQ291bnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5ld1BhZ2VDb3VudCA9IE1hdGgubWF4KC0xLCBuZXdQYWdlQ291bnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub2xkLFxuICAgICAgICBwYWdlQ291bnQ6IG5ld1BhZ2VDb3VudFxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0YWJsZS5nZXRQYWdlT3B0aW9ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFBhZ2VDb3VudCgpXSwgcGFnZUNvdW50ID0+IHtcbiAgICAgIGxldCBwYWdlT3B0aW9ucyA9IFtdO1xuICAgICAgaWYgKHBhZ2VDb3VudCAmJiBwYWdlQ291bnQgPiAwKSB7XG4gICAgICAgIHBhZ2VPcHRpb25zID0gWy4uLm5ldyBBcnJheShwYWdlQ291bnQpXS5maWxsKG51bGwpLm1hcCgoXywgaSkgPT4gaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFnZU9wdGlvbnM7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0UGFnZU9wdGlvbnMnKSk7XG4gICAgdGFibGUuZ2V0Q2FuUHJldmlvdXNQYWdlID0gKCkgPT4gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLnBhZ2VJbmRleCA+IDA7XG4gICAgdGFibGUuZ2V0Q2FuTmV4dFBhZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZ2VJbmRleFxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkucGFnaW5hdGlvbjtcbiAgICAgIGNvbnN0IHBhZ2VDb3VudCA9IHRhYmxlLmdldFBhZ2VDb3VudCgpO1xuICAgICAgaWYgKHBhZ2VDb3VudCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocGFnZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWdlSW5kZXggPCBwYWdlQ291bnQgLSAxO1xuICAgIH07XG4gICAgdGFibGUucHJldmlvdXNQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleChvbGQgPT4gb2xkIC0gMSk7XG4gICAgfTtcbiAgICB0YWJsZS5uZXh0UGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgob2xkID0+IHtcbiAgICAgICAgcmV0dXJuIG9sZCArIDE7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLmZpcnN0UGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgoMCk7XG4gICAgfTtcbiAgICB0YWJsZS5sYXN0UGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgodGFibGUuZ2V0UGFnZUNvdW50KCkgLSAxKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldEV4cGFuZGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRQYWdpbmF0aW9uUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0UGFnaW5hdGlvblJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbFBhZ2luYXRpb24gfHwgIXRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFBhZ2VDb3VudCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRwYWdlQ28yO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRwYWdlQ28yID0gdGFibGUub3B0aW9ucy5wYWdlQ291bnQpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRwYWdlQ28yIDogTWF0aC5jZWlsKHRhYmxlLmdldFJvd0NvdW50KCkgLyB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24ucGFnZVNpemUpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0Um93Q291bnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkcm93Q291O1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRyb3dDb3UgPSB0YWJsZS5vcHRpb25zLnJvd0NvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkcm93Q291IDogdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkucm93cy5sZW5ndGg7XG4gICAgfTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSA9ICgpID0+ICh7XG4gIGxlZnQ6IFtdLFxuICByaWdodDogW11cbn0pO1xuY29uc3QgZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSA9ICgpID0+ICh7XG4gIHRvcDogW10sXG4gIGJvdHRvbTogW11cbn0pO1xuY29uc3QgUGlubmluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblBpbm5pbmc6IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUoKSxcbiAgICAgIHJvd1Bpbm5pbmc6IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUoKSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5QaW5uaW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5QaW5uaW5nJywgdGFibGUpLFxuICAgICAgb25Sb3dQaW5uaW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdyb3dQaW5uaW5nJywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5waW4gPSBwb3NpdGlvbiA9PiB7XG4gICAgICBjb25zdCBjb2x1bW5JZHMgPSBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKS5tYXAoZCA9PiBkLmlkKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5QaW5uaW5nKG9sZCA9PiB7XG4gICAgICAgIHZhciBfb2xkJGxlZnQzLCBfb2xkJHJpZ2h0MztcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdmFyIF9vbGQkbGVmdCwgX29sZCRyaWdodDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogKChfb2xkJGxlZnQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5sZWZ0KSAhPSBudWxsID8gX29sZCRsZWZ0IDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksXG4gICAgICAgICAgICByaWdodDogWy4uLigoX29sZCRyaWdodCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnJpZ2h0KSAhPSBudWxsID8gX29sZCRyaWdodCA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLCAuLi5jb2x1bW5JZHNdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHZhciBfb2xkJGxlZnQyLCBfb2xkJHJpZ2h0MjtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogWy4uLigoX29sZCRsZWZ0MiA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmxlZnQpICE9IG51bGwgPyBfb2xkJGxlZnQyIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksIC4uLmNvbHVtbklkc10sXG4gICAgICAgICAgICByaWdodDogKChfb2xkJHJpZ2h0MiA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnJpZ2h0KSAhPSBudWxsID8gX29sZCRyaWdodDIgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiAoKF9vbGQkbGVmdDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5sZWZ0KSAhPSBudWxsID8gX29sZCRsZWZ0MyA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLFxuICAgICAgICAgIHJpZ2h0OiAoKF9vbGQkcmlnaHQzID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQucmlnaHQpICE9IG51bGwgPyBfb2xkJHJpZ2h0MyA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5QaW4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBsZWFmQ29sdW1ucyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpO1xuICAgICAgcmV0dXJuIGxlYWZDb2x1bW5zLnNvbWUoZCA9PiB7XG4gICAgICAgIHZhciBfZCRjb2x1bW5EZWYkZW5hYmxlUGksIF9yZWYsIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgICAgcmV0dXJuICgoX2QkY29sdW1uRGVmJGVuYWJsZVBpID0gZC5jb2x1bW5EZWYuZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IF9kJGNvbHVtbkRlZiRlbmFibGVQaSA6IHRydWUpICYmICgoX3JlZiA9IChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblBpbm5pbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0YWJsZS5vcHRpb25zLmVuYWJsZVBpbm5pbmcpICE9IG51bGwgPyBfcmVmIDogdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1Bpbm5lZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZDb2x1bW5JZHMgPSBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKS5tYXAoZCA9PiBkLmlkKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHRcbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmc7XG4gICAgICBjb25zdCBpc0xlZnQgPSBsZWFmQ29sdW1uSWRzLnNvbWUoZCA9PiBsZWZ0ID09IG51bGwgPyB2b2lkIDAgOiBsZWZ0LmluY2x1ZGVzKGQpKTtcbiAgICAgIGNvbnN0IGlzUmlnaHQgPSBsZWFmQ29sdW1uSWRzLnNvbWUoZCA9PiByaWdodCA9PSBudWxsID8gdm9pZCAwIDogcmlnaHQuaW5jbHVkZXMoZCkpO1xuICAgICAgcmV0dXJuIGlzTGVmdCA/ICdsZWZ0JyA6IGlzUmlnaHQgPyAncmlnaHQnIDogZmFsc2U7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0UGlubmVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGNvbHVtLCBfdGFibGUkZ2V0U3RhdGUkY29sdW0yO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBjb2x1bW4uZ2V0SXNQaW5uZWQoKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA/IChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZykgPT0gbnVsbCB8fCAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA9IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTJbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtMi5pbmRleE9mKGNvbHVtbi5pZCkpICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkY29sdW0gOiAtMSA6IDA7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy5waW4gPSAocG9zaXRpb24sIGluY2x1ZGVMZWFmUm93cywgaW5jbHVkZVBhcmVudFJvd3MpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZSb3dJZHMgPSBpbmNsdWRlTGVhZlJvd3MgPyByb3cuZ2V0TGVhZlJvd3MoKS5tYXAoX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSkgOiBbXTtcbiAgICAgIGNvbnN0IHBhcmVudFJvd0lkcyA9IGluY2x1ZGVQYXJlbnRSb3dzID8gcm93LmdldFBhcmVudFJvd3MoKS5tYXAoX3JlZjMgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmMztcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSkgOiBbXTtcbiAgICAgIGNvbnN0IHJvd0lkcyA9IG5ldyBTZXQoWy4uLnBhcmVudFJvd0lkcywgcm93LmlkLCAuLi5sZWFmUm93SWRzXSk7XG4gICAgICB0YWJsZS5zZXRSb3dQaW5uaW5nKG9sZCA9PiB7XG4gICAgICAgIHZhciBfb2xkJHRvcDMsIF9vbGQkYm90dG9tMztcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHZhciBfb2xkJHRvcCwgX29sZCRib3R0b207XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogKChfb2xkJHRvcCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnRvcCkgIT0gbnVsbCA/IF9vbGQkdG9wIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLFxuICAgICAgICAgICAgYm90dG9tOiBbLi4uKChfb2xkJGJvdHRvbSA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmJvdHRvbSkgIT0gbnVsbCA/IF9vbGQkYm90dG9tIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLCAuLi5BcnJheS5mcm9tKHJvd0lkcyldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgdmFyIF9vbGQkdG9wMiwgX29sZCRib3R0b20yO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IFsuLi4oKF9vbGQkdG9wMiA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnRvcCkgIT0gbnVsbCA/IF9vbGQkdG9wMiA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSwgLi4uQXJyYXkuZnJvbShyb3dJZHMpXSxcbiAgICAgICAgICAgIGJvdHRvbTogKChfb2xkJGJvdHRvbTIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5ib3R0b20pICE9IG51bGwgPyBfb2xkJGJvdHRvbTIgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiAoKF9vbGQkdG9wMyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnRvcCkgIT0gbnVsbCA/IF9vbGQkdG9wMyA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSxcbiAgICAgICAgICBib3R0b206ICgoX29sZCRib3R0b20zID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20zIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5QaW4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZjQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVuYWJsZVJvd1Bpbm5pbmcsXG4gICAgICAgIGVuYWJsZVBpbm5pbmdcbiAgICAgIH0gPSB0YWJsZS5vcHRpb25zO1xuICAgICAgaWYgKHR5cGVvZiBlbmFibGVSb3dQaW5uaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBlbmFibGVSb3dQaW5uaW5nKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF9yZWY0ID0gZW5hYmxlUm93UGlubmluZyAhPSBudWxsID8gZW5hYmxlUm93UGlubmluZyA6IGVuYWJsZVBpbm5pbmcpICE9IG51bGwgPyBfcmVmNCA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNQaW5uZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCByb3dJZHMgPSBbcm93LmlkXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdG9wLFxuICAgICAgICBib3R0b21cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmc7XG4gICAgICBjb25zdCBpc1RvcCA9IHJvd0lkcy5zb21lKGQgPT4gdG9wID09IG51bGwgPyB2b2lkIDAgOiB0b3AuaW5jbHVkZXMoZCkpO1xuICAgICAgY29uc3QgaXNCb3R0b20gPSByb3dJZHMuc29tZShkID0+IGJvdHRvbSA9PSBudWxsID8gdm9pZCAwIDogYm90dG9tLmluY2x1ZGVzKGQpKTtcbiAgICAgIHJldHVybiBpc1RvcCA/ICd0b3AnIDogaXNCb3R0b20gPyAnYm90dG9tJyA6IGZhbHNlO1xuICAgIH07XG4gICAgcm93LmdldFBpbm5lZEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRfZ2V0UGlubmVkUm93cywgX3Zpc2libGVQaW5uZWRSb3dJZHMkO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSByb3cuZ2V0SXNQaW5uZWQoKTtcbiAgICAgIGlmICghcG9zaXRpb24pIHJldHVybiAtMTtcbiAgICAgIGNvbnN0IHZpc2libGVQaW5uZWRSb3dJZHMgPSAoX3RhYmxlJF9nZXRQaW5uZWRSb3dzID0gdGFibGUuX2dldFBpbm5lZFJvd3MocG9zaXRpb24pKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJF9nZXRQaW5uZWRSb3dzLm1hcChfcmVmNSA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IF9yZWY1O1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoX3Zpc2libGVQaW5uZWRSb3dJZHMkID0gdmlzaWJsZVBpbm5lZFJvd0lkcyA9PSBudWxsID8gdm9pZCAwIDogdmlzaWJsZVBpbm5lZFJvd0lkcy5pbmRleE9mKHJvdy5pZCkpICE9IG51bGwgPyBfdmlzaWJsZVBpbm5lZFJvd0lkcyQgOiAtMTtcbiAgICB9O1xuICAgIHJvdy5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuX2dldEFsbFZpc2libGVDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENlbGxzLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgY29uc3QgbGVmdEFuZFJpZ2h0ID0gWy4uLihsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLCAuLi4ocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pXTtcbiAgICAgIHJldHVybiBhbGxDZWxscy5maWx0ZXIoZCA9PiAhbGVmdEFuZFJpZ2h0LmluY2x1ZGVzKGQuY29sdW1uLmlkKSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRDZW50ZXJWaXNpYmxlQ2VsbHMnKSk7XG4gICAgcm93LmdldExlZnRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuX2dldEFsbFZpc2libGVDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDZWxscywgbGVmdCkgPT4ge1xuICAgICAgY29uc3QgY2VsbHMgPSAobGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKS5tYXAoY29sdW1uSWQgPT4gYWxsQ2VsbHMuZmluZChjZWxsID0+IGNlbGwuY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKS5tYXAoZCA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICBwb3NpdGlvbjogJ2xlZnQnXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRMZWZ0VmlzaWJsZUNlbGxzJykpO1xuICAgIHJvdy5nZXRSaWdodFZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDZWxscywgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGNlbGxzID0gKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKS5tYXAoY29sdW1uSWQgPT4gYWxsQ2VsbHMuZmluZChjZWxsID0+IGNlbGwuY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKS5tYXAoZCA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0J1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0UmlnaHRWaXNpYmxlQ2VsbHMnKSk7XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Q29sdW1uUGlubmluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblBpbm5pbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5QaW5uaW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uUGlubmluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldENvbHVtblBpbm5pbmcoZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5jb2x1bW5QaW5uaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZUNvbHVtbnNQaW5uZWQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvO1xuICAgICAgY29uc3QgcGlubmluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSRsZWZ0LCBfcGlubmluZ1N0YXRlJHJpZ2h0O1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoKF9waW5uaW5nU3RhdGUkbGVmdCA9IHBpbm5pbmdTdGF0ZS5sZWZ0KSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRsZWZ0Lmxlbmd0aCkgfHwgKChfcGlubmluZ1N0YXRlJHJpZ2h0ID0gcGlubmluZ1N0YXRlLnJpZ2h0KSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRyaWdodC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCb29sZWFuKChfcGlubmluZ1N0YXRlJHBvc2l0aW8gPSBwaW5uaW5nU3RhdGVbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvLmxlbmd0aCk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRMZWZ0TGVhZkNvbHVtbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDb2x1bW5zLCBsZWZ0KSA9PiB7XG4gICAgICByZXR1cm4gKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENvbHVtbnMuZmluZChjb2x1bW4gPT4gY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldExlZnRMZWFmQ29sdW1ucycpKTtcbiAgICB0YWJsZS5nZXRSaWdodExlYWZDb2x1bW5zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIHJpZ2h0KSA9PiB7XG4gICAgICByZXR1cm4gKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKS5tYXAoY29sdW1uSWQgPT4gYWxsQ29sdW1ucy5maW5kKGNvbHVtbiA9PiBjb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0UmlnaHRMZWFmQ29sdW1ucycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJMZWFmQ29sdW1ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGxlZnRBbmRSaWdodCA9IFsuLi4obGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKSwgLi4uKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKV07XG4gICAgICByZXR1cm4gYWxsQ29sdW1ucy5maWx0ZXIoZCA9PiAhbGVmdEFuZFJpZ2h0LmluY2x1ZGVzKGQuaWQpKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldENlbnRlckxlYWZDb2x1bW5zJykpO1xuICAgIHRhYmxlLnNldFJvd1Bpbm5pbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Sb3dQaW5uaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uUm93UGlubmluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldFJvd1Bpbm5pbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkciwgX3RhYmxlJGluaXRpYWxTdGF0ZTI7XG4gICAgICByZXR1cm4gdGFibGUuc2V0Um93UGlubmluZyhkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRyID0gKF90YWJsZSRpbml0aWFsU3RhdGUyID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZTIucm93UGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkciA6IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzUGlubmVkID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9waW5uaW5nU3RhdGUkcG9zaXRpbzI7XG4gICAgICBjb25zdCBwaW5uaW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmc7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfcGlubmluZ1N0YXRlJHRvcCwgX3Bpbm5pbmdTdGF0ZSRib3R0b207XG4gICAgICAgIHJldHVybiBCb29sZWFuKCgoX3Bpbm5pbmdTdGF0ZSR0b3AgPSBwaW5uaW5nU3RhdGUudG9wKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSR0b3AubGVuZ3RoKSB8fCAoKF9waW5uaW5nU3RhdGUkYm90dG9tID0gcGlubmluZ1N0YXRlLmJvdHRvbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkYm90dG9tLmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4oKF9waW5uaW5nU3RhdGUkcG9zaXRpbzIgPSBwaW5uaW5nU3RhdGVbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvMi5sZW5ndGgpO1xuICAgIH07XG4gICAgdGFibGUuX2dldFBpbm5lZFJvd3MgPSBtZW1vKHBvc2l0aW9uID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZ1twb3NpdGlvbl0sIHBvc2l0aW9uXSwgKHZpc2libGVSb3dzLCBwaW5uZWRSb3dJZHMsIHBvc2l0aW9uKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMka2VlcFBpO1xuICAgICAgY29uc3Qgcm93cyA9ICgoX3RhYmxlJG9wdGlvbnMka2VlcFBpID0gdGFibGUub3B0aW9ucy5rZWVwUGlubmVkUm93cykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGtlZXBQaSA6IHRydWUpID9cbiAgICAgIC8vZ2V0IGFsbCByb3dzIHRoYXQgYXJlIHBpbm5lZCBldmVuIGlmIHRoZXkgd291bGQgbm90IGJlIG90aGVyd2lzZSB2aXNpYmxlXG4gICAgICAvL2FjY291bnQgZm9yIGV4cGFuZGVkIHBhcmVudCByb3dzLCBidXQgbm90IHBhZ2luYXRpb24gb3IgZmlsdGVyaW5nXG4gICAgICAocGlubmVkUm93SWRzICE9IG51bGwgPyBwaW5uZWRSb3dJZHMgOiBbXSkubWFwKHJvd0lkID0+IHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGFibGUuZ2V0Um93KHJvd0lkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJvdy5nZXRJc0FsbFBhcmVudHNFeHBhbmRlZCgpID8gcm93IDogbnVsbDtcbiAgICAgIH0pIDpcbiAgICAgIC8vZWxzZSBnZXQgb25seSB2aXNpYmxlIHJvd3MgdGhhdCBhcmUgcGlubmVkXG4gICAgICAocGlubmVkUm93SWRzICE9IG51bGwgPyBwaW5uZWRSb3dJZHMgOiBbXSkubWFwKHJvd0lkID0+IHZpc2libGVSb3dzLmZpbmQocm93ID0+IHJvdy5pZCA9PT0gcm93SWQpKTtcbiAgICAgIHJldHVybiByb3dzLmZpbHRlcihCb29sZWFuKS5tYXAoZCA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICBwb3NpdGlvblxuICAgICAgfSkpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnX2dldFBpbm5lZFJvd3MnKSk7XG4gICAgdGFibGUuZ2V0VG9wUm93cyA9ICgpID0+IHRhYmxlLl9nZXRQaW5uZWRSb3dzKCd0b3AnKTtcbiAgICB0YWJsZS5nZXRCb3R0b21Sb3dzID0gKCkgPT4gdGFibGUuX2dldFBpbm5lZFJvd3MoJ2JvdHRvbScpO1xuICAgIHRhYmxlLmdldENlbnRlclJvd3MgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy50b3AsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy5ib3R0b21dLCAoYWxsUm93cywgdG9wLCBib3R0b20pID0+IHtcbiAgICAgIGNvbnN0IHRvcEFuZEJvdHRvbSA9IG5ldyBTZXQoWy4uLih0b3AgIT0gbnVsbCA/IHRvcCA6IFtdKSwgLi4uKGJvdHRvbSAhPSBudWxsID8gYm90dG9tIDogW10pXSk7XG4gICAgICByZXR1cm4gYWxsUm93cy5maWx0ZXIoZCA9PiAhdG9wQW5kQm90dG9tLmhhcyhkLmlkKSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRDZW50ZXJSb3dzJykpO1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBSb3dTZWxlY3Rpb24gPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByb3dTZWxlY3Rpb246IHt9LFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvblJvd1NlbGVjdGlvbkNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncm93U2VsZWN0aW9uJywgdGFibGUpLFxuICAgICAgZW5hYmxlUm93U2VsZWN0aW9uOiB0cnVlLFxuICAgICAgZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb246IHRydWUsXG4gICAgICBlbmFibGVTdWJSb3dTZWxlY3Rpb246IHRydWVcbiAgICAgIC8vIGVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uOiBmYWxzZSxcbiAgICAgIC8vIGlzQWRkaXRpdmVTZWxlY3RFdmVudDogKGU6IHVua25vd24pID0+ICEhZS5tZXRhS2V5LFxuICAgICAgLy8gaXNJbmNsdXNpdmVTZWxlY3RFdmVudDogKGU6IHVua25vd24pID0+ICEhZS5zaGlmdEtleSxcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbiA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vblJvd1NlbGVjdGlvbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblJvd1NlbGVjdGlvbkNoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldFJvd1NlbGVjdGlvbiA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRyO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFJvd1NlbGVjdGlvbihkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHIgPSB0YWJsZS5pbml0aWFsU3RhdGUucm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRyIDoge30pO1xuICAgIH07XG4gICAgdGFibGUudG9nZ2xlQWxsUm93c1NlbGVjdGVkID0gdmFsdWUgPT4ge1xuICAgICAgdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIXRhYmxlLmdldElzQWxsUm93c1NlbGVjdGVkKCk7XG4gICAgICAgIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHtcbiAgICAgICAgICAuLi5vbGRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJlR3JvdXBlZEZsYXRSb3dzID0gdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKCkuZmxhdFJvd3M7XG5cbiAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIGBtdXRhdGVSb3dJc1NlbGVjdGVkYCBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxuICAgICAgICAvLyBBbGwgb2YgdGhlIHJvd3MgYXJlIGZsYXQgYWxyZWFkeSwgc28gaXQgd291bGRuJ3QgYmUgd29ydGggaXRcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcHJlR3JvdXBlZEZsYXRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIGlmICghcm93LmdldENhblNlbGVjdCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd1NlbGVjdGlvbltyb3cuaWRdID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmVHcm91cGVkRmxhdFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHJvd1NlbGVjdGlvbltyb3cuaWRdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dTZWxlY3Rpb247XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLnRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQgPSB2YWx1ZSA9PiB0YWJsZS5zZXRSb3dTZWxlY3Rpb24ob2xkID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkKCk7XG4gICAgICBjb25zdCByb3dTZWxlY3Rpb24gPSB7XG4gICAgICAgIC4uLm9sZFxuICAgICAgfTtcbiAgICAgIHRhYmxlLmdldFJvd01vZGVsKCkucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgIG11dGF0ZVJvd0lzU2VsZWN0ZWQocm93U2VsZWN0aW9uLCByb3cuaWQsIHJlc29sdmVkVmFsdWUsIHRydWUsIHRhYmxlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJvd1NlbGVjdGlvbjtcbiAgICB9KTtcblxuICAgIC8vIGFkZFJvd1NlbGVjdGlvblJhbmdlOiByb3dJZCA9PiB7XG4gICAgLy8gICBjb25zdCB7XG4gICAgLy8gICAgIHJvd3MsXG4gICAgLy8gICAgIHJvd3NCeUlkLFxuICAgIC8vICAgICBvcHRpb25zOiB7IHNlbGVjdEdyb3VwaW5nUm93cywgc2VsZWN0U3ViUm93cyB9LFxuICAgIC8vICAgfSA9IHRhYmxlXG5cbiAgICAvLyAgIGNvbnN0IGZpbmRTZWxlY3RlZFJvdyA9IChyb3dzOiBSb3dbXSkgPT4ge1xuICAgIC8vICAgICBsZXQgZm91bmRcbiAgICAvLyAgICAgcm93cy5maW5kKGQgPT4ge1xuICAgIC8vICAgICAgIGlmIChkLmdldElzU2VsZWN0ZWQoKSkge1xuICAgIC8vICAgICAgICAgZm91bmQgPSBkXG4gICAgLy8gICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgICBjb25zdCBzdWJGb3VuZCA9IGZpbmRTZWxlY3RlZFJvdyhkLnN1YlJvd3MgfHwgW10pXG4gICAgLy8gICAgICAgaWYgKHN1YkZvdW5kKSB7XG4gICAgLy8gICAgICAgICBmb3VuZCA9IHN1YkZvdW5kXG4gICAgLy8gICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgICByZXR1cm4gZmFsc2VcbiAgICAvLyAgICAgfSlcbiAgICAvLyAgICAgcmV0dXJuIGZvdW5kXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIGNvbnN0IGZpcnN0Um93ID0gZmluZFNlbGVjdGVkUm93KHJvd3MpIHx8IHJvd3NbMF1cbiAgICAvLyAgIGNvbnN0IGxhc3RSb3cgPSByb3dzQnlJZFtyb3dJZF1cblxuICAgIC8vICAgbGV0IGluY2x1ZGUgPSBmYWxzZVxuICAgIC8vICAgY29uc3Qgc2VsZWN0ZWRSb3dJZHMgPSB7fVxuXG4gICAgLy8gICBjb25zdCBhZGRSb3cgPSAocm93OiBSb3cpID0+IHtcbiAgICAvLyAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB0cnVlLCB7XG4gICAgLy8gICAgICAgcm93c0J5SWQsXG4gICAgLy8gICAgICAgc2VsZWN0R3JvdXBpbmdSb3dzOiBzZWxlY3RHcm91cGluZ1Jvd3MhLFxuICAgIC8vICAgICAgIHNlbGVjdFN1YlJvd3M6IHNlbGVjdFN1YlJvd3MhLFxuICAgIC8vICAgICB9KVxuICAgIC8vICAgfVxuXG4gICAgLy8gICB0YWJsZS5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAvLyAgICAgY29uc3QgaXNGaXJzdFJvdyA9IHJvdy5pZCA9PT0gZmlyc3RSb3cuaWRcbiAgICAvLyAgICAgY29uc3QgaXNMYXN0Um93ID0gcm93LmlkID09PSBsYXN0Um93LmlkXG5cbiAgICAvLyAgICAgaWYgKGlzRmlyc3RSb3cgfHwgaXNMYXN0Um93KSB7XG4gICAgLy8gICAgICAgaWYgKCFpbmNsdWRlKSB7XG4gICAgLy8gICAgICAgICBpbmNsdWRlID0gdHJ1ZVxuICAgIC8vICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZSkge1xuICAgIC8vICAgICAgICAgYWRkUm93KHJvdylcbiAgICAvLyAgICAgICAgIGluY2x1ZGUgPSBmYWxzZVxuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgfVxuXG4gICAgLy8gICAgIGlmIChpbmNsdWRlKSB7XG4gICAgLy8gICAgICAgYWRkUm93KHJvdylcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfSlcblxuICAgIC8vICAgdGFibGUuc2V0Um93U2VsZWN0aW9uKHNlbGVjdGVkUm93SWRzKVxuICAgIC8vIH0sXG4gICAgdGFibGUuZ2V0UHJlU2VsZWN0ZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldFNlbGVjdGVkUm93TW9kZWwgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgdGFibGUuZ2V0Q29yZVJvd01vZGVsKCldLCAocm93U2VsZWN0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgICAgICByb3dzQnlJZDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRTZWxlY3RlZFJvd01vZGVsJykpO1xuICAgIHRhYmxlLmdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCldLCAocm93U2VsZWN0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgICAgICByb3dzQnlJZDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwnKSk7XG4gICAgdGFibGUuZ2V0R3JvdXBlZFNlbGVjdGVkUm93TW9kZWwgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgdGFibGUuZ2V0U29ydGVkUm93TW9kZWwoKV0sIChyb3dTZWxlY3Rpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsJykpO1xuXG4gICAgLy8vXG5cbiAgICAvLyBnZXRHcm91cGluZ1Jvd0NhblNlbGVjdDogcm93SWQgPT4ge1xuICAgIC8vICAgY29uc3Qgcm93ID0gdGFibGUuZ2V0Um93KHJvd0lkKVxuXG4gICAgLy8gICBpZiAoIXJvdykge1xuICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICAgIC8vICAgfVxuXG4gICAgLy8gICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24ocm93KVxuICAgIC8vICAgfVxuXG4gICAgLy8gICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbiA/PyBmYWxzZVxuICAgIC8vIH0sXG5cbiAgICB0YWJsZS5nZXRJc0FsbFJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHByZUdyb3VwZWRGbGF0Um93cyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIGxldCBpc0FsbFJvd3NTZWxlY3RlZCA9IEJvb2xlYW4ocHJlR3JvdXBlZEZsYXRSb3dzLmxlbmd0aCAmJiBPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCk7XG4gICAgICBpZiAoaXNBbGxSb3dzU2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHByZUdyb3VwZWRGbGF0Um93cy5zb21lKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkgJiYgIXJvd1NlbGVjdGlvbltyb3cuaWRdKSkge1xuICAgICAgICAgIGlzQWxsUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FsbFJvd3NTZWxlY3RlZDtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25GbGF0Um93cyA9IHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzLmZpbHRlcihyb3cgPT4gcm93LmdldENhblNlbGVjdCgpKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIGxldCBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSAhIXBhZ2luYXRpb25GbGF0Um93cy5sZW5ndGg7XG4gICAgICBpZiAoaXNBbGxQYWdlUm93c1NlbGVjdGVkICYmIHBhZ2luYXRpb25GbGF0Um93cy5zb21lKHJvdyA9PiAhcm93U2VsZWN0aW9uW3Jvdy5pZF0pKSB7XG4gICAgICAgIGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQWxsUGFnZVJvd3NTZWxlY3RlZDtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkcm93U2U7XG4gICAgICBjb25zdCB0b3RhbFNlbGVjdGVkID0gT2JqZWN0LmtleXMoKF90YWJsZSRnZXRTdGF0ZSRyb3dTZSA9IHRhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJHJvd1NlIDoge30pLmxlbmd0aDtcbiAgICAgIHJldHVybiB0b3RhbFNlbGVjdGVkID4gMCAmJiB0b3RhbFNlbGVjdGVkIDwgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzLmxlbmd0aDtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZVBhZ2VSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwYWdpbmF0aW9uRmxhdFJvd3MgPSB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93cztcbiAgICAgIHJldHVybiB0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQoKSA/IGZhbHNlIDogcGFnaW5hdGlvbkZsYXRSb3dzLmZpbHRlcihyb3cgPT4gcm93LmdldENhblNlbGVjdCgpKS5zb21lKGQgPT4gZC5nZXRJc1NlbGVjdGVkKCkgfHwgZC5nZXRJc1NvbWVTZWxlY3RlZCgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy50b2dnbGVTZWxlY3RlZCA9ICh2YWx1ZSwgb3B0cykgPT4ge1xuICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHJvdy5nZXRJc1NlbGVjdGVkKCk7XG4gICAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24ob2xkID0+IHtcbiAgICAgICAgdmFyIF9vcHRzJHNlbGVjdENoaWxkcmVuO1xuICAgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICFpc1NlbGVjdGVkO1xuICAgICAgICBpZiAocm93LmdldENhblNlbGVjdCgpICYmIGlzU2VsZWN0ZWQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3RlZFJvd0lkcyA9IHtcbiAgICAgICAgICAuLi5vbGRcbiAgICAgICAgfTtcbiAgICAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB2YWx1ZSwgKF9vcHRzJHNlbGVjdENoaWxkcmVuID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5zZWxlY3RDaGlsZHJlbikgIT0gbnVsbCA/IF9vcHRzJHNlbGVjdENoaWxkcmVuIDogdHJ1ZSwgdGFibGUpO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRSb3dJZHM7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGlzUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pO1xuICAgIH07XG4gICAgcm93LmdldElzU29tZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGlzU3ViUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pID09PSAnc29tZSc7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNBbGxTdWJSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gaXNTdWJSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbikgPT09ICdhbGwnO1xuICAgIH07XG4gICAgcm93LmdldENhblNlbGVjdCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbihyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuU2VsZWN0U3ViUm93cyA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xuICAgICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24ocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuTXVsdGlTZWxlY3QgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMztcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbihyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUzID0gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTMgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldFRvZ2dsZVNlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhblNlbGVjdCA9IHJvdy5nZXRDYW5TZWxlY3QoKTtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdmFyIF90YXJnZXQ7XG4gICAgICAgIGlmICghY2FuU2VsZWN0KSByZXR1cm47XG4gICAgICAgIHJvdy50b2dnbGVTZWxlY3RlZCgoX3RhcmdldCA9IGUudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IG11dGF0ZVJvd0lzU2VsZWN0ZWQgPSAoc2VsZWN0ZWRSb3dJZHMsIGlkLCB2YWx1ZSwgaW5jbHVkZUNoaWxkcmVuLCB0YWJsZSkgPT4ge1xuICB2YXIgX3JvdyRzdWJSb3dzO1xuICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3coaWQsIHRydWUpO1xuXG4gIC8vIGNvbnN0IGlzR3JvdXBlZCA9IHJvdy5nZXRJc0dyb3VwZWQoKVxuXG4gIC8vIGlmICggLy8gVE9ETzogZW5mb3JjZSBncm91cGluZyByb3cgc2VsZWN0aW9uIHJ1bGVzXG4gIC8vICAgIWlzR3JvdXBlZCB8fFxuICAvLyAgIChpc0dyb3VwZWQgJiYgdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbilcbiAgLy8gKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghcm93LmdldENhbk11bHRpU2VsZWN0KCkpIHtcbiAgICAgIE9iamVjdC5rZXlzKHNlbGVjdGVkUm93SWRzKS5mb3JFYWNoKGtleSA9PiBkZWxldGUgc2VsZWN0ZWRSb3dJZHNba2V5XSk7XG4gICAgfVxuICAgIGlmIChyb3cuZ2V0Q2FuU2VsZWN0KCkpIHtcbiAgICAgIHNlbGVjdGVkUm93SWRzW2lkXSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBzZWxlY3RlZFJvd0lkc1tpZF07XG4gIH1cbiAgLy8gfVxuXG4gIGlmIChpbmNsdWRlQ2hpbGRyZW4gJiYgKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgcm93LmdldENhblNlbGVjdFN1YlJvd3MoKSkge1xuICAgIHJvdy5zdWJSb3dzLmZvckVhY2gocm93ID0+IG11dGF0ZVJvd0lzU2VsZWN0ZWQoc2VsZWN0ZWRSb3dJZHMsIHJvdy5pZCwgdmFsdWUsIGluY2x1ZGVDaGlsZHJlbiwgdGFibGUpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpIHtcbiAgY29uc3Qgcm93U2VsZWN0aW9uID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb247XG4gIGNvbnN0IG5ld1NlbGVjdGVkRmxhdFJvd3MgPSBbXTtcbiAgY29uc3QgbmV3U2VsZWN0ZWRSb3dzQnlJZCA9IHt9O1xuXG4gIC8vIEZpbHRlcnMgdG9wIGxldmVsIGFuZCBuZXN0ZWQgcm93c1xuICBjb25zdCByZWN1cnNlUm93cyA9IGZ1bmN0aW9uIChyb3dzLCBkZXB0aCkge1xuICAgIHJldHVybiByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgdmFyIF9yb3ckc3ViUm93czI7XG4gICAgICBjb25zdCBpc1NlbGVjdGVkID0gaXNSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbik7XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICBuZXdTZWxlY3RlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgbmV3U2VsZWN0ZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgfVxuICAgICAgaWYgKChfcm93JHN1YlJvd3MyID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzMi5sZW5ndGgpIHtcbiAgICAgICAgcm93ID0ge1xuICAgICAgICAgIC4uLnJvdyxcbiAgICAgICAgICBzdWJSb3dzOiByZWN1cnNlUm93cyhyb3cuc3ViUm93cylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgICB9XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJvd3M6IHJlY3Vyc2VSb3dzKHJvd01vZGVsLnJvd3MpLFxuICAgIGZsYXRSb3dzOiBuZXdTZWxlY3RlZEZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiBuZXdTZWxlY3RlZFJvd3NCeUlkXG4gIH07XG59XG5mdW5jdGlvbiBpc1Jvd1NlbGVjdGVkKHJvdywgc2VsZWN0aW9uKSB7XG4gIHZhciBfc2VsZWN0aW9uJHJvdyRpZDtcbiAgcmV0dXJuIChfc2VsZWN0aW9uJHJvdyRpZCA9IHNlbGVjdGlvbltyb3cuaWRdKSAhPSBudWxsID8gX3NlbGVjdGlvbiRyb3ckaWQgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU3ViUm93U2VsZWN0ZWQocm93LCBzZWxlY3Rpb24sIHRhYmxlKSB7XG4gIHZhciBfcm93JHN1YlJvd3MzO1xuICBpZiAoISgoX3JvdyRzdWJSb3dzMyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93czMubGVuZ3RoKSkgcmV0dXJuIGZhbHNlO1xuICBsZXQgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IHRydWU7XG4gIGxldCBzb21lU2VsZWN0ZWQgPSBmYWxzZTtcbiAgcm93LnN1YlJvd3MuZm9yRWFjaChzdWJSb3cgPT4ge1xuICAgIC8vIEJhaWwgb3V0IGVhcmx5IGlmIHdlIGtub3cgYm90aCBvZiB0aGVzZVxuICAgIGlmIChzb21lU2VsZWN0ZWQgJiYgIWFsbENoaWxkcmVuU2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN1YlJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgaWYgKGlzUm93U2VsZWN0ZWQoc3ViUm93LCBzZWxlY3Rpb24pKSB7XG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgcm93IHNlbGVjdGlvbiBvZiBuZXN0ZWQgc3Vicm93c1xuICAgIGlmIChzdWJSb3cuc3ViUm93cyAmJiBzdWJSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQgPSBpc1N1YlJvd1NlbGVjdGVkKHN1YlJvdywgc2VsZWN0aW9uKTtcbiAgICAgIGlmIChzdWJSb3dDaGlsZHJlblNlbGVjdGVkID09PSAnYWxsJykge1xuICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdWJSb3dDaGlsZHJlblNlbGVjdGVkID09PSAnc29tZScpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhbGxDaGlsZHJlblNlbGVjdGVkID8gJ2FsbCcgOiBzb21lU2VsZWN0ZWQgPyAnc29tZScgOiBmYWxzZTtcbn1cblxuY29uc3QgcmVTcGxpdEFscGhhTnVtZXJpYyA9IC8oWzAtOV0rKS9nbTtcbmNvbnN0IGFscGhhbnVtZXJpYyA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUFscGhhbnVtZXJpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCkpO1xufTtcbmNvbnN0IGFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmUgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVBbHBoYW51bWVyaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkpO1xufTtcblxuLy8gVGhlIHRleHQgZmlsdGVyIGlzIG1vcmUgYmFzaWMgKGxlc3MgbnVtZXJpYyBzdXBwb3J0KVxuLy8gYnV0IGlzIG11Y2ggZmFzdGVyXG5jb25zdCB0ZXh0ID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQmFzaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpKTtcbn07XG5cbi8vIFRoZSB0ZXh0IGZpbHRlciBpcyBtb3JlIGJhc2ljIChsZXNzIG51bWVyaWMgc3VwcG9ydClcbi8vIGJ1dCBpcyBtdWNoIGZhc3RlclxuY29uc3QgdGV4dENhc2VTZW5zaXRpdmUgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKSk7XG59O1xuY29uc3QgZGF0ZXRpbWUgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgY29uc3QgYSA9IHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICBjb25zdCBiID0gcm93Qi5nZXRWYWx1ZShjb2x1bW5JZCk7XG5cbiAgLy8gQ2FuIGhhbmRsZSBudWxsaXNoIHZhbHVlc1xuICAvLyBVc2UgPiBhbmQgPCBiZWNhdXNlID09IChhbmQgPT09KSBkb2Vzbid0IHdvcmsgd2l0aFxuICAvLyBEYXRlIG9iamVjdHMgKHdvdWxkIHJlcXVpcmUgY2FsbGluZyBnZXRUaW1lKCkpLlxuICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG59O1xuY29uc3QgYmFzaWMgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSwgcm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpO1xufTtcblxuLy8gVXRpbHNcblxuZnVuY3Rpb24gY29tcGFyZUJhc2ljKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG59XG5mdW5jdGlvbiB0b1N0cmluZyhhKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoaXNOYU4oYSkgfHwgYSA9PT0gSW5maW5pdHkgfHwgYSA9PT0gLUluZmluaXR5KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLy8gTWl4ZWQgc29ydGluZyBpcyBzbG93LCBidXQgdmVyeSBpbmNsdXNpdmUgb2YgbWFueSBlZGdlIGNhc2VzLlxuLy8gSXQgaGFuZGxlcyBudW1iZXJzLCBtaXhlZCBhbHBoYW51bWVyaWMgY29tYmluYXRpb25zLCBhbmQgZXZlblxuLy8gbnVsbCwgdW5kZWZpbmVkLCBhbmQgSW5maW5pdHlcbmZ1bmN0aW9uIGNvbXBhcmVBbHBoYW51bWVyaWMoYVN0ciwgYlN0cikge1xuICAvLyBTcGxpdCBvbiBudW1iZXIgZ3JvdXBzLCBidXQga2VlcCB0aGUgZGVsaW1pdGVyXG4gIC8vIFRoZW4gcmVtb3ZlIGZhbHNleSBzcGxpdCB2YWx1ZXNcbiAgY29uc3QgYSA9IGFTdHIuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBiID0gYlN0ci5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgLy8gV2hpbGVcbiAgd2hpbGUgKGEubGVuZ3RoICYmIGIubGVuZ3RoKSB7XG4gICAgY29uc3QgYWEgPSBhLnNoaWZ0KCk7XG4gICAgY29uc3QgYmIgPSBiLnNoaWZ0KCk7XG4gICAgY29uc3QgYW4gPSBwYXJzZUludChhYSwgMTApO1xuICAgIGNvbnN0IGJuID0gcGFyc2VJbnQoYmIsIDEwKTtcbiAgICBjb25zdCBjb21ibyA9IFthbiwgYm5dLnNvcnQoKTtcblxuICAgIC8vIEJvdGggYXJlIHN0cmluZ1xuICAgIGlmIChpc05hTihjb21ib1swXSkpIHtcbiAgICAgIGlmIChhYSA+IGJiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKGJiID4gYWEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gT25lIGlzIGEgc3RyaW5nLCBvbmUgaXMgYSBudW1iZXJcbiAgICBpZiAoaXNOYU4oY29tYm9bMV0pKSB7XG4gICAgICByZXR1cm4gaXNOYU4oYW4pID8gLTEgOiAxO1xuICAgIH1cblxuICAgIC8vIEJvdGggYXJlIG51bWJlcnNcbiAgICBpZiAoYW4gPiBibikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChibiA+IGFuKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xufVxuXG4vLyBFeHBvcnRzXG5cbmNvbnN0IHNvcnRpbmdGbnMgPSB7XG4gIGFscGhhbnVtZXJpYyxcbiAgYWxwaGFudW1lcmljQ2FzZVNlbnNpdGl2ZSxcbiAgdGV4dCxcbiAgdGV4dENhc2VTZW5zaXRpdmUsXG4gIGRhdGV0aW1lLFxuICBiYXNpY1xufTtcblxuLy9cblxuY29uc3QgU29ydGluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvcnRpbmc6IFtdLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvcnRpbmdGbjogJ2F1dG8nLFxuICAgICAgc29ydFVuZGVmaW5lZDogMVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uU29ydGluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignc29ydGluZycsIHRhYmxlKSxcbiAgICAgIGlzTXVsdGlTb3J0RXZlbnQ6IGUgPT4ge1xuICAgICAgICByZXR1cm4gZS5zaGlmdEtleTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLmdldEF1dG9Tb3J0aW5nRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvd3MgPSB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3Muc2xpY2UoMTApO1xuICAgICAgbGV0IGlzU3RyaW5nID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiBmaXJzdFJvd3MpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMuZGF0ZXRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpc1N0cmluZyA9IHRydWU7XG4gICAgICAgICAgaWYgKHZhbHVlLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0aW5nRm5zLmFscGhhbnVtZXJpYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICByZXR1cm4gc29ydGluZ0Zucy50ZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNvcnRpbmdGbnMuYmFzaWM7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QXV0b1NvcnREaXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93c1swXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmlyc3RSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGZpcnN0Um93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gJ2FzYyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ2Rlc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldFNvcnRpbmdGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRzb3J0aW4sIF90YWJsZSRvcHRpb25zJHNvcnRpbjI7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuIDogY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvU29ydGluZ0ZuKCkgOiAoX3RhYmxlJG9wdGlvbnMkc29ydGluID0gKF90YWJsZSRvcHRpb25zJHNvcnRpbjIgPSB0YWJsZS5vcHRpb25zLnNvcnRpbmdGbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRzb3J0aW4yW2NvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHNvcnRpbiA6IHNvcnRpbmdGbnNbY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm5dO1xuICAgIH07XG4gICAgY29sdW1uLnRvZ2dsZVNvcnRpbmcgPSAoZGVzYywgbXVsdGkpID0+IHtcbiAgICAgIC8vIGlmIChjb2x1bW4uY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgIC8vICAgY29sdW1uLmNvbHVtbnMuZm9yRWFjaCgoYywgaSkgPT4ge1xuICAgICAgLy8gICAgIGlmIChjLmlkKSB7XG4gICAgICAvLyAgICAgICB0YWJsZS50b2dnbGVDb2x1bW5Tb3J0aW5nKGMuaWQsIHVuZGVmaW5lZCwgbXVsdGkgfHwgISFpKVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfSlcbiAgICAgIC8vICAgcmV0dXJuXG4gICAgICAvLyB9XG5cbiAgICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgb3V0c2lkZSBvZiB0YWJsZS5zZXRTb3J0aW5nIHRvIGJlIGluIHN5bmMgd2l0aCByZXJlbmRlclxuICAgICAgY29uc3QgbmV4dFNvcnRpbmdPcmRlciA9IGNvbHVtbi5nZXROZXh0U29ydGluZ09yZGVyKCk7XG4gICAgICBjb25zdCBoYXNNYW51YWxWYWx1ZSA9IHR5cGVvZiBkZXNjICE9PSAndW5kZWZpbmVkJyAmJiBkZXNjICE9PSBudWxsO1xuICAgICAgdGFibGUuc2V0U29ydGluZyhvbGQgPT4ge1xuICAgICAgICAvLyBGaW5kIGFueSBleGlzdGluZyBzb3J0aW5nIGZvciB0aGlzIGNvbHVtblxuICAgICAgICBjb25zdCBleGlzdGluZ1NvcnRpbmcgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICAgIGxldCBuZXdTb3J0aW5nID0gW107XG5cbiAgICAgICAgLy8gV2hhdCBzaG91bGQgd2UgZG8gd2l0aCB0aGlzIHNvcnQgYWN0aW9uP1xuICAgICAgICBsZXQgc29ydEFjdGlvbjtcbiAgICAgICAgbGV0IG5leHREZXNjID0gaGFzTWFudWFsVmFsdWUgPyBkZXNjIDogbmV4dFNvcnRpbmdPcmRlciA9PT0gJ2Rlc2MnO1xuXG4gICAgICAgIC8vIE11bHRpLW1vZGVcbiAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGggJiYgY29sdW1uLmdldENhbk11bHRpU29ydCgpICYmIG11bHRpKSB7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nU29ydGluZykge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ2FkZCc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vcm1hbCBtb2RlXG4gICAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGggJiYgZXhpc3RpbmdJbmRleCAhPT0gb2xkLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVwbGFjZSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ1NvcnRpbmcpIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAndG9nZ2xlJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZXBsYWNlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgdG9nZ2xlIHN0YXRlcyB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBzb3J0aW5nXG4gICAgICAgIGlmIChzb3J0QWN0aW9uID09PSAndG9nZ2xlJykge1xuICAgICAgICAgIC8vIElmIHdlIGFyZSBcImFjdHVhbGx5XCIgdG9nZ2xpbmcgKG5vdCBhIG1hbnVhbCBzZXQgdmFsdWUpLCBzaG91bGQgd2UgcmVtb3ZlIHRoZSBzb3J0aW5nP1xuICAgICAgICAgIGlmICghaGFzTWFudWFsVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElzIG91ciBpbnRlbnRpb24gdG8gcmVtb3ZlP1xuICAgICAgICAgICAgaWYgKCFuZXh0U29ydGluZ09yZGVyKSB7XG4gICAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVtb3ZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICdhZGQnKSB7XG4gICAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJG1heE11bDtcbiAgICAgICAgICBuZXdTb3J0aW5nID0gWy4uLm9sZCwge1xuICAgICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICAgIGRlc2M6IG5leHREZXNjXG4gICAgICAgICAgfV07XG4gICAgICAgICAgLy8gVGFrZSBsYXRlc3QgbiBjb2x1bW5zXG4gICAgICAgICAgbmV3U29ydGluZy5zcGxpY2UoMCwgbmV3U29ydGluZy5sZW5ndGggLSAoKF90YWJsZSRvcHRpb25zJG1heE11bCA9IHRhYmxlLm9wdGlvbnMubWF4TXVsdGlTb3J0Q29sQ291bnQpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRtYXhNdWwgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpO1xuICAgICAgICB9IGVsc2UgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnKSB7XG4gICAgICAgICAgLy8gVGhpcyBmbGlwcyAob3Igc2V0cykgdGhlXG4gICAgICAgICAgbmV3U29ydGluZyA9IG9sZC5tYXAoZCA9PiB7XG4gICAgICAgICAgICBpZiAoZC5pZCA9PT0gY29sdW1uLmlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgICAgICBkZXNjOiBuZXh0RGVzY1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc29ydEFjdGlvbiA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICBuZXdTb3J0aW5nID0gb2xkLmZpbHRlcihkID0+IGQuaWQgIT09IGNvbHVtbi5pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3U29ydGluZyA9IFt7XG4gICAgICAgICAgICBpZDogY29sdW1uLmlkLFxuICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U29ydGluZztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldEZpcnN0U29ydERpciA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfY29sdW1uJGNvbHVtbkRlZiRzb3I7XG4gICAgICBjb25zdCBzb3J0RGVzY0ZpcnN0ID0gKF9yZWYgPSAoX2NvbHVtbiRjb2x1bW5EZWYkc29yID0gY29sdW1uLmNvbHVtbkRlZi5zb3J0RGVzY0ZpcnN0KSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkc29yIDogdGFibGUub3B0aW9ucy5zb3J0RGVzY0ZpcnN0KSAhPSBudWxsID8gX3JlZiA6IGNvbHVtbi5nZXRBdXRvU29ydERpcigpID09PSAnZGVzYyc7XG4gICAgICByZXR1cm4gc29ydERlc2NGaXJzdCA/ICdkZXNjJyA6ICdhc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldE5leHRTb3J0aW5nT3JkZXIgPSBtdWx0aSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xuICAgICAgY29uc3QgZmlyc3RTb3J0RGlyZWN0aW9uID0gY29sdW1uLmdldEZpcnN0U29ydERpcigpO1xuICAgICAgY29uc3QgaXNTb3J0ZWQgPSBjb2x1bW4uZ2V0SXNTb3J0ZWQoKTtcbiAgICAgIGlmICghaXNTb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0U29ydERpcmVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NvcnRlZCAhPT0gZmlyc3RTb3J0RGlyZWN0aW9uICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVTb3J0aW5nUmVtb3ZhbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmIChcbiAgICAgIC8vIElmIGVuYWJsZVNvcnRSZW1vdmUsIGVuYWJsZSBpbiBnZW5lcmFsXG4gICAgICBtdWx0aSA/IChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJlbW92ZSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlIDogdHJ1ZSkgLy8gSWYgbXVsdGksIGRvbid0IGFsbG93IGlmIGVuYWJsZU11bHRpUmVtb3ZlKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTb3J0ZWQgPT09ICdkZXNjJyA/ICdhc2MnIDogJ2Rlc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhblNvcnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGUzO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVTb3J0aW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUzID0gdGFibGUub3B0aW9ucy5lbmFibGVTb3J0aW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA6IHRydWUpICYmICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0ID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYyLCBfY29sdW1uJGNvbHVtbkRlZiRlbmEyO1xuICAgICAgcmV0dXJuIChfcmVmMiA9IChfY29sdW1uJGNvbHVtbkRlZiRlbmEyID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVNdWx0aVNvcnQpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEyIDogdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVNvcnQpICE9IG51bGwgPyBfcmVmMiA6ICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNTb3J0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJHNvcnRpO1xuICAgICAgY29uc3QgY29sdW1uU29ydCA9IChfdGFibGUkZ2V0U3RhdGUkc29ydGkgPSB0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkc29ydGkuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICByZXR1cm4gIWNvbHVtblNvcnQgPyBmYWxzZSA6IGNvbHVtblNvcnQuZGVzYyA/ICdkZXNjJyA6ICdhc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldFNvcnRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkc29ydGkyLCBfdGFibGUkZ2V0U3RhdGUkc29ydGkzO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkc29ydGkyID0gKF90YWJsZSRnZXRTdGF0ZSRzb3J0aTMgPSB0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkc29ydGkzLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCkpICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkc29ydGkyIDogLTE7XG4gICAgfTtcbiAgICBjb2x1bW4uY2xlYXJTb3J0aW5nID0gKCkgPT4ge1xuICAgICAgLy9jbGVhciBzb3J0aW5nIGZvciBqdXN0IDEgY29sdW1uXG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKG9sZCA9PiBvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoID8gb2xkLmZpbHRlcihkID0+IGQuaWQgIT09IGNvbHVtbi5pZCkgOiBbXSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0VG9nZ2xlU29ydGluZ0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5Tb3J0ID0gY29sdW1uLmdldENhblNvcnQoKTtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgaWYgKCFjYW5Tb3J0KSByZXR1cm47XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xuICAgICAgICBjb2x1bW4udG9nZ2xlU29ydGluZyA9PSBudWxsIHx8IGNvbHVtbi50b2dnbGVTb3J0aW5nKHVuZGVmaW5lZCwgY29sdW1uLmdldENhbk11bHRpU29ydCgpID8gdGFibGUub3B0aW9ucy5pc011bHRpU29ydEV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmlzTXVsdGlTb3J0RXZlbnQoZSkgOiBmYWxzZSk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0U29ydGluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vblNvcnRpbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Tb3J0aW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0U29ydGluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRzLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0U29ydGluZyhkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuc29ydGluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcyA6IFtdKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0R3JvdXBlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0U29ydGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldFNvcnRlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0U29ydGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsU29ydGluZyB8fCAhdGFibGUuX2dldFNvcnRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IFZpc2liaWxpdHkgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5WaXNpYmlsaXR5OiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5WaXNpYmlsaXR5JywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5ID0gdmFsdWUgPT4ge1xuICAgICAgaWYgKGNvbHVtbi5nZXRDYW5IaWRlKCkpIHtcbiAgICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eShvbGQgPT4gKHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgW2NvbHVtbi5pZF06IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6ICFjb2x1bW4uZ2V0SXNWaXNpYmxlKClcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29sdW1uLmdldElzVmlzaWJsZSA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfdGFibGUkZ2V0U3RhdGUkY29sdW07XG4gICAgICBjb25zdCBjaGlsZENvbHVtbnMgPSBjb2x1bW4uY29sdW1ucztcbiAgICAgIHJldHVybiAoX3JlZiA9IGNoaWxkQ29sdW1ucy5sZW5ndGggPyBjaGlsZENvbHVtbnMuc29tZShjID0+IGMuZ2V0SXNWaXNpYmxlKCkpIDogKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uVmlzaWJpbGl0eSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bVtjb2x1bW4uaWRdKSAhPSBudWxsID8gX3JlZiA6IHRydWU7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuSGlkZSA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlSGlkaW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUhpZGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpO1xuICAgIH07XG4gICAgY29sdW1uLmdldFRvZ2dsZVZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eSA9PSBudWxsIHx8IGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5KGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuZ2V0QWxsQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5WaXNpYmlsaXR5XSwgY2VsbHMgPT4ge1xuICAgICAgcmV0dXJuIGNlbGxzLmZpbHRlcihjZWxsID0+IGNlbGwuY29sdW1uLmdldElzVmlzaWJsZSgpKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ19nZXRBbGxWaXNpYmxlQ2VsbHMnKSk7XG4gICAgcm93LmdldFZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5nZXRMZWZ0VmlzaWJsZUNlbGxzKCksIHJvdy5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMoKSwgcm93LmdldFJpZ2h0VmlzaWJsZUNlbGxzKCldLCAobGVmdCwgY2VudGVyLCByaWdodCkgPT4gWy4uLmxlZnQsIC4uLmNlbnRlciwgLi4ucmlnaHRdLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldFZpc2libGVDZWxscycpKTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICBjb25zdCBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QgPSAoa2V5LCBnZXRDb2x1bW5zKSA9PiB7XG4gICAgICByZXR1cm4gbWVtbygoKSA9PiBbZ2V0Q29sdW1ucygpLCBnZXRDb2x1bW5zKCkuZmlsdGVyKGQgPT4gZC5nZXRJc1Zpc2libGUoKSkubWFwKGQgPT4gZC5pZCkuam9pbignXycpXSwgY29sdW1ucyA9PiB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLmZpbHRlcihkID0+IGQuZ2V0SXNWaXNpYmxlID09IG51bGwgPyB2b2lkIDAgOiBkLmdldElzVmlzaWJsZSgpKTtcbiAgICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCBrZXkpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFZpc2libGVGbGF0Q29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0VmlzaWJsZUZsYXRDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0QWxsRmxhdENvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0TGVmdExlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldFJpZ2h0TGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRDZW50ZXJMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5ID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5WaXNpYmlsaXR5ID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5WaXNpYmlsaXR5KSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDoge30pO1xuICAgIH07XG4gICAgdGFibGUudG9nZ2xlQWxsQ29sdW1uc1Zpc2libGUgPSB2YWx1ZSA9PiB7XG4gICAgICB2YXIgX3ZhbHVlO1xuICAgICAgdmFsdWUgPSAoX3ZhbHVlID0gdmFsdWUpICE9IG51bGwgPyBfdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSgpO1xuICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eSh0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLnJlZHVjZSgob2JqLCBjb2x1bW4pID0+ICh7XG4gICAgICAgIC4uLm9iaixcbiAgICAgICAgW2NvbHVtbi5pZF06ICF2YWx1ZSA/ICEoY29sdW1uLmdldENhbkhpZGUgIT0gbnVsbCAmJiBjb2x1bW4uZ2V0Q2FuSGlkZSgpKSA6IHZhbHVlXG4gICAgICB9KSwge30pKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsQ29sdW1uc1Zpc2libGUgPSAoKSA9PiAhdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5zb21lKGNvbHVtbiA9PiAhKGNvbHVtbi5nZXRJc1Zpc2libGUgIT0gbnVsbCAmJiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpKTtcbiAgICB0YWJsZS5nZXRJc1NvbWVDb2x1bW5zVmlzaWJsZSA9ICgpID0+IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkuc29tZShjb2x1bW4gPT4gY29sdW1uLmdldElzVmlzaWJsZSA9PSBudWxsID8gdm9pZCAwIDogY29sdW1uLmdldElzVmlzaWJsZSgpKTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxDb2x1bW5zVmlzaWJpbGl0eUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHZhciBfdGFyZ2V0O1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSgoX3RhcmdldCA9IGUudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKSB7XG4gIHJldHVybiAhcG9zaXRpb24gPyB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSA6IHBvc2l0aW9uID09PSAnY2VudGVyJyA/IHRhYmxlLmdldENlbnRlclZpc2libGVMZWFmQ29sdW1ucygpIDogcG9zaXRpb24gPT09ICdsZWZ0JyA/IHRhYmxlLmdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMoKSA6IHRhYmxlLmdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zKCk7XG59XG5cbmNvbnN0IGZlYXR1cmVzID0gW0hlYWRlcnMsIFZpc2liaWxpdHksIE9yZGVyaW5nLCBQaW5uaW5nLCBGaWx0ZXJzLCBTb3J0aW5nLCBHcm91cGluZywgRXhwYW5kaW5nLCBQYWdpbmF0aW9uLCBSb3dTZWxlY3Rpb24sIENvbHVtblNpemluZ107XG5cbi8vXG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGluaXRpYWxTdGF0ZTtcbiAgaWYgKG9wdGlvbnMuZGVidWdBbGwgfHwgb3B0aW9ucy5kZWJ1Z1RhYmxlKSB7XG4gICAgY29uc29sZS5pbmZvKCdDcmVhdGluZyBUYWJsZSBJbnN0YW5jZS4uLicpO1xuICB9XG4gIGxldCB0YWJsZSA9IHtcbiAgICBfZmVhdHVyZXM6IGZlYXR1cmVzXG4gIH07XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gdGFibGUuX2ZlYXR1cmVzLnJlZHVjZSgob2JqLCBmZWF0dXJlKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBmZWF0dXJlLmdldERlZmF1bHRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldERlZmF1bHRPcHRpb25zKHRhYmxlKSk7XG4gIH0sIHt9KTtcbiAgY29uc3QgbWVyZ2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gICAgaWYgKHRhYmxlLm9wdGlvbnMubWVyZ2VPcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5tZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgfTtcbiAgY29uc3QgY29yZUluaXRpYWxTdGF0ZSA9IHt9O1xuICBsZXQgaW5pdGlhbFN0YXRlID0ge1xuICAgIC4uLmNvcmVJbml0aWFsU3RhdGUsXG4gICAgLi4uKChfb3B0aW9ucyRpbml0aWFsU3RhdGUgPSBvcHRpb25zLmluaXRpYWxTdGF0ZSkgIT0gbnVsbCA/IF9vcHRpb25zJGluaXRpYWxTdGF0ZSA6IHt9KVxuICB9O1xuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICB2YXIgX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0O1xuICAgIGluaXRpYWxTdGF0ZSA9IChfZmVhdHVyZSRnZXRJbml0aWFsU3QgPSBmZWF0dXJlLmdldEluaXRpYWxTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZmVhdHVyZS5nZXRJbml0aWFsU3RhdGUoaW5pdGlhbFN0YXRlKSkgIT0gbnVsbCA/IF9mZWF0dXJlJGdldEluaXRpYWxTdCA6IGluaXRpYWxTdGF0ZTtcbiAgfSk7XG4gIGNvbnN0IHF1ZXVlZCA9IFtdO1xuICBsZXQgcXVldWVkVGltZW91dCA9IGZhbHNlO1xuICBjb25zdCBjb3JlSW5zdGFuY2UgPSB7XG4gICAgX2ZlYXR1cmVzOiBmZWF0dXJlcyxcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9LFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICBfcXVldWU6IGNiID0+IHtcbiAgICAgIHF1ZXVlZC5wdXNoKGNiKTtcbiAgICAgIGlmICghcXVldWVkVGltZW91dCkge1xuICAgICAgICBxdWV1ZWRUaW1lb3V0ID0gdHJ1ZTtcblxuICAgICAgICAvLyBTY2hlZHVsZSBhIG1pY3JvdGFzayB0byBydW4gdGhlIHF1ZXVlZCBjYWxsYmFja3MgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgY2FsbCBzdGFjayAocmVuZGVyLCBldGMpIGhhcyBmaW5pc2hlZC5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgd2hpbGUgKHF1ZXVlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHF1ZXVlZC5zaGlmdCgpKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXVlZFRpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRTdGF0ZSh0YWJsZS5pbml0aWFsU3RhdGUpO1xuICAgIH0sXG4gICAgc2V0T3B0aW9uczogdXBkYXRlciA9PiB7XG4gICAgICBjb25zdCBuZXdPcHRpb25zID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCB0YWJsZS5vcHRpb25zKTtcbiAgICAgIHRhYmxlLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgfSxcbiAgICBnZXRTdGF0ZTogKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuc3RhdGU7XG4gICAgfSxcbiAgICBzZXRTdGF0ZTogdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5vcHRpb25zLm9uU3RhdGVDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uU3RhdGVDaGFuZ2UodXBkYXRlcik7XG4gICAgfSxcbiAgICBfZ2V0Um93SWQ6IChyb3csIGluZGV4LCBwYXJlbnQpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRnZXRSb3c7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGdldFJvdyA9IHRhYmxlLm9wdGlvbnMuZ2V0Um93SWQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0Um93SWQocm93LCBpbmRleCwgcGFyZW50KSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldFJvdyA6IGAke3BhcmVudCA/IFtwYXJlbnQuaWQsIGluZGV4XS5qb2luKCcuJykgOiBpbmRleH1gO1xuICAgIH0sXG4gICAgZ2V0Q29yZVJvd01vZGVsOiAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRDb3JlUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldENvcmVSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0Q29yZVJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0Q29yZVJvd01vZGVsKCk7XG4gICAgfSxcbiAgICAvLyBUaGUgZmluYWwgY2FsbHMgc3RhcnQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgbW9kZWwsXG4gICAgLy8gZXhwYW5kZWQgcm93cywgd2hpY2ggdGhlbiB3b3JrIHRoZWlyIHdheSB1cFxuXG4gICAgZ2V0Um93TW9kZWw6ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKTtcbiAgICB9LFxuICAgIC8vaW4gbmV4dCB2ZXJzaW9uLCB3ZSBzaG91bGQganVzdCBwYXNzIGluIHRoZSByb3cgbW9kZWwgYXMgdGhlIG9wdGlvbmFsIDJuZCBhcmdcbiAgICBnZXRSb3c6IChpZCwgc2VhcmNoQWxsKSA9PiB7XG4gICAgICBsZXQgcm93ID0gKHNlYXJjaEFsbCA/IHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpIDogdGFibGUuZ2V0Um93TW9kZWwoKSkucm93c0J5SWRbaWRdO1xuICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgcm93ID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkucm93c0J5SWRbaWRdO1xuICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldFJvdyBjb3VsZCBub3QgZmluZCByb3cgd2l0aCBJRDogJHtpZH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb3c7XG4gICAgfSxcbiAgICBfZ2V0RGVmYXVsdENvbHVtbkRlZjogbWVtbygoKSA9PiBbdGFibGUub3B0aW9ucy5kZWZhdWx0Q29sdW1uXSwgZGVmYXVsdENvbHVtbiA9PiB7XG4gICAgICB2YXIgX2RlZmF1bHRDb2x1bW47XG4gICAgICBkZWZhdWx0Q29sdW1uID0gKF9kZWZhdWx0Q29sdW1uID0gZGVmYXVsdENvbHVtbikgIT0gbnVsbCA/IF9kZWZhdWx0Q29sdW1uIDoge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXI6IHByb3BzID0+IHtcbiAgICAgICAgICBjb25zdCByZXNvbHZlZENvbHVtbkRlZiA9IHByb3BzLmhlYWRlci5jb2x1bW4uY29sdW1uRGVmO1xuICAgICAgICAgIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQ29sdW1uRGVmLmlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZm9vdGVyOiBwcm9wcyA9PiBwcm9wcy5oZWFkZXIuY29sdW1uLmlkLFxuICAgICAgICBjZWxsOiBwcm9wcyA9PiB7XG4gICAgICAgICAgdmFyIF9wcm9wcyRyZW5kZXJWYWx1ZSR0bywgX3Byb3BzJHJlbmRlclZhbHVlO1xuICAgICAgICAgIHJldHVybiAoX3Byb3BzJHJlbmRlclZhbHVlJHRvID0gKF9wcm9wcyRyZW5kZXJWYWx1ZSA9IHByb3BzLnJlbmRlclZhbHVlKCkpID09IG51bGwgfHwgX3Byb3BzJHJlbmRlclZhbHVlLnRvU3RyaW5nID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkcmVuZGVyVmFsdWUudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF9wcm9wcyRyZW5kZXJWYWx1ZSR0byA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC4uLnRhYmxlLl9mZWF0dXJlcy5yZWR1Y2UoKG9iaiwgZmVhdHVyZSkgPT4ge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgZmVhdHVyZS5nZXREZWZhdWx0Q29sdW1uRGVmID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldERlZmF1bHRDb2x1bW5EZWYoKSk7XG4gICAgICAgIH0sIHt9KSxcbiAgICAgICAgLi4uZGVmYXVsdENvbHVtblxuICAgICAgfTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyhvcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ19nZXREZWZhdWx0Q29sdW1uRGVmJykpLFxuICAgIF9nZXRDb2x1bW5EZWZzOiAoKSA9PiB0YWJsZS5vcHRpb25zLmNvbHVtbnMsXG4gICAgZ2V0QWxsQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuX2dldENvbHVtbkRlZnMoKV0sIGNvbHVtbkRlZnMgPT4ge1xuICAgICAgY29uc3QgcmVjdXJzZUNvbHVtbnMgPSBmdW5jdGlvbiAoY29sdW1uRGVmcywgcGFyZW50LCBkZXB0aCkge1xuICAgICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlcHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uRGVmcy5tYXAoY29sdW1uRGVmID0+IHtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjcmVhdGVDb2x1bW4odGFibGUsIGNvbHVtbkRlZiwgZGVwdGgsIHBhcmVudCk7XG4gICAgICAgICAgY29uc3QgZ3JvdXBpbmdDb2x1bW5EZWYgPSBjb2x1bW5EZWY7XG4gICAgICAgICAgY29sdW1uLmNvbHVtbnMgPSBncm91cGluZ0NvbHVtbkRlZi5jb2x1bW5zID8gcmVjdXJzZUNvbHVtbnMoZ3JvdXBpbmdDb2x1bW5EZWYuY29sdW1ucywgY29sdW1uLCBkZXB0aCArIDEpIDogW107XG4gICAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlY3Vyc2VDb2x1bW5zKGNvbHVtbkRlZnMpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsQ29sdW1ucycpKSxcbiAgICBnZXRBbGxGbGF0Q29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpXSwgYWxsQ29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gYWxsQ29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiB7XG4gICAgICAgIHJldHVybiBjb2x1bW4uZ2V0RmxhdENvbHVtbnMoKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsRmxhdENvbHVtbnMnKSksXG4gICAgX2dldEFsbEZsYXRDb2x1bW5zQnlJZDogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsRmxhdENvbHVtbnMoKV0sIGZsYXRDb2x1bW5zID0+IHtcbiAgICAgIHJldHVybiBmbGF0Q29sdW1ucy5yZWR1Y2UoKGFjYywgY29sdW1uKSA9PiB7XG4gICAgICAgIGFjY1tjb2x1bW4uaWRdID0gY29sdW1uO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsRmxhdENvbHVtbnNCeUlkJykpLFxuICAgIGdldEFsbExlYWZDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLl9nZXRPcmRlckNvbHVtbnNGbigpXSwgKGFsbENvbHVtbnMsIG9yZGVyQ29sdW1ucykgPT4ge1xuICAgICAgbGV0IGxlYWZDb2x1bW5zID0gYWxsQ29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKSk7XG4gICAgICByZXR1cm4gb3JkZXJDb2x1bW5zKGxlYWZDb2x1bW5zKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyhvcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldEFsbExlYWZDb2x1bW5zJykpLFxuICAgIGdldENvbHVtbjogY29sdW1uSWQgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuX2dldEFsbEZsYXRDb2x1bW5zQnlJZCgpW2NvbHVtbklkXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb2x1bW4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW1RhYmxlXSBDb2x1bW4gd2l0aCBpZCAnJHtjb2x1bW5JZH0nIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odGFibGUsIGNvcmVJbnN0YW5jZSk7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0YWJsZS5fZmVhdHVyZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IHRhYmxlLl9mZWF0dXJlc1tpbmRleF07XG4gICAgZmVhdHVyZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlVGFibGUgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVRhYmxlKHRhYmxlKTtcbiAgfVxuICByZXR1cm4gdGFibGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNlbGwodGFibGUsIHJvdywgY29sdW1uLCBjb2x1bW5JZCkge1xuICBjb25zdCBnZXRSZW5kZXJWYWx1ZSA9ICgpID0+IHtcbiAgICB2YXIgX2NlbGwkZ2V0VmFsdWU7XG4gICAgcmV0dXJuIChfY2VsbCRnZXRWYWx1ZSA9IGNlbGwuZ2V0VmFsdWUoKSkgIT0gbnVsbCA/IF9jZWxsJGdldFZhbHVlIDogdGFibGUub3B0aW9ucy5yZW5kZXJGYWxsYmFja1ZhbHVlO1xuICB9O1xuICBjb25zdCBjZWxsID0ge1xuICAgIGlkOiBgJHtyb3cuaWR9XyR7Y29sdW1uLmlkfWAsXG4gICAgcm93LFxuICAgIGNvbHVtbixcbiAgICBnZXRWYWx1ZTogKCkgPT4gcm93LmdldFZhbHVlKGNvbHVtbklkKSxcbiAgICByZW5kZXJWYWx1ZTogZ2V0UmVuZGVyVmFsdWUsXG4gICAgZ2V0Q29udGV4dDogbWVtbygoKSA9PiBbdGFibGUsIGNvbHVtbiwgcm93LCBjZWxsXSwgKHRhYmxlLCBjb2x1bW4sIHJvdywgY2VsbCkgPT4gKHtcbiAgICAgIHRhYmxlLFxuICAgICAgY29sdW1uLFxuICAgICAgcm93LFxuICAgICAgY2VsbDogY2VsbCxcbiAgICAgIGdldFZhbHVlOiBjZWxsLmdldFZhbHVlLFxuICAgICAgcmVuZGVyVmFsdWU6IGNlbGwucmVuZGVyVmFsdWVcbiAgICB9KSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ2VsbHMnLCAnY2VsbC5nZXRDb250ZXh0JykpXG4gIH07XG4gIHRhYmxlLl9mZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgIGZlYXR1cmUuY3JlYXRlQ2VsbCA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlQ2VsbChjZWxsLCBjb2x1bW4sIHJvdywgdGFibGUpO1xuICB9LCB7fSk7XG4gIHJldHVybiBjZWxsO1xufVxuXG5jb25zdCBjcmVhdGVSb3cgPSAodGFibGUsIGlkLCBvcmlnaW5hbCwgcm93SW5kZXgsIGRlcHRoLCBzdWJSb3dzLCBwYXJlbnRJZCkgPT4ge1xuICBsZXQgcm93ID0ge1xuICAgIGlkLFxuICAgIGluZGV4OiByb3dJbmRleCxcbiAgICBvcmlnaW5hbCxcbiAgICBkZXB0aCxcbiAgICBwYXJlbnRJZCxcbiAgICBfdmFsdWVzQ2FjaGU6IHt9LFxuICAgIF91bmlxdWVWYWx1ZXNDYWNoZToge30sXG4gICAgZ2V0VmFsdWU6IGNvbHVtbklkID0+IHtcbiAgICAgIGlmIChyb3cuX3ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpO1xuICAgICAgaWYgKCEoY29sdW1uICE9IG51bGwgJiYgY29sdW1uLmFjY2Vzc29yRm4pKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGNvbHVtbi5hY2Nlc3NvckZuKHJvdy5vcmlnaW5hbCwgcm93SW5kZXgpO1xuICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgIH0sXG4gICAgZ2V0VW5pcXVlVmFsdWVzOiBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll91bmlxdWVWYWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5hY2Nlc3NvckZuKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKCFjb2x1bW4uY29sdW1uRGVmLmdldFVuaXF1ZVZhbHVlcykge1xuICAgICAgICByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IFtyb3cuZ2V0VmFsdWUoY29sdW1uSWQpXTtcbiAgICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBjb2x1bW4uY29sdW1uRGVmLmdldFVuaXF1ZVZhbHVlcyhyb3cub3JpZ2luYWwsIHJvd0luZGV4KTtcbiAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9LFxuICAgIHJlbmRlclZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICB2YXIgX3JvdyRnZXRWYWx1ZTtcbiAgICAgIHJldHVybiAoX3JvdyRnZXRWYWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpICE9IG51bGwgPyBfcm93JGdldFZhbHVlIDogdGFibGUub3B0aW9ucy5yZW5kZXJGYWxsYmFja1ZhbHVlO1xuICAgIH0sXG4gICAgc3ViUm93czogc3ViUm93cyAhPSBudWxsID8gc3ViUm93cyA6IFtdLFxuICAgIGdldExlYWZSb3dzOiAoKSA9PiBmbGF0dGVuQnkocm93LnN1YlJvd3MsIGQgPT4gZC5zdWJSb3dzKSxcbiAgICBnZXRQYXJlbnRSb3c6ICgpID0+IHJvdy5wYXJlbnRJZCA/IHRhYmxlLmdldFJvdyhyb3cucGFyZW50SWQsIHRydWUpIDogdW5kZWZpbmVkLFxuICAgIGdldFBhcmVudFJvd3M6ICgpID0+IHtcbiAgICAgIGxldCBwYXJlbnRSb3dzID0gW107XG4gICAgICBsZXQgY3VycmVudFJvdyA9IHJvdztcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJvdyA9IGN1cnJlbnRSb3cuZ2V0UGFyZW50Um93KCk7XG4gICAgICAgIGlmICghcGFyZW50Um93KSBicmVhaztcbiAgICAgICAgcGFyZW50Um93cy5wdXNoKHBhcmVudFJvdyk7XG4gICAgICAgIGN1cnJlbnRSb3cgPSBwYXJlbnRSb3c7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50Um93cy5yZXZlcnNlKCk7XG4gICAgfSxcbiAgICBnZXRBbGxDZWxsczogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKV0sIGxlYWZDb2x1bW5zID0+IHtcbiAgICAgIHJldHVybiBsZWFmQ29sdW1ucy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNlbGwodGFibGUsIHJvdywgY29sdW1uLCBjb2x1bW4uaWQpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRBbGxDZWxscycpKSxcbiAgICBfZ2V0QWxsQ2VsbHNCeUNvbHVtbklkOiBtZW1vKCgpID0+IFtyb3cuZ2V0QWxsQ2VsbHMoKV0sIGFsbENlbGxzID0+IHtcbiAgICAgIHJldHVybiBhbGxDZWxscy5yZWR1Y2UoKGFjYywgY2VsbCkgPT4ge1xuICAgICAgICBhY2NbY2VsbC5jb2x1bW4uaWRdID0gY2VsbDtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldEFsbENlbGxzQnlDb2x1bW5JZCcpKVxuICB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlLl9mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0YWJsZS5fZmVhdHVyZXNbaV07XG4gICAgZmVhdHVyZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlUm93ID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVSb3cocm93LCB0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIHJvdztcbn07XG5cbi8vIHR5cGUgUGVyc29uID0ge1xuLy8gICBmaXJzdE5hbWU6IHN0cmluZ1xuLy8gICBsYXN0TmFtZTogc3RyaW5nXG4vLyAgIGFnZTogbnVtYmVyXG4vLyAgIHZpc2l0czogbnVtYmVyXG4vLyAgIHN0YXR1czogc3RyaW5nXG4vLyAgIHByb2dyZXNzOiBudW1iZXJcbi8vICAgY3JlYXRlZEF0OiBEYXRlXG4vLyAgIG5lc3RlZDoge1xuLy8gICAgIGZvbzogW1xuLy8gICAgICAge1xuLy8gICAgICAgICBiYXI6ICdiYXInXG4vLyAgICAgICB9XG4vLyAgICAgXVxuLy8gICAgIGJhcjogeyBzdWJCYXI6IGJvb2xlYW4gfVtdXG4vLyAgICAgYmF6OiB7XG4vLyAgICAgICBmb286ICdmb28nXG4vLyAgICAgICBiYXI6IHtcbi8vICAgICAgICAgYmF6OiAnYmF6J1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuXG4vLyBjb25zdCB0ZXN0OiBEZWVwS2V5czxQZXJzb24+ID0gJ25lc3RlZC5mb28uMC5iYXInXG4vLyBjb25zdCB0ZXN0MjogRGVlcEtleXM8UGVyc29uPiA9ICduZXN0ZWQuYmFyJ1xuXG4vLyBjb25zdCBoZWxwZXIgPSBjcmVhdGVDb2x1bW5IZWxwZXI8UGVyc29uPigpXG5cbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmZvbycsIHtcbi8vICAgY2VsbDogaW5mbyA9PiBpbmZvLmdldFZhbHVlKCksXG4vLyB9KVxuXG4vLyBoZWxwZXIuYWNjZXNzb3IoJ25lc3RlZC5mb28uMC5iYXInLCB7XG4vLyAgIGNlbGw6IGluZm8gPT4gaW5mby5nZXRWYWx1ZSgpLFxuLy8gfSlcblxuLy8gaGVscGVyLmFjY2Vzc29yKCduZXN0ZWQuYmFyJywge1xuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcbi8vIH0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbHVtbkhlbHBlcigpIHtcbiAgcmV0dXJuIHtcbiAgICBhY2Nlc3NvcjogKGFjY2Vzc29yLCBjb2x1bW4pID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgYWNjZXNzb3IgPT09ICdmdW5jdGlvbicgPyB7XG4gICAgICAgIC4uLmNvbHVtbixcbiAgICAgICAgYWNjZXNzb3JGbjogYWNjZXNzb3JcbiAgICAgIH0gOiB7XG4gICAgICAgIC4uLmNvbHVtbixcbiAgICAgICAgYWNjZXNzb3JLZXk6IGFjY2Vzc29yXG4gICAgICB9O1xuICAgIH0sXG4gICAgZGlzcGxheTogY29sdW1uID0+IGNvbHVtbixcbiAgICBncm91cDogY29sdW1uID0+IGNvbHVtblxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb3JlUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5vcHRpb25zLmRhdGFdLCBkYXRhID0+IHtcbiAgICBjb25zdCByb3dNb2RlbCA9IHtcbiAgICAgIHJvd3M6IFtdLFxuICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgcm93c0J5SWQ6IHt9XG4gICAgfTtcbiAgICBjb25zdCBhY2Nlc3NSb3dzID0gZnVuY3Rpb24gKG9yaWdpbmFsUm93cywgZGVwdGgsIHBhcmVudFJvdykge1xuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVwdGggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmlnaW5hbFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBhbiBleHBlbnNpdmUgY2hlY2sgYXQgc2NhbGUsIHNvIHdlIHNob3VsZCBtb3ZlIGl0IHNvbWV3aGVyZSBlbHNlLCBidXQgd2hlcmU/XG4gICAgICAgIC8vIGlmICghaWQpIHtcbiAgICAgICAgLy8gICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKGBnZXRSb3dJZCBleHBlY3RlZCBhbiBJRCwgYnV0IGdvdCAke2lkfWApXG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgcm93XG4gICAgICAgIGNvbnN0IHJvdyA9IGNyZWF0ZVJvdyh0YWJsZSwgdGFibGUuX2dldFJvd0lkKG9yaWdpbmFsUm93c1tpXSwgaSwgcGFyZW50Um93KSwgb3JpZ2luYWxSb3dzW2ldLCBpLCBkZXB0aCwgdW5kZWZpbmVkLCBwYXJlbnRSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudFJvdy5pZCk7XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBldmVyeSByb3cgaW4gYSBmbGF0IGFycmF5XG4gICAgICAgIHJvd01vZGVsLmZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIGV2ZXJ5IHJvdyBieSBpdHMgSURcbiAgICAgICAgcm93TW9kZWwucm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgLy8gUHVzaCB0YWJsZSByb3cgaW50byBwYXJlbnRcbiAgICAgICAgcm93cy5wdXNoKHJvdyk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCBzdWJyb3dzXG4gICAgICAgIGlmICh0YWJsZS5vcHRpb25zLmdldFN1YlJvd3MpIHtcbiAgICAgICAgICB2YXIgX3JvdyRvcmlnaW5hbFN1YlJvd3M7XG4gICAgICAgICAgcm93Lm9yaWdpbmFsU3ViUm93cyA9IHRhYmxlLm9wdGlvbnMuZ2V0U3ViUm93cyhvcmlnaW5hbFJvd3NbaV0sIGkpO1xuXG4gICAgICAgICAgLy8gVGhlbiByZWN1cnNpdmVseSBhY2Nlc3MgdGhlbVxuICAgICAgICAgIGlmICgoX3JvdyRvcmlnaW5hbFN1YlJvd3MgPSByb3cub3JpZ2luYWxTdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckb3JpZ2luYWxTdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgcm93LnN1YlJvd3MgPSBhY2Nlc3NSb3dzKHJvdy5vcmlnaW5hbFN1YlJvd3MsIGRlcHRoICsgMSwgcm93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH07XG4gICAgcm93TW9kZWwucm93cyA9IGFjY2Vzc1Jvd3MoZGF0YSk7XG4gICAgcmV0dXJuIHJvd01vZGVsO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRSb3dNb2RlbCcsICgpID0+IHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKSkpO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJSb3dzKHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKSB7XG4gIGlmICh0YWJsZS5vcHRpb25zLmZpbHRlckZyb21MZWFmUm93cykge1xuICAgIHJldHVybiBmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyhyb3dzLCBmaWx0ZXJSb3dJbXBsLCB0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlclJvd01vZGVsRnJvbVJvb3Qocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpO1xufVxuZnVuY3Rpb24gZmlsdGVyUm93TW9kZWxGcm9tTGVhZnMocm93c1RvRmlsdGVyLCBmaWx0ZXJSb3csIHRhYmxlKSB7XG4gIHZhciBfdGFibGUkb3B0aW9ucyRtYXhMZWE7XG4gIGNvbnN0IG5ld0ZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgY29uc3QgbmV3RmlsdGVyZWRSb3dzQnlJZCA9IHt9O1xuICBjb25zdCBtYXhEZXB0aCA9IChfdGFibGUkb3B0aW9ucyRtYXhMZWEgPSB0YWJsZS5vcHRpb25zLm1heExlYWZSb3dGaWx0ZXJEZXB0aCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heExlYSA6IDEwMDtcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJvd3MgPSBbXTtcblxuICAgIC8vIEZpbHRlciBmcm9tIGNoaWxkcmVuIHVwIGZpcnN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzVG9GaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgICBsZXQgcm93ID0gcm93c1RvRmlsdGVyW2ldO1xuICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KHRhYmxlLCByb3cuaWQsIHJvdy5vcmlnaW5hbCwgcm93LmluZGV4LCByb3cuZGVwdGgsIHVuZGVmaW5lZCwgcm93LnBhcmVudElkKTtcbiAgICAgIG5ld1Jvdy5jb2x1bW5GaWx0ZXJzID0gcm93LmNvbHVtbkZpbHRlcnM7XG4gICAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgZGVwdGggPCBtYXhEZXB0aCkge1xuICAgICAgICBuZXdSb3cuc3ViUm93cyA9IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpO1xuICAgICAgICByb3cgPSBuZXdSb3c7XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSAmJiAhbmV3Um93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSB8fCBuZXdSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJvd3M6IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvd3NUb0ZpbHRlciksXG4gICAgZmxhdFJvd3M6IG5ld0ZpbHRlcmVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld0ZpbHRlcmVkUm93c0J5SWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlclJvd01vZGVsRnJvbVJvb3Qocm93c1RvRmlsdGVyLCBmaWx0ZXJSb3csIHRhYmxlKSB7XG4gIHZhciBfdGFibGUkb3B0aW9ucyRtYXhMZWEyO1xuICBjb25zdCBuZXdGaWx0ZXJlZEZsYXRSb3dzID0gW107XG4gIGNvbnN0IG5ld0ZpbHRlcmVkUm93c0J5SWQgPSB7fTtcbiAgY29uc3QgbWF4RGVwdGggPSAoX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA9IHRhYmxlLm9wdGlvbnMubWF4TGVhZlJvd0ZpbHRlckRlcHRoKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA6IDEwMDtcblxuICAvLyBGaWx0ZXJzIHRvcCBsZXZlbCBhbmQgbmVzdGVkIHJvd3NcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuICAgIC8vIEZpbHRlciBmcm9tIHBhcmVudHMgZG93bndhcmQgZmlyc3RcblxuICAgIGNvbnN0IHJvd3MgPSBbXTtcblxuICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8gYW55IHN1YlJvd3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0ZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHJvdyA9IHJvd3NUb0ZpbHRlcltpXTtcbiAgICAgIGNvbnN0IHBhc3MgPSBmaWx0ZXJSb3cocm93KTtcbiAgICAgIGlmIChwYXNzKSB7XG4gICAgICAgIHZhciBfcm93JHN1YlJvd3MyO1xuICAgICAgICBpZiAoKF9yb3ckc3ViUm93czIgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MyLmxlbmd0aCAmJiBkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KHRhYmxlLCByb3cuaWQsIHJvdy5vcmlnaW5hbCwgcm93LmluZGV4LCByb3cuZGVwdGgsIHVuZGVmaW5lZCwgcm93LnBhcmVudElkKTtcbiAgICAgICAgICBuZXdSb3cuc3ViUm93cyA9IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpO1xuICAgICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgfVxuICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZUZpbHRlclJvd3Mocm93c1RvRmlsdGVyKSxcbiAgICBmbGF0Um93czogbmV3RmlsdGVyZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3RmlsdGVyZWRSb3dzQnlJZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRGaWx0ZXJlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMsIHRhYmxlLmdldFN0YXRlKCkuZ2xvYmFsRmlsdGVyXSwgKHJvd01vZGVsLCBjb2x1bW5GaWx0ZXJzLCBnbG9iYWxGaWx0ZXIpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICEoY29sdW1uRmlsdGVycyAhPSBudWxsICYmIGNvbHVtbkZpbHRlcnMubGVuZ3RoKSAmJiAhZ2xvYmFsRmlsdGVyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvd01vZGVsLmZsYXRSb3dzW2ldLmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3NbaV0uY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzID0gW107XG4gICAgY29uc3QgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzID0gW107XG4gICAgKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCA/IGNvbHVtbkZpbHRlcnMgOiBbXSkuZm9yRWFjaChkID0+IHtcbiAgICAgIHZhciBfZmlsdGVyRm4kcmVzb2x2ZUZpbHQ7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oZC5pZCk7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xuICAgICAgaWYgKCFmaWx0ZXJGbikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgYSB2YWxpZCAnY29sdW1uLmZpbHRlckZuJyBmb3IgY29sdW1uIHdpdGggdGhlIElEOiAke2NvbHVtbi5pZH0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLnB1c2goe1xuICAgICAgICBpZDogZC5pZCxcbiAgICAgICAgZmlsdGVyRm4sXG4gICAgICAgIHJlc29sdmVkVmFsdWU6IChfZmlsdGVyRm4kcmVzb2x2ZUZpbHQgPSBmaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZShkLnZhbHVlKSkgIT0gbnVsbCA/IF9maWx0ZXJGbiRyZXNvbHZlRmlsdCA6IGQudmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpbHRlcmFibGVJZHMgPSBjb2x1bW5GaWx0ZXJzLm1hcChkID0+IGQuaWQpO1xuICAgIGNvbnN0IGdsb2JhbEZpbHRlckZuID0gdGFibGUuZ2V0R2xvYmFsRmlsdGVyRm4oKTtcbiAgICBjb25zdCBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zID0gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIoKSk7XG4gICAgaWYgKGdsb2JhbEZpbHRlciAmJiBnbG9iYWxGaWx0ZXJGbiAmJiBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgZmlsdGVyYWJsZUlkcy5wdXNoKCdfX2dsb2JhbF9fJyk7XG4gICAgICBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgdmFyIF9nbG9iYWxGaWx0ZXJGbiRyZXNvbDtcbiAgICAgICAgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLnB1c2goe1xuICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgZmlsdGVyRm46IGdsb2JhbEZpbHRlckZuLFxuICAgICAgICAgIHJlc29sdmVkVmFsdWU6IChfZ2xvYmFsRmlsdGVyRm4kcmVzb2wgPSBnbG9iYWxGaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbEZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZShnbG9iYWxGaWx0ZXIpKSAhPSBudWxsID8gX2dsb2JhbEZpbHRlckZuJHJlc29sIDogZ2xvYmFsRmlsdGVyXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBjdXJyZW50Q29sdW1uRmlsdGVyO1xuICAgIGxldCBjdXJyZW50R2xvYmFsRmlsdGVyO1xuXG4gICAgLy8gRmxhZyB0aGUgcHJlZmlsdGVyZWQgcm93IG1vZGVsIHdpdGggZWFjaCBmaWx0ZXIgc3RhdGVcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCByb3cgPSByb3dNb2RlbC5mbGF0Um93c1tqXTtcbiAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzID0ge307XG4gICAgICBpZiAocmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVkQ29sdW1uRmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRDb2x1bW5GaWx0ZXIgPSByZXNvbHZlZENvbHVtbkZpbHRlcnNbaV07XG4gICAgICAgICAgY29uc3QgaWQgPSBjdXJyZW50Q29sdW1uRmlsdGVyLmlkO1xuXG4gICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgY29sdW1uIGZpbHRlciBzdGF0ZVxuICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzW2lkXSA9IGN1cnJlbnRDb2x1bW5GaWx0ZXIuZmlsdGVyRm4ocm93LCBpZCwgY3VycmVudENvbHVtbkZpbHRlci5yZXNvbHZlZFZhbHVlLCBmaWx0ZXJNZXRhID0+IHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YVtpZF0gPSBmaWx0ZXJNZXRhO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVkR2xvYmFsRmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRHbG9iYWxGaWx0ZXIgPSByZXNvbHZlZEdsb2JhbEZpbHRlcnNbaV07XG4gICAgICAgICAgY29uc3QgaWQgPSBjdXJyZW50R2xvYmFsRmlsdGVyLmlkO1xuICAgICAgICAgIC8vIFRhZyB0aGUgcm93IHdpdGggdGhlIGZpcnN0IHRydXRoeSBnbG9iYWwgZmlsdGVyIHN0YXRlXG4gICAgICAgICAgaWYgKGN1cnJlbnRHbG9iYWxGaWx0ZXIuZmlsdGVyRm4ocm93LCBpZCwgY3VycmVudEdsb2JhbEZpbHRlci5yZXNvbHZlZFZhbHVlLCBmaWx0ZXJNZXRhID0+IHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YVtpZF0gPSBmaWx0ZXJNZXRhO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByb3cuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJSb3dzSW1wbCA9IHJvdyA9PiB7XG4gICAgICAvLyBIb3Jpem9udGFsbHkgZmlsdGVyIHJvd3MgdGhyb3VnaCBlYWNoIGNvbHVtblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJhYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVyc1tmaWx0ZXJhYmxlSWRzW2ldXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvLyBGaWx0ZXIgZmluYWwgcm93cyB1c2luZyBhbGwgb2YgdGhlIGFjdGl2ZSBmaWx0ZXJzXG4gICAgcmV0dXJuIGZpbHRlclJvd3Mocm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RmlsdGVyZWRSb3dNb2RlbCcsICgpID0+IHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKSkpO1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycywgdGFibGUuZ2V0U3RhdGUoKS5nbG9iYWxGaWx0ZXIsIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKV0sIChwcmVSb3dNb2RlbCwgY29sdW1uRmlsdGVycywgZ2xvYmFsRmlsdGVyKSA9PiB7XG4gICAgaWYgKCFwcmVSb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCAmJiBjb2x1bW5GaWx0ZXJzLmxlbmd0aCkgJiYgIWdsb2JhbEZpbHRlcikge1xuICAgICAgcmV0dXJuIHByZVJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJhYmxlSWRzID0gWy4uLmNvbHVtbkZpbHRlcnMubWFwKGQgPT4gZC5pZCkuZmlsdGVyKGQgPT4gZCAhPT0gY29sdW1uSWQpLCBnbG9iYWxGaWx0ZXIgPyAnX19nbG9iYWxfXycgOiB1bmRlZmluZWRdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBmaWx0ZXJSb3dzSW1wbCA9IHJvdyA9PiB7XG4gICAgICAvLyBIb3Jpem9udGFsbHkgZmlsdGVyIHJvd3MgdGhyb3VnaCBlYWNoIGNvbHVtblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJhYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVyc1tmaWx0ZXJhYmxlSWRzW2ldXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIGZpbHRlclJvd3MocHJlUm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RmFjZXRlZFJvd01vZGVsJykpO1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkVW5pcXVlVmFsdWVzKCkge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT4gbWVtbygoKSA9PiB7XG4gICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgcmV0dXJuIFsoX3RhYmxlJGdldENvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCgpXTtcbiAgfSwgZmFjZXRlZFJvd01vZGVsID0+IHtcbiAgICBpZiAoIWZhY2V0ZWRSb3dNb2RlbCkgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICBsZXQgZmFjZXRlZFVuaXF1ZVZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWVzID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzW2ldLmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tqXTtcbiAgICAgICAgaWYgKGZhY2V0ZWRVbmlxdWVWYWx1ZXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgIHZhciBfZmFjZXRlZFVuaXF1ZVZhbHVlcyQ7XG4gICAgICAgICAgZmFjZXRlZFVuaXF1ZVZhbHVlcy5zZXQodmFsdWUsICgoX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkID0gZmFjZXRlZFVuaXF1ZVZhbHVlcy5nZXQodmFsdWUpKSAhPSBudWxsID8gX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkIDogMCkgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWNldGVkVW5pcXVlVmFsdWVzLnNldCh2YWx1ZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhY2V0ZWRVbmlxdWVWYWx1ZXM7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgYGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXNfJHtjb2x1bW5JZH1gKSk7XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IHtcbiAgICB2YXIgX3RhYmxlJGdldENvbHVtbjtcbiAgICByZXR1cm4gWyhfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsKCldO1xuICB9LCBmYWNldGVkUm93TW9kZWwgPT4ge1xuICAgIHZhciBfZmFjZXRlZFJvd01vZGVsJGZsYXQ7XG4gICAgaWYgKCFmYWNldGVkUm93TW9kZWwpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IChfZmFjZXRlZFJvd01vZGVsJGZsYXQgPSBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZmFjZXRlZFJvd01vZGVsJGZsYXQuZ2V0VW5pcXVlVmFsdWVzKGNvbHVtbklkKTtcbiAgICBpZiAodHlwZW9mIGZpcnN0VmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgZmFjZXRlZE1pbk1heFZhbHVlcyA9IFtmaXJzdFZhbHVlLCBmaXJzdFZhbHVlXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWVzID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzW2ldLmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tqXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgZmFjZXRlZE1pbk1heFZhbHVlc1swXSkge1xuICAgICAgICAgIGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+IGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMV0pIHtcbiAgICAgICAgICBmYWNldGVkTWluTWF4VmFsdWVzWzFdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhY2V0ZWRNaW5NYXhWYWx1ZXM7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMnKSk7XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nLCB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCgpXSwgKHNvcnRpbmcsIHJvd01vZGVsKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKHNvcnRpbmcgIT0gbnVsbCAmJiBzb3J0aW5nLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3Qgc29ydGluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nO1xuICAgIGNvbnN0IHNvcnRlZEZsYXRSb3dzID0gW107XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHNvcnRpbmdzIHRoYXQgY29ycmVzcG9uZCB0byBub24gZXhpc3RpbmcgY29sdW1uc1xuICAgIGNvbnN0IGF2YWlsYWJsZVNvcnRpbmcgPSBzb3J0aW5nU3RhdGUuZmlsdGVyKHNvcnQgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRDb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oc29ydC5pZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldENhblNvcnQoKTtcbiAgICB9KTtcbiAgICBjb25zdCBjb2x1bW5JbmZvQnlJZCA9IHt9O1xuICAgIGF2YWlsYWJsZVNvcnRpbmcuZm9yRWFjaChzb3J0RW50cnkgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKHNvcnRFbnRyeS5pZCk7XG4gICAgICBpZiAoIWNvbHVtbikgcmV0dXJuO1xuICAgICAgY29sdW1uSW5mb0J5SWRbc29ydEVudHJ5LmlkXSA9IHtcbiAgICAgICAgc29ydFVuZGVmaW5lZDogY29sdW1uLmNvbHVtbkRlZi5zb3J0VW5kZWZpbmVkLFxuICAgICAgICBpbnZlcnRTb3J0aW5nOiBjb2x1bW4uY29sdW1uRGVmLmludmVydFNvcnRpbmcsXG4gICAgICAgIHNvcnRpbmdGbjogY29sdW1uLmdldFNvcnRpbmdGbigpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHNvcnREYXRhID0gcm93cyA9PiB7XG4gICAgICAvLyBUaGlzIHdpbGwgYWxzbyBwZXJmb3JtIGEgc3RhYmxlIHNvcnRpbmcgdXNpbmcgdGhlIHJvdyBpbmRleFxuICAgICAgLy8gaWYgbmVlZGVkLlxuICAgICAgY29uc3Qgc29ydGVkRGF0YSA9IHJvd3MubWFwKHJvdyA9PiAoe1xuICAgICAgICAuLi5yb3dcbiAgICAgIH0pKTtcbiAgICAgIHNvcnRlZERhdGEuc29ydCgocm93QSwgcm93QikgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF2YWlsYWJsZVNvcnRpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgX3NvcnRFbnRyeSRkZXNjO1xuICAgICAgICAgIGNvbnN0IHNvcnRFbnRyeSA9IGF2YWlsYWJsZVNvcnRpbmdbaV07XG4gICAgICAgICAgY29uc3QgY29sdW1uSW5mbyA9IGNvbHVtbkluZm9CeUlkW3NvcnRFbnRyeS5pZF07XG4gICAgICAgICAgY29uc3QgaXNEZXNjID0gKF9zb3J0RW50cnkkZGVzYyA9IHNvcnRFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogc29ydEVudHJ5LmRlc2MpICE9IG51bGwgPyBfc29ydEVudHJ5JGRlc2MgOiBmYWxzZTtcbiAgICAgICAgICBsZXQgc29ydEludCA9IDA7XG5cbiAgICAgICAgICAvLyBBbGwgc29ydGluZyBpbnRzIHNob3VsZCBhbHdheXMgcmV0dXJuIGluIGFzY2VuZGluZyBvcmRlclxuICAgICAgICAgIGlmIChjb2x1bW5JbmZvLnNvcnRVbmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFWYWx1ZSA9IHJvd0EuZ2V0VmFsdWUoc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGJWYWx1ZSA9IHJvd0IuZ2V0VmFsdWUoc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGFVbmRlZmluZWQgPSBhVmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGJVbmRlZmluZWQgPSBiVmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhVW5kZWZpbmVkIHx8IGJVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc29ydEludCA9IGFVbmRlZmluZWQgJiYgYlVuZGVmaW5lZCA/IDAgOiBhVW5kZWZpbmVkID8gY29sdW1uSW5mby5zb3J0VW5kZWZpbmVkIDogLWNvbHVtbkluZm8uc29ydFVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvcnRJbnQgPT09IDApIHtcbiAgICAgICAgICAgIHNvcnRJbnQgPSBjb2x1bW5JbmZvLnNvcnRpbmdGbihyb3dBLCByb3dCLCBzb3J0RW50cnkuaWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHNvcnRpbmcgaXMgbm9uLXplcm8sIHRha2UgY2FyZSBvZiBkZXNjIGFuZCBpbnZlcnNpb25cbiAgICAgICAgICBpZiAoc29ydEludCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzRGVzYykge1xuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbHVtbkluZm8uaW52ZXJ0U29ydGluZykge1xuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRJbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dBLmluZGV4IC0gcm93Qi5pbmRleDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgc3ViLXJvd3MsIHNvcnQgdGhlbVxuICAgICAgc29ydGVkRGF0YS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgICAgIHNvcnRlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgaWYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93LnN1YlJvd3MgPSBzb3J0RGF0YShyb3cuc3ViUm93cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvcnRlZERhdGE7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcm93czogc29ydERhdGEocm93TW9kZWwucm93cyksXG4gICAgICBmbGF0Um93czogc29ydGVkRmxhdFJvd3MsXG4gICAgICByb3dzQnlJZDogcm93TW9kZWwucm93c0J5SWRcbiAgICB9O1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRTb3J0ZWRSb3dNb2RlbCcsICgpID0+IHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKSkpO1xufVxuXG5mdW5jdGlvbiBnZXRHcm91cGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nLCB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwoKV0sIChncm91cGluZywgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICFncm91cGluZy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgdGhlIGdyb3VwaW5nIGxpc3QgZG93biB0byBjb2x1bW5zIHRoYXQgZXhpc3RcbiAgICBjb25zdCBleGlzdGluZ0dyb3VwaW5nID0gZ3JvdXBpbmcuZmlsdGVyKGNvbHVtbklkID0+IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpO1xuICAgIGNvbnN0IGdyb3VwZWRGbGF0Um93cyA9IFtdO1xuICAgIGNvbnN0IGdyb3VwZWRSb3dzQnlJZCA9IHt9O1xuICAgIC8vIGNvbnN0IG9ubHlHcm91cGVkRmxhdFJvd3M6IFJvd1tdID0gW107XG4gICAgLy8gY29uc3Qgb25seUdyb3VwZWRSb3dzQnlJZDogUmVjb3JkPFJvd0lkLCBSb3c+ID0ge307XG4gICAgLy8gY29uc3Qgbm9uR3JvdXBlZEZsYXRSb3dzOiBSb3dbXSA9IFtdO1xuICAgIC8vIGNvbnN0IG5vbkdyb3VwZWRSb3dzQnlJZDogUmVjb3JkPFJvd0lkLCBSb3c+ID0ge307XG5cbiAgICAvLyBSZWN1cnNpdmVseSBncm91cCB0aGUgZGF0YVxuICAgIGNvbnN0IGdyb3VwVXBSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChyb3dzLCBkZXB0aCwgcGFyZW50SWQpIHtcbiAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlcHRoID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIEdyb3VwaW5nIGRlcHRoIGhhcyBiZWVuIGJlZW4gbWV0XG4gICAgICAvLyBTdG9wIGdyb3VwaW5nIGFuZCBzaW1wbHkgcmV3cml0ZSB0aGQgZGVwdGggYW5kIHJvdyByZWxhdGlvbnNoaXBzXG4gICAgICBpZiAoZGVwdGggPj0gZXhpc3RpbmdHcm91cGluZy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJvd3MubWFwKHJvdyA9PiB7XG4gICAgICAgICAgcm93LmRlcHRoID0gZGVwdGg7XG4gICAgICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBncm91cGVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgICBpZiAocm93LnN1YlJvd3MpIHtcbiAgICAgICAgICAgIHJvdy5zdWJSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvdy5zdWJSb3dzLCBkZXB0aCArIDEsIHJvdy5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uSWQgPSBleGlzdGluZ0dyb3VwaW5nW2RlcHRoXTtcblxuICAgICAgLy8gR3JvdXAgdGhlIHJvd3MgdG9nZXRoZXIgZm9yIHRoaXMgbGV2ZWxcbiAgICAgIGNvbnN0IHJvd0dyb3Vwc01hcCA9IGdyb3VwQnkocm93cywgY29sdW1uSWQpO1xuXG4gICAgICAvLyBQZWZvcm0gYWdncmVnYXRpb25zIGZvciBlYWNoIGdyb3VwXG4gICAgICBjb25zdCBhZ2dyZWdhdGVkR3JvdXBlZFJvd3MgPSBBcnJheS5mcm9tKHJvd0dyb3Vwc01hcC5lbnRyaWVzKCkpLm1hcCgoX3JlZiwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IFtncm91cGluZ1ZhbHVlLCBncm91cGVkUm93c10gPSBfcmVmO1xuICAgICAgICBsZXQgaWQgPSBgJHtjb2x1bW5JZH06JHtncm91cGluZ1ZhbHVlfWA7XG4gICAgICAgIGlkID0gcGFyZW50SWQgPyBgJHtwYXJlbnRJZH0+JHtpZH1gIDogaWQ7XG5cbiAgICAgICAgLy8gRmlyc3QsIFJlY3Vyc2UgdG8gZ3JvdXAgc3ViIHJvd3MgYmVmb3JlIGFnZ3JlZ2F0aW9uXG4gICAgICAgIGNvbnN0IHN1YlJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkoZ3JvdXBlZFJvd3MsIGRlcHRoICsgMSwgaWQpO1xuXG4gICAgICAgIC8vIEZsYXR0ZW4gdGhlIGxlYWYgcm93cyBvZiB0aGUgcm93cyBpbiB0aGlzIGdyb3VwXG4gICAgICAgIGNvbnN0IGxlYWZSb3dzID0gZGVwdGggPyBmbGF0dGVuQnkoZ3JvdXBlZFJvd3MsIHJvdyA9PiByb3cuc3ViUm93cykgOiBncm91cGVkUm93cztcbiAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlUm93KHRhYmxlLCBpZCwgbGVhZlJvd3NbMF0ub3JpZ2luYWwsIGluZGV4LCBkZXB0aCwgdW5kZWZpbmVkLCBwYXJlbnRJZCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocm93LCB7XG4gICAgICAgICAgZ3JvdXBpbmdDb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgICAgZ3JvdXBpbmdWYWx1ZSxcbiAgICAgICAgICBzdWJSb3dzLFxuICAgICAgICAgIGxlYWZSb3dzLFxuICAgICAgICAgIGdldFZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICAgICAgICAvLyBEb24ndCBhZ2dyZWdhdGUgY29sdW1ucyB0aGF0IGFyZSBpbiB0aGUgZ3JvdXBpbmdcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0dyb3VwaW5nLmluY2x1ZGVzKGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICBpZiAocm93Ll92YWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGdyb3VwZWRSb3dzWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9ncm91cGVkUm93cyQwJGdldFZhbDtcbiAgICAgICAgICAgICAgICByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IChfZ3JvdXBlZFJvd3MkMCRnZXRWYWwgPSBncm91cGVkUm93c1swXS5nZXRWYWx1ZShjb2x1bW5JZCkpICE9IG51bGwgPyBfZ3JvdXBlZFJvd3MkMCRnZXRWYWwgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFnZ3JlZ2F0ZSB0aGUgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpO1xuICAgICAgICAgICAgY29uc3QgYWdncmVnYXRlRm4gPSBjb2x1bW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRBZ2dyZWdhdGlvbkZuKCk7XG4gICAgICAgICAgICBpZiAoYWdncmVnYXRlRm4pIHtcbiAgICAgICAgICAgICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGFnZ3JlZ2F0ZUZuKGNvbHVtbklkLCBsZWFmUm93cywgZ3JvdXBlZFJvd3MpO1xuICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgIC8vIGlmIChzdWJSb3cuZ2V0SXNHcm91cGVkPy4oKSkge1xuICAgICAgICAgIC8vICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgLy8gICBvbmx5R3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAvLyAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgLy8gICBub25Hcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcm93O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWdncmVnYXRlZEdyb3VwZWRSb3dzO1xuICAgIH07XG4gICAgY29uc3QgZ3JvdXBlZFJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkocm93TW9kZWwucm93cywgMCk7XG4gICAgZ3JvdXBlZFJvd3MuZm9yRWFjaChzdWJSb3cgPT4ge1xuICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgLy8gaWYgKHN1YlJvdy5nZXRJc0dyb3VwZWQ/LigpKSB7XG4gICAgICAvLyAgIG9ubHlHcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgLy8gICBvbmx5R3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICBub25Hcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgLy8gICBub25Hcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgIC8vIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcm93czogZ3JvdXBlZFJvd3MsXG4gICAgICBmbGF0Um93czogZ3JvdXBlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IGdyb3VwZWRSb3dzQnlJZFxuICAgIH07XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEdyb3VwZWRSb3dNb2RlbCcsICgpID0+IHtcbiAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgdGFibGUuX2F1dG9SZXNldEV4cGFuZGVkKCk7XG4gICAgICB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCk7XG4gICAgfSk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGdyb3VwQnkocm93cywgY29sdW1uSWQpIHtcbiAgY29uc3QgZ3JvdXBNYXAgPSBuZXcgTWFwKCk7XG4gIHJldHVybiByb3dzLnJlZHVjZSgobWFwLCByb3cpID0+IHtcbiAgICBjb25zdCByZXNLZXkgPSBgJHtyb3cuZ2V0R3JvdXBpbmdWYWx1ZShjb2x1bW5JZCl9YDtcbiAgICBjb25zdCBwcmV2aW91cyA9IG1hcC5nZXQocmVzS2V5KTtcbiAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICBtYXAuc2V0KHJlc0tleSwgW3Jvd10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91cy5wdXNoKHJvdyk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH0sIGdyb3VwTWFwKTtcbn1cblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQsIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwoKSwgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93c10sIChleHBhbmRlZCwgcm93TW9kZWwsIHBhZ2luYXRlRXhwYW5kZWRSb3dzKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCBleHBhbmRlZCAhPT0gdHJ1ZSAmJiAhT2JqZWN0LmtleXMoZXhwYW5kZWQgIT0gbnVsbCA/IGV4cGFuZGVkIDoge30pLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBpZiAoIXBhZ2luYXRlRXhwYW5kZWRSb3dzKSB7XG4gICAgICAvLyBPbmx5IGV4cGFuZCByb3dzIGF0IHRoaXMgcG9pbnQgaWYgdGhleSBhcmUgYmVpbmcgcGFnaW5hdGVkXG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRSb3dzKHJvd01vZGVsKTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RXhwYW5kZWRSb3dNb2RlbCcpKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFJvd3Mocm93TW9kZWwpIHtcbiAgY29uc3QgZXhwYW5kZWRSb3dzID0gW107XG4gIGNvbnN0IGhhbmRsZVJvdyA9IHJvdyA9PiB7XG4gICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICBleHBhbmRlZFJvd3MucHVzaChyb3cpO1xuICAgIGlmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiByb3cuZ2V0SXNFeHBhbmRlZCgpKSB7XG4gICAgICByb3cuc3ViUm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgfVxuICB9O1xuICByb3dNb2RlbC5yb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiBleHBhbmRlZFJvd3MsXG4gICAgZmxhdFJvd3M6IHJvd01vZGVsLmZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiByb3dNb2RlbC5yb3dzQnlJZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYWdpbmF0aW9uUm93TW9kZWwob3B0cykge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLCB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKSwgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93cyA/IHVuZGVmaW5lZCA6IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWRdLCAocGFnaW5hdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VTaXplLFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHBhZ2luYXRpb247XG4gICAgbGV0IHtcbiAgICAgIHJvd3MsXG4gICAgICBmbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkXG4gICAgfSA9IHJvd01vZGVsO1xuICAgIGNvbnN0IHBhZ2VTdGFydCA9IHBhZ2VTaXplICogcGFnZUluZGV4O1xuICAgIGNvbnN0IHBhZ2VFbmQgPSBwYWdlU3RhcnQgKyBwYWdlU2l6ZTtcbiAgICByb3dzID0gcm93cy5zbGljZShwYWdlU3RhcnQsIHBhZ2VFbmQpO1xuICAgIGxldCBwYWdpbmF0ZWRSb3dNb2RlbDtcbiAgICBpZiAoIXRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0gZXhwYW5kUm93cyh7XG4gICAgICAgIHJvd3MsXG4gICAgICAgIGZsYXRSb3dzLFxuICAgICAgICByb3dzQnlJZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0ge1xuICAgICAgICByb3dzLFxuICAgICAgICBmbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWRcbiAgICAgIH07XG4gICAgfVxuICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzID0gW107XG4gICAgY29uc3QgaGFuZGxlUm93ID0gcm93ID0+IHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgIGlmIChyb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgcm93LnN1YlJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFnaW5hdGVkUm93TW9kZWwucm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgcmV0dXJuIHBhZ2luYXRlZFJvd01vZGVsO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRQYWdpbmF0aW9uUm93TW9kZWwnKSk7XG59XG5cbmV4cG9ydCB7IENvbHVtblNpemluZywgRXhwYW5kaW5nLCBGaWx0ZXJzLCBHcm91cGluZywgSGVhZGVycywgT3JkZXJpbmcsIFBhZ2luYXRpb24sIFBpbm5pbmcsIFJvd1NlbGVjdGlvbiwgU29ydGluZywgVmlzaWJpbGl0eSwgX2dldFZpc2libGVMZWFmQ29sdW1ucywgYWdncmVnYXRpb25GbnMsIGJ1aWxkSGVhZGVyR3JvdXBzLCBjcmVhdGVDZWxsLCBjcmVhdGVDb2x1bW4sIGNyZWF0ZUNvbHVtbkhlbHBlciwgY3JlYXRlUm93LCBjcmVhdGVUYWJsZSwgZGVmYXVsdENvbHVtblNpemluZywgZXhwYW5kUm93cywgZmlsdGVyRm5zLCBmbGF0dGVuQnksIGZ1bmN0aW9uYWxVcGRhdGUsIGdldENvcmVSb3dNb2RlbCwgZ2V0RXhwYW5kZWRSb3dNb2RlbCwgZ2V0RmFjZXRlZE1pbk1heFZhbHVlcywgZ2V0RmFjZXRlZFJvd01vZGVsLCBnZXRGYWNldGVkVW5pcXVlVmFsdWVzLCBnZXRGaWx0ZXJlZFJvd01vZGVsLCBnZXRHcm91cGVkUm93TW9kZWwsIGdldE1lbW9PcHRpb25zLCBnZXRQYWdpbmF0aW9uUm93TW9kZWwsIGdldFNvcnRlZFJvd01vZGVsLCBpc0Z1bmN0aW9uLCBpc051bWJlckFycmF5LCBpc1Jvd1NlbGVjdGVkLCBpc1N1YlJvd1NlbGVjdGVkLCBtYWtlU3RhdGVVcGRhdGVyLCBtZW1vLCBub29wLCBvcmRlckNvbHVtbnMsIHBhc3NpdmVFdmVudFN1cHBvcnRlZCwgcmVTcGxpdEFscGhhTnVtZXJpYywgc2VsZWN0Um93c0ZuLCBzaG91bGRBdXRvUmVtb3ZlRmlsdGVyLCBzb3J0aW5nRm5zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\n");

/***/ })

};
;